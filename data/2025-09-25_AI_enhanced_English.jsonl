{"id": "2509.19459", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.19459", "abs": "https://arxiv.org/abs/2509.19459", "authors": ["Yutong Guo", "Weiyu Luo", "Brian Demsky"], "title": "Automated Insertion of Flushes and Fences for Persistency", "comment": null, "summary": "CXL shared memory and persistent memory allow the contents of memory to\npersist beyond crashes. Stores to persistent or CXL memory are typically not\nimmediately made persistent; developers must manually flush the corresponding\ncache lines to force the data to be written to the underlying storage.\nCorrectly using flush and fence operations is known to be challenging. While\nstate-of-the-art tools can find missing flush instructions, they often require\nbug-revealing test cases. No existing tools can ensure the absence of missing\nflush bugs.\n  In this paper, we present PMRobust, a compiler that automatically inserts\nflush and fence operations to ensure that code using persistent memory is free\nfrom missing flush and fence bugs. PMRobust employs a novel static analysis\nwith optimizations that target newly allocated objects. We have evaluated\nPMRobust on persistent memory libraries and several persistent memory data\nstructures and measured a geometric mean overhead of 0.26% relative to the\noriginal benchmarks with hand-placed flush and fence operations.", "AI": {"tldr": "PMRobust automatically inserts persistence-enforcing flush/fence operations in code, guaranteeing safety from missing flush bugs and incurring minimal overhead, making persistent memory usage more reliable and developer-friendly.", "motivation": "Using persistent memory (like CXL shared memory) requires developers to manually flush cache lines to ensure data is truly persistent, which is error-prone and hard to get right. Existing tools detect some bugs but require special test cases and cannot guarantee the absence of missing flush instructions.", "method": "PMRobust is a compiler tool that automatically inserts flush and fence operations. It applies novel static analysis techniques and optimizations, especially focusing on newly allocated objects to ensure bug-free persistence guarantees without developer intervention.", "result": "PMRobust was tested on libraries and data structures using persistent memory and showed very low performance overhead (0.26% geometric mean) compared to manual flush/fence placement.", "conclusion": "PMRobust enables reliable bug-free usage of persistent memory by automating the insertion of flush and fence operations, eliminating developer errors and need for special test cases, with minimal overhead."}}
{"id": "2509.19533", "categories": ["cs.SE", "cs.AI", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.19533", "abs": "https://arxiv.org/abs/2509.19533", "authors": ["Mengdi Lu", "Steven Ding", "Furkan Alaca", "Philippe Charland"], "title": "Semantic-Aware Fuzzing: An Empirical Framework for LLM-Guided, Reasoning-Driven Input Mutation", "comment": null, "summary": "Security vulnerabilities in Internet-of-Things devices, mobile platforms, and\nautonomous systems remain critical. Traditional mutation-based fuzzers -- while\neffectively explore code paths -- primarily perform byte- or bit-level edits\nwithout semantic reasoning. Coverage-guided tools such as AFL++ use\ndictionaries, grammars, and splicing heuristics to impose shallow structural\nconstraints, leaving deeper protocol logic, inter-field dependencies, and\ndomain-specific semantics unaddressed. Conversely, reasoning-capable large\nlanguage models (LLMs) can leverage pretraining knowledge to understand input\nformats, respect complex constraints, and propose targeted mutations, much like\nan experienced reverse engineer or testing expert. However, lacking ground\ntruth for \"correct\" mutation reasoning makes supervised fine-tuning\nimpractical, motivating explorations of off-the-shelf LLMs via prompt-based\nfew-shot learning. To bridge this gap, we present an open-source microservices\nframework that integrates reasoning LLMs with AFL++ on Google's FuzzBench,\ntackling asynchronous execution and divergent hardware demands (GPU- vs.\nCPU-intensive) of LLMs and fuzzers. We evaluate four research questions: (R1)\nHow can reasoning LLMs be integrated into the fuzzing mutation loop? (R2) Do\nfew-shot prompts yield higher-quality mutations than zero-shot? (R3) Can prompt\nengineering with off-the-shelf models improve fuzzing directly? and (R4) Which\nopen-source reasoning LLMs perform best under prompt-only conditions?\nExperiments with Llama3.3, Deepseek-r1-Distill-Llama-70B, QwQ-32B, and Gemma3\nhighlight Deepseek as the most promising. Mutation effectiveness depends more\non prompt complexity and model choice than shot count. Response latency and\nthroughput bottlenecks remain key obstacles, offering directions for future\nwork.", "AI": {"tldr": "The paper introduces a framework that combines AFL++ fuzzing and large language models to improve software vulnerability discovery by generating smarter mutations. The study shows that model selection and prompt design are more important than the number of examples shown, with throughput bottlenecks remaining a challenge.", "motivation": "Traditional mutation-based fuzzers lack semantic reasoning and often miss deep vulnerabilities in IoT, mobile, and autonomous systems due to shallow input mutation strategies. Domain-specific constraints and protocol logic are typically not well handled, and supervised learning for correct mutation reasoning is impractical.", "method": "The authors present an open-source microservices framework that integrates reasoning-capable large language models (LLMs) with AFL++ fuzzer on FuzzBench. They focus on asynchronous execution and hardware differences, and evaluate the integration of LLMs via few-shot and zero-shot prompt engineering for mutation generation.", "result": "Among the tested models, Deepseek-r1-Distill-Llama-70B showed the most promising results. The effectiveness of LLM-based mutations is more influenced by prompt complexity and model choice than by the number of shots. Latency and throughput remain significant challenges.", "conclusion": "Integrating reasoning LLMs with state-of-the-art fuzzers can yield more effective mutation strategies by incorporating semantic and protocol knowledge. However, practical adoption requires overcoming hardware and performance bottlenecks, and selecting suitable LLMs and prompt strategies."}}
{"id": "2509.19587", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.19587", "abs": "https://arxiv.org/abs/2509.19587", "authors": ["Mohamed Ouf", "Haoyu Li", "Michael Zhang", "Mariam Guizani"], "title": "Reverse Engineering User Stories from Code using Large Language Models", "comment": null, "summary": "User stories are essential in agile development, yet often missing or\noutdated in legacy and poorly documented systems. We investigate whether large\nlanguage models (LLMs) can automatically recover user stories directly from\nsource code and how prompt design impacts output quality. Using 1,750 annotated\nC++ snippets of varying complexity, we evaluate five state-of-the-art LLMs\nacross six prompting strategies. Results show that all models achieve, on\naverage, an F1 score of 0.8 for code up to 200 NLOC. Our findings show that a\nsingle illustrative example enables the smallest model (8B) to match the\nperformance of a much larger 70B model. In contrast, structured reasoning via\nChain-of-Thought offers only marginal gains, primarily for larger models.", "AI": {"tldr": "LLMs can accurately recover user stories from C++ source code, with simple prompt design (such as providing an example) often sufficient even for smaller models. Chain-of-Thought only slightly improves results, primarily in larger models.", "motivation": "User stories are often crucial in agile software development, but are frequently missing or outdated in legacy code bases lacking documentation. This paper explores whether large language models (LLMs) can automatically recover user stories from source code, potentially aiding maintainers and developers.", "method": "The authors use 1,750 annotated C++ code snippets of varying complexity to assess five state-of-the-art LLMs (ranging in size) over six different prompt design strategies, including illustrative examples and structured reasoning (Chain-of-Thought).", "result": "All tested LLMs achieved an average F1 score of 0.8 for code snippets up to 200 NLOC. Notably, providing a single example enables the smallest model (8B) to reach the performance of a much larger model (70B). Chain-of-Thought strategies only provide minor improvements, mainly for the larger models.", "conclusion": "LLMs are effective at recovering user stories from source code, even in complex legacy systems, with simple prompt designs (e.g., single illustrative examples) being highly efficient, especially for smaller models. More complex prompting strategies offer limited additional benefits."}}
{"id": "2509.19673", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.19673", "abs": "https://arxiv.org/abs/2509.19673", "authors": ["Ahmed Aljohani", "Anamul Haque Mollah", "Hyunsook Do"], "title": "Assertion Messages with Large Language Models (LLMs) for Code", "comment": "Accepted at Proceedings of the 2025 Evaluation and Assessment in\n  Software Engineering (EASE '25)", "summary": "Assertion messages significantly enhance unit tests by clearly explaining the\nreasons behind test failures, yet they are frequently omitted by developers and\nautomated test-generation tools. Despite recent advancements, Large Language\nModels (LLMs) have not been systematically evaluated for their ability to\ngenerate informative assertion messages. In this paper, we introduce an\nevaluation of four state-of-the-art Fill-in-the-Middle (FIM) LLMs -\nQwen2.5-Coder-32B, Codestral-22B, CodeLlama-13B, and StarCoder - on a dataset\nof 216 Java test methods containing developer-written assertion messages. We\nfind that Codestral-22B achieves the highest quality score of 2.76 out of 5\nusing a human-like evaluation approach, compared to 3.24 for manually written\nmessages. Our ablation study shows that including descriptive test comments\nfurther improves Codestral's performance to 2.97, highlighting the critical\nrole of context in generating clear assertion messages. Structural analysis\ndemonstrates that all models frequently replicate developers' preferred\nlinguistic patterns. We discuss the limitations of the selected models and\nconventional text evaluation metrics in capturing diverse assertion message\nstructures. Our benchmark, evaluation results, and discussions provide an\nessential foundation for advancing automated, context-aware generation of\nassertion messages in test code. A replication package is available at\nhttps://doi.org/10.5281/zenodo.15293133", "AI": {"tldr": "LLMs can generate assertion messages for unit tests, though their performance lags behind human-written messages. More context leads to better quality, and the field needs improved evaluation methods and modeling. Codestral-22B currently leads among tested LLMs, especially when given descriptive comments.", "motivation": "Assertion messages are crucial in unit tests for clarifying reasons behind test failures, but are often neglected by developers and automated tools. LLMs have not been systematically evaluated for their capability to generate assertion messages.", "method": "The paper evaluates four advanced Fill-in-the-Middle LLMs (Qwen2.5-Coder-32B, Codestral-22B, CodeLlama-13B, StarCoder) using a dataset of 216 Java test methods with developer-written assertion messages. Scores are determined through human-like evaluation and ablation studies are performed to test the effect of adding descriptive test comments.", "result": "Codestral-22B achieved the highest LLM-generated score (2.76/5) compared to human-written messages (3.24/5). Adding descriptive test comments further improved Codestral's score to 2.97/5. All models frequently mirrored developer linguistic patterns. The study found limitations in current models and evaluation metrics.", "conclusion": "Context, such as descriptive comments, significantly improves LLM-generated assertion messages. The paper provides a foundation for further research in automated, context-aware generation of informative assertion messages for unit tests."}}
{"id": "2509.19607", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.19607", "abs": "https://arxiv.org/abs/2509.19607", "authors": ["William J. Bowman"], "title": "Macro-embedding Compiler Intermediate Languages in Racket", "comment": null, "summary": "We present the design and implementation of a macro-embedding of a family of\ncompiler intermediate languages, from a Scheme-like language to x86-64, into\nRacket. This embedding is used as part of a testing framework for a compilers\ncourse to derive interpreters for all the intermediate languages. The embedding\nimplements features including safe, functional abstractions as well as unsafe\nassembly features, and the interactions between the two at various intermediate\nstages.\n  This paper aims to demonstrate language-oriented techniques and abstractions\nfor implementing (1) a large family of languages and (2) interoperability\nbetween low- and high-level languages. The primary strength of this approach is\nthe high degree of code reuse and interoperability compared to implementing\neach interpreter separately. The design emphasizes modularity and\ncompositionality of an open set of language features by local macro expansion\ninto a single host language, rather than implementing a language pre-defined by\na closed set of features. This enables reuse from both the host language\n(Racket) and between intermediate languages, and enables interoperability\nbetween high- and low-level features, simplifying development of the\nintermediate language semantics. It also facilitates extending or redefining\nindividual language features in intermediate languages, and exposing multiple\ninterfaces to the embedded languages.", "AI": {"tldr": "This paper introduces a macro-embedding framework in Racket for a family of compiler intermediate languages, supporting both high- and low-level features. The approach promotes code reuse, modularity, and flexible extension of language features, streamlining interpreter generation and enhancing compiler course infrastructure.", "motivation": "The motivation of the paper is to improve the process of implementing and testing compiler intermediate languages by enabling more code reuse, modularity, and easier interoperability between high-level and low-level language features. Traditional approaches require separate interpreter implementations for each language, which is inefficient and less flexible.", "method": "The authors designed and implemented a macro-embedding approach in Racket. This method involves embedding a family of intermediate languages\u2014ranging from a Scheme-like language to x86-64 assembly\u2014into the host language Racket, primarily via local macro expansion. This allows abstraction and composition of language features, safe and unsafe, at different compiler stages.", "result": "The result is a flexible framework that allows interpreters for all these languages to be derived easily, facilitates code reuse, and supports interoperability and extensibility. It simplifies semantic development, enables multiple interfaces, and allows individual features of intermediate languages to be extended or redefined.", "conclusion": "The paper concludes that macro-embedding for compiler intermediate languages enables much greater code reuse, modularity, extensibility, and interoperability, compared to separately implemented interpreters. It offers a powerful and practical approach for language-oriented compiler design and education."}}
{"id": "2509.19708", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.19708", "abs": "https://arxiv.org/abs/2509.19708", "authors": ["Anand Kumar", "Vishal Khare", "Deepak Sharma", "Satyam Kumar", "Vijay Saini", "Anshul Yadav", "Sachendra Jain", "Ankit Rana", "Pratham Verma", "Vaibhav Meena", "Avinash Edubilli"], "title": "Intuition to Evidence: Measuring AI's True Impact on Developer Productivity", "comment": "16 pages, 10 figures, 5 tables", "summary": "We present a comprehensive real-world evaluation of AI-assisted software\ndevelopment tools deployed at enterprise scale. Over one year, 300 engineers\nacross multiple teams integrated an in-house AI platform (DeputyDev) that\ncombines code generation and automated review capabilities into their daily\nworkflows. Through rigorous cohort analysis, our study demonstrates\nstatistically significant productivity improvements, including an overall 31.8%\nreduction in PR review cycle time.\n  Developer adoption was strong, with 85% satisfaction for code review features\nand 93% expressing a desire to continue using the platform. Adoption patterns\nshowed systematic scaling from 4% engagement in month 1 to 83% peak usage by\nmonth 6, stabilizing at 60% active engagement. Top adopters achieved a 61%\nincrease in code volume pushed to production, contributing to approximately 30\nto 40% of code shipped to production through this tool, accounting for an\noverall 28% increase in code shipment volume.\n  Unlike controlled benchmark evaluations, our longitudinal analysis provides\nempirical evidence from production environments, revealing both the\ntransformative potential and practical deployment challenges of integrating AI\ninto enterprise software development workflows.", "AI": {"tldr": "A year-long, real-world study of an AI tool (DeputyDev) used by 300 engineers showed major gains: faster code reviews, more code shipped, and high satisfaction. Empirical results underline both the potential and the challenges of embedding AI in enterprise software development workflows.", "motivation": "AI-assisted software development tools are rapidly gaining attention, but most studies rely on controlled benchmarks rather than real-world, large-scale deployments. There is a need to empirically assess productivity, adoption, and challenges when such tools are actually used in enterprise environments.", "method": "A longitudinal, cohort-based empirical study was conducted over one year with 300 engineers using an in-house AI platform called DeputyDev. Productivity metrics, adoption rates, satisfaction scores, and code shipment volume were carefully tracked and analyzed as the platform was integrated into daily workflows.", "result": "The tool achieved a 31.8% reduction in PR review cycle time, an 85% satisfaction rate for review features, and a 93% desire to continue usage. Usage ramped to 83% engagement by month 6, later stabilizing at 60%. Top adopters saw a 61% increase in code volume, and the tool contributed to a 28% overall increase in shipped code.", "conclusion": "Deploying AI-assisted development tools at scale produces measurable productivity gains and high developer satisfaction, but also reveals unique challenges not observed in lab settings. Real-world adoption is feasible and impactful, provided practical deployment barriers are addressed."}}
{"id": "2509.19613", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.19613", "abs": "https://arxiv.org/abs/2509.19613", "authors": ["William J. Bowman"], "title": "Compilation as Multi-Language Semantics", "comment": null, "summary": "Modeling interoperability between programs in different languages is a key\nproblem when modeling verified and secure compilation, which has been\nsuccessfully addressed using multi-language semantics. Unfortunately, existing\nmodels of compilation using multi-language semantics define two variants of\neach compiler pass: a syntactic translation on open terms to model compilation,\nand a run-time translation of closed terms at multi-language boundaries to\nmodel interoperability.\n  In this talk, I discuss work-in-progress approach to uniformly model a\ncompiler entirely as a reduction system on open term in a multi-language\nsemantics, rather than as a syntactic translation. This simultaneously defines\nthe compiler and the interoperability semantics, reducing duplication. It also\nprovides interesting semantic insights. Normalization of the cross-language\nredexes performs ahead-of-time (AOT) compilation. Evaluation in the\nmulti-language models just-in-time (JIT) compilation. Confluence of\nmulti-language reduction implies compiler correctness, and part of the secure\ncompilation proof (full abstraction), enabling focus on the difficult part of\nthe proof. Subject reduction of the multi-language reduction implies\ntype-preservation of the compiler.", "AI": {"tldr": "The paper proposes modeling compilers and interoperability as a unified reduction system, reducing duplication and strengthening semantic guarantees like correctness and type-preservation for secure multi-language compilation.", "motivation": "Modeling interoperability between programs written in different languages is challenging, especially for verified and secure compilation. Traditional approaches using multi-language semantics require duplicating work by having separate models for compilation and interoperability.", "method": "The paper presents a work-in-progress approach to model the entire compiler as a reduction system on open terms within multi-language semantics, instead of using syntactic translation. This uniform method simultaneously defines both the compiler and the semantics of interoperability.", "result": "The approach reduces duplication and provides new semantic insights. It covers both ahead-of-time (AOT) and just-in-time (JIT) compilation within the model. Key properties like confluence and subject reduction in the multi-language reduction system imply compiler correctness and type-preservation, helping to concentrate proof efforts on the harder aspects.", "conclusion": "This unified reduction-based approach to modeling verified and secure compilation in multi-language semantics avoids duplication, clarifies compiler correctness and secure compilation proofs, and type-preservation, streamlining interoperability modeling."}}
{"id": "2509.19918", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.19918", "abs": "https://arxiv.org/abs/2509.19918", "authors": ["Micheline B\u00e9n\u00e9dicte Moumoula", "Serge Lionel Nikiema", "Alb\u00e9rick Euraste Djire", "Abdoul Kader Kabore", "Jacques Klein", "Tegawend\u00e9 F. Bissyande"], "title": "Beyond Language Barriers: Multi-Agent Coordination for Multi-Language Code Generation", "comment": null, "summary": "Producing high-quality code across multiple programming languages is\nincreasingly important as today's software systems are built on heterogeneous\nstacks. Large language models (LLMs) have advanced the state of automated\nprogramming, yet their proficiency varies sharply between languages, especially\nthose with limited training data such as Rust, Perl, OCaml, and Erlang. Many\ncurrent solutions including language-specific fine-tuning, multi-agent\norchestration, transfer learning, and intermediate-representation pipelines\nstill approach each target language in isolation, missing opportunities to\nshare knowledge or exploit recurring cross-language patterns.\n  XL-CoGen tackles this challenge with a coordinated multi-agent architecture\nthat integrates intermediate representation, code generation, translation, and\nautomated repair. Its distinguishing feature is a data-driven mechanism for\nselecting bridging languages: empirically derived transfer matrices identify\nthe best intermediate languages based on demonstrated translation success\nrather than raw generation accuracy. The system performs early output\nvalidation, iteratively corrects errors, and reuses intermediate artifacts as\ncontextual scaffolds for subsequent translations.\n  Extensive experiments show that XL-CoGen yields notable improvements with 13\npercentage-point gains over the strongest fine-tuned baseline and as much as 30\npercentage points over existing single-language multi-agent methods. Ablation\nstudies further demonstrate that compatibility-guided bridging significantly\noutperforms LLM-based heuristics, confirming the value of cumulative\ncross-language knowledge transfer.", "AI": {"tldr": "XL-CoGen introduces a multi-agent system for code generation across diverse languages, using data-driven bridging and cross-language knowledge transfer to achieve significantly better results over existing methods.", "motivation": "Ensuring high-quality code generation across various programming languages is crucial due to the heterogeneous nature of modern software stacks. Existing LLM-based solutions struggle with languages that have limited training data and often treat each language separately, missing opportunities to transfer knowledge or leverage patterns across languages.", "method": "XL-CoGen uses a coordinated multi-agent architecture combining intermediate representation, code generation, translation, and automated code repair. A key innovation is its data-driven selection of bridging languages using transfer matrices, enabling effective cross-language translation and validating outputs early with iterative correction and contextual scaffolding.", "result": "XL-CoGen delivers substantial improvements, achieving up to 13 percentage points gain over the best fine-tuned baseline and up to 30 percentage points over single-language multi-agent systems. Ablation studies show that transfer-matrix-driven bridging outperforms heuristics-based approaches, underscoring the advantage of cumulative cross-language knowledge transfer.", "conclusion": "XL-CoGen establishes a new state-of-the-art in multi-language code generation, especially for languages with limited training data, by leveraging data-driven cross-language knowledge sharing and coordinated agent collaboration."}}
{"id": "2509.20020", "categories": ["cs.PL", "cs.LG", "cs.MS", "cs.SC", "F.2.2; I.1.2; I.1.3"], "pdf": "https://arxiv.org/pdf/2509.20020", "abs": "https://arxiv.org/abs/2509.20020", "authors": ["Maurice Wenig", "Paul G. Rump", "Mark Blacher", "Joachim Giesen"], "title": "The Syntax and Semantics of einsum", "comment": "21 pages, 1 figure. Includes formal definitions, proofs of algebraic\n  properties, and nesting/denesting rules for the einsum notation", "summary": "In 2011, einsum was introduced to NumPy as a practical and convenient\nnotation for tensor expressions in machine learning, quantum circuit\nsimulation, and other fields. It has since been implemented in additional\nPython frameworks such as PyTorch and TensorFlow, as well as in other\nprogramming languages such as Julia. Despite its practical success, the einsum\nnotation still lacks a solid theoretical basis, and is not unified across the\ndifferent frameworks, limiting opportunities for formal reasoning and\nsystematic optimization. In this work, we discuss the terminology of tensor\nexpressions and provide a formal definition of the einsum language. Based on\nthis definition, we formalize and prove important equivalence rules for tensor\nexpressions and highlight their relevance in practical applications.", "AI": {"tldr": "This paper builds a formal theoretical foundation for the widely-used einsum tensor notation, proving equivalence rules and fostering better interoperability and optimization in machine learning and scientific computing frameworks.", "motivation": "The einsum notation is widely used for tensor expressions in various fields, but it lacks a consistent theoretical framework and is implemented differently across major libraries. This fragmentation limits formal reasoning, verification, and optimization.", "method": "The paper discusses existing terminology related to tensor expressions and develops a formal definition of the einsum language. It then establishes and proves key equivalence rules based on this formalization, connecting these rules to relevant practical applications.", "result": "The authors provide a rigorous formal foundation for the einsum notation, prove important equivalence rules, and demonstrate their practical value for systematic reasoning and optimization in computational frameworks.", "conclusion": "A unified and formal definition of einsum enables systematic reasoning, verification, and more effective implementation and optimization across different frameworks."}}
{"id": "2509.20010", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20010", "abs": "https://arxiv.org/abs/2509.20010", "authors": ["Xiaoning Ren", "Yuhang Ye", "Xiongfei Wu", "Yueming Wu", "Yinxing Xue"], "title": "Demystifying the Evolution of Neural Networks with BOM Analysis: Insights from a Large-Scale Study of 55,997 GitHub Repositories", "comment": "11pages,8figures", "summary": "Neural networks have become integral to many fields due to their exceptional\nperformance. The open-source community has witnessed a rapid influx of neural\nnetwork (NN) repositories with fast-paced iterations, making it crucial for\npractitioners to analyze their evolution to guide development and stay ahead of\ntrends. While extensive research has explored traditional software evolution\nusing Software Bill of Materials (SBOMs), these are ill-suited for NN software,\nwhich relies on pre-defined modules and pre-trained models (PTMs) with distinct\ncomponent structures and reuse patterns. Conceptual AI Bills of Materials\n(AIBOMs) also lack practical implementations for large-scale evolutionary\nanalysis. To fill this gap, we introduce the Neural Network Bill of Material\n(NNBOM), a comprehensive dataset construct tailored for NN software. We create\na large-scale NNBOM database from 55,997 curated PyTorch GitHub repositories,\ncataloging their TPLs, PTMs, and modules. Leveraging this database, we conduct\na comprehensive empirical study of neural network software evolution across\nsoftware scale, component reuse, and inter-domain dependency, providing\nmaintainers and developers with a holistic view of its long-term trends.\nBuilding on these findings, we develop two prototype applications,\n\\textit{Multi repository Evolution Analyzer} and \\textit{Single repository\nComponent Assessor and Recommender}, to demonstrate the practical value of our\nanalysis.", "AI": {"tldr": "This paper introduces NNBOM, a dedicated Bill of Materials dataset for neural networks, constructed from nearly 56K PyTorch GitHub repositories. It provides empirical insights into NN software evolution and demonstrates practical utility through prototype analysis and recommendation tools.", "motivation": "Existing SBOMs and conceptual AIBOMs do not meet the evolving needs of neural network software analysis because of their unique reliance on modules and pre-trained models. There is a lack of practical tools for large-scale evolutionary analysis in this domain, necessitating an NN-specific solution.", "method": "Construction of a large-scale NNBOM from 55,997 PyTorch GitHub repositories. Empirical analysis of neural network software evolution regarding scale, reuse, and dependencies. Development of supporting prototype applications.", "result": "Creation of a large-scale, curated NNBOM database. Comprehensive analysis showing trends in NN software evolution. Development of two prototype applications that validate the usefulness of NNBOM-based insights for repository maintenance and component recommendation.", "conclusion": "The authors have established Neural Network Bill of Materials (NNBOM) as a formal dataset structure for analyzing the evolution of neural network repositories, showing its effectiveness with prototype tools."}}
{"id": "2509.20136", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20136", "abs": "https://arxiv.org/abs/2509.20136", "authors": ["Wei Zhang", "Jack Yang", "Renshuai Tao", "Lingzheng Chai", "Shawn Guo", "Jiajun Wu", "Xiaoming Chen", "Ganqu Cui", "Ning Ding", "Xander Xu", "Hu Wei", "Bowen Zhou"], "title": "V-GameGym: Visual Game Generation for Code Large Language Models", "comment": null, "summary": "Code large language models have demonstrated remarkable capabilities in\nprogramming tasks, yet current benchmarks primarily focus on single modality\nrather than visual game development. Most existing code-related benchmarks\nevaluate syntax correctness and execution accuracy, overlooking critical\ngame-specific metrics such as playability, visual aesthetics, and user\nengagement that are essential for real-world deployment. To address the gap\nbetween current LLM capabilities in algorithmic problem-solving and competitive\nprogramming versus the comprehensive requirements of practical game\ndevelopment, we present V-GameGym, a comprehensive benchmark comprising 2,219\nhigh-quality samples across 100 thematic clusters derived from real-world\nrepositories, adopting a novel clustering-based curation methodology to ensure\nboth diversity and structural completeness. Further, we introduce a multimodal\nevaluation framework with an automated LLM-driven pipeline for visual code\nsynthesis using complete UI sandbox environments. Our extensive analysis\nreveals that V-GameGym effectively bridges the gap between code generation\naccuracy and practical game development workflows, providing quantifiable\nquality metrics for visual programming and interactive element generation.", "AI": {"tldr": "Current code LLM benchmarks miss key aspects of visual game development. V-GameGym is a new, diverse benchmark and evaluation framework that assesses LLMs on tasks like playability and visual appeal, supporting better real-world use in game development.", "motivation": "Existing benchmarks for code large language models (LLMs) focus on basic programming tasks and single modalities, neglecting important aspects of game development like playability, visual appeal, and user interaction. This limits the real-world applicability of LLMs in game development.", "method": "The paper introduces V-GameGym, a new benchmark containing 2,219 curated game development samples from 100 clusters, using a novel clustering-based selection method. It also proposes a multimodal evaluation framework with an automated pipeline for assessing visual code synthesis within UI sandbox environments.", "result": "V-GameGym enables robust evaluation of code LLMs on comprehensive game development tasks. The benchmark provides diversity and completeness, and the evaluation framework delivers quantifiable metrics for both the quality of visual programming and interactive elements.", "conclusion": "V-GameGym bridges the gap between current code LLM benchmarks and practical game development demands by focusing on visual and interactive metrics, supporting better assessment of LLMs for real-world game creation tasks."}}
{"id": "2509.20149", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20149", "abs": "https://arxiv.org/abs/2509.20149", "authors": ["Jianzhang Zhang", "Jialong Zhou", "Nan Niu", "Chuang Liu"], "title": "Enhancing Requirement Traceability through Data Augmentation Using Large Language Models", "comment": null, "summary": "Requirements traceability is crucial in software engineering to ensure\nconsistency between requirements and code. However, existing automated\ntraceability methods are constrained by the scarcity of training data and\nchallenges in bridging the semantic gap between artifacts. This study aims to\naddress the data scarcity problem in requirements traceability by employing\nlarge language models (LLMs) for data augmentation. We propose a novel approach\nthat utilizes prompt-based techniques with LLMs to generate augmented\nrequirement-to-code trace links, thereby enhancing the training dataset. Four\nLLMs (Gemini 1.5 Pro, Claude 3, GPT-3.5, and GPT-4) were used, employing both\nzero-shot and few-shot templates. Moreover, we optimized the encoder component\nof the tracing model to improve its efficiency and adaptability to augmented\ndata. The key contributions of this paper are: (1) proposing and evaluating\nfour prompt templates for data augmentation; (2) providing a comparative\nanalysis of four LLMs for generating trace links; (3) enhancing the model's\nencoder for improved adaptability to augmented datasets. Experimental results\nshow that our approach significantly enhances model performance, achieving an\nF1 score improvement of up to 28.59%, thus demonstrating its effectiveness and\npotential for practical application.", "AI": {"tldr": "This paper tackles the data scarcity issue in automated requirements traceability using large language models for data augmentation. Leveraging different prompt-based templates and optimizing the model's encoder, the approach greatly improves performance, highlighting the practical value of LLMs for trace link generation.", "motivation": "Automated requirements traceability is essential in software engineering but is currently limited by a lack of sufficient training data and a persistent semantic gap between requirements and code.", "method": "The paper uses large language models (LLMs) for prompt-based data augmentation, applying zero-shot and few-shot templates with four different LLMs (Gemini 1.5 Pro, Claude 3, GPT-3.5, GPT-4) to generate augmented requirement-to-code trace links. The encoder of the tracing model is also optimized for efficiency and adaptability to the augmented data.", "result": "Experimental results demonstrate that the proposed approach significantly boosts model performance, with an F1 score improvement of up to 28.59%.", "conclusion": "The use of LLM-based data augmentation and encoder optimization provides a promising solution to data scarcity challenges in requirements traceability, leading to substantial improvements in traceability automation."}}
{"id": "2509.20172", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.20172", "abs": "https://arxiv.org/abs/2509.20172", "authors": ["Daniel Maninger", "Leon Chemnitz", "Amir Molzam Sharifloo", "Jannis Brugger", "Mira Mezini"], "title": "Benchmarking Web API Integration Code Generation", "comment": "To be published in Proceedings of 2nd ACM International Conference on\n  AI-powered Software, Benchmark & Dataset Track (AIware '25)", "summary": "API integration is a cornerstone of our digital infrastructure, enabling\nsoftware systems to connect and interact. However, as shown by many studies,\nwriting or generating correct code to invoke APIs, particularly web APIs, is\nchallenging. Although large language models~(LLMs) have become popular in\nsoftware development, their effectiveness in automating the generation of web\nAPI integration code remains unexplored. In order to address this, we present a\ndataset and evaluation pipeline designed to assess the ability of LLMs to\ngenerate web API invocation code. Our experiments with several open-source LLMs\nreveal that generating API invocations poses a significant challenge, resulting\nin hallucinated endpoints, incorrect argument usage, and other errors. None of\nthe evaluated open-source models were able to solve more than 40% of the tasks.", "AI": {"tldr": "Open-source LLMs have trouble accurately generating web API code, with less than 40% task success in tests. API invocation remains a major challenge for today's models.", "motivation": "API integration is essential in digital infrastructure, yet generating correct code for invoking web APIs is often difficult and error-prone. With the rise of large language models (LLMs) in software development, it's necessary to assess their ability to automate API code generation.", "method": "The authors introduce a dataset and an evaluation pipeline specifically designed to test and analyze the performance of LLMs in generating web API invocation code. They conduct experiments using various open-source LLMs.", "result": "Experimental results show that current open-source LLMs frequently make mistakes in generating API invocation code, such as hallucinating endpoints and misusing arguments. No tested model correctly generated solutions for more than 40% of the tasks.", "conclusion": "LLMs, despite their popularity in software development, currently struggle with automating web API integration code generation. Significant improvements are needed before LLMs can reliably perform this task."}}
{"id": "2509.20215", "categories": ["cs.SE", "cs.AI", "cs.AR"], "pdf": "https://arxiv.org/pdf/2509.20215", "abs": "https://arxiv.org/abs/2509.20215", "authors": ["Guang Yang", "Wei Zheng", "Xiang Chen", "Yifan Sun", "Fengji Zhang", "Terry Yue Zhuo"], "title": "The Cream Rises to the Top: Efficient Reranking Method for Verilog Code Generation", "comment": "Under review ICASSP 2026", "summary": "LLMs face significant challenges in Verilog generation due to limited\ndomain-specific knowledge. While sampling techniques improve pass@k metrics,\nhardware engineers need one trustworthy solution rather than uncertain\ncandidates. To bridge this gap, we formulate it as a semantic alignment problem\nbetween requirements and Verilog implementations, and propose VCD-RNK, a\ndiscriminator model tailored for efficient Verilog code reranking.\nSpecifically, VCD-RNKincorporates Verilog-specific reasoning by distilling\nexpert knowledge across three dimensions: code semantic analysis, test case\ngeneration, and functional correctness assessment. By explicitly simulating the\nabove reasoning processes during inference, VCD-RNK effectively avoids\ncomputationally intensive test execution in existing methods.", "AI": {"tldr": "LLMs aren't reliable for Verilog code generation due to specialized knowledge gaps. The paper introduces VCD-RNK, a domain-aware model that reranks code by simulating expert reasoning, improving code reliability without expensive testing.", "motivation": "LLMs struggle to generate reliable Verilog code due to lack of specialized domain knowledge. Hardware engineers require a single trustworthy solution, not multiple uncertain code samples. Existing evaluation methods are computationally expensive and don't guarantee semantic correctness.", "method": "The paper formulates code generation as a semantic alignment issue and introduces VCD-RNK, a discriminator model designed to rerank Verilog code candidates. VCD-RNK simulates expert reasoning (code analysis, test generation, correctness assessment) via distilled knowledge to evaluate code quality without expensive test executions.", "result": "VCD-RNK effectively reranks Verilog code candidates by leveraging domain-specific reasoning, enabling efficient and trustworthy selection of correct code. It avoids the need for costly computational tests required by previous approaches.", "conclusion": "By incorporating expert-level reasoning dimensions and semantic alignment techniques, VCD-RNK enables efficient and reliable selection of correct Verilog code, addressing key limitations of LLMs in hardware code generation."}}
{"id": "2509.20300", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20300", "abs": "https://arxiv.org/abs/2509.20300", "authors": ["Jannis Kiesel", "Jonathan Heiss"], "title": "Confidentiality-Preserving Verifiable Business Processes through Zero-Knowledge Proofs", "comment": null, "summary": "Ensuring the integrity of business processes without disclosing confidential\nbusiness information is a major challenge in inter-organizational processes.\nThis paper introduces a zero-knowledge proof (ZKP)-based approach for the\nverifiable execution of business processes while preserving confidentiality. We\nintegrate ZK virtual machines (zkVMs) into business process management engines\nthrough a comprehensive system architecture and a prototypical implementation.\nOur approach supports chained verifiable computations through proof\ncompositions. On the example of product carbon footprinting, we model\nsequential footprinting activities and demonstrate how organizations can prove\nand verify the integrity of verifiable processes without exposing sensitive\ninformation. We assess different ZKP proving variants within process models for\ntheir efficiency in proving and verifying, and discuss the practical\nintegration of ZKPs throughout the Business Process Management (BPM) lifecycle.\nOur experiment-driven evaluation demonstrates the automation of process\nverification under given confidentiality constraints.", "AI": {"tldr": "This paper proposes integrating zero-knowledge proofs with business process management to securely verify process integrity across organizations, automatically and efficiently, while keeping sensitive business data private. The technique is validated with a product carbon footprinting case and shows promise for practical BPM lifecycle integration.", "motivation": "The paper aims to address the challenge of ensuring business process integrity across organizations without disclosing confidential information. In inter-organizational processes, sensitive data sharing is a barrier to transparency and trust.", "method": "It introduces a zero-knowledge proof (ZKP)-based approach, integrating ZK virtual machines (zkVMs) into business process management engines. The method includes a comprehensive system architecture and a prototype implementation that enables chained verifiable computations using proof compositions.", "result": "The approach is tested with product carbon footprinting as an example, demonstrating organizations can verify business process integrity without exposing sensitive data. Multiple ZKP proving variants are assessed for their efficiency, and practical BPM lifecycle integration is discussed. Experimental results show successful automation of process verification under confidentiality constraints.", "conclusion": "Zero-knowledge proofs can effectively ensure business process integrity and automation within confidentiality limits, making process verification secure and practical for real-world applications."}}
{"id": "2509.20308", "categories": ["cs.SE", "68M15 (Primary), 68M12, 68Q42 (Secondary)", "D.2.5; C.2.2; F.4.2"], "pdf": "https://arxiv.org/pdf/2509.20308", "abs": "https://arxiv.org/abs/2509.20308", "authors": ["Alexander Liggesmeyer", "Jos\u00e9 Antonio Zamudio Amaya", "Andreas Zeller"], "title": "Protocol Testing with I/O Grammars", "comment": "20 pages", "summary": "Generating software tests faces two fundamental problems. First, one needs to\n_generate inputs_ that are syntactically and semantically correct, yet\nsufficiently diverse to cover behavior. Second, one needs an _oracle_ to _check\noutputs_ whether a test case is correct or not. Both problems become apparent\nin _protocol testing_, where inputs are messages exchanged between parties, and\noutputs are the responses of these parties.\n  In this paper, we propose a novel approach to protocol testing that combines\ninput generation and output checking in a single framework. We introduce _I/O\ngrammars_ as the first means to _completely_ specify the syntax and semantics\nof protocols, including messages, states, and interactions. Our implementation,\nbased on the FANDANGO framework, takes a single I/O grammar, and can act as a\n_test generator_, as a _mock object_, and as an _oracle_ for a _client_, a\n_server_, or both (or actually any number of parties), a versatility not found\nin any existing tool or formalism. User-defined _constraints}_can have the\ngenerator focus on arbitrary protocol features; $k$-path guidance\nsystematically covers states, messages, responses, and value alternatives in a\nunified fashion.\n  We evaluate the effectiveness of our approach by applying it to several\nprotocols, including DNS, FTP, and SMTP. We demonstrate that I/O grammars can\nspecify advanced protocol features correctly and completely, while also\nenabling output validation of the programs under test. In its evaluation, we\nfind that systematic coverage of the I/O grammar results in much quicker\ncoverage of the input and response spaces (and thus functionality) compared to\nthe random-based state-of-the-art approaches.", "AI": {"tldr": "This paper presents I/O grammars and the FANDANGO framework, offering an effective unified solution for protocol test generation and validation, enabling quick and comprehensive coverage versus traditional methods.", "motivation": "Software test generation, especially for protocols, faces two major challenges: generating syntactically/semantically correct and diverse inputs, and constructing oracles to check the correctness of outputs. Existing tools do not fully address both in an integrated, flexible, and comprehensive manner.", "method": "The paper introduces 'I/O grammars', a novel formalism that allows the complete specification of protocol syntax and semantics across messages, states, and interactions. The FANDANGO framework uses these grammars to function as a test generator, mock object, and oracle for multiple protocol parties. The approach features user-defined constraints and k-path guidance for focused, systematic coverage.", "result": "I/O grammars were implemented for several protocols including DNS, FTP, and SMTP, demonstrating the ability to specify protocols completely and enable precise output validation. Empirical results show that this approach achieves significantly faster and more thorough coverage of protocol behaviors than random-based approaches.", "conclusion": "The proposed approach, using I/O grammars and the FANDANGO framework, provides a complete, integrated, and flexible solution for protocol testing, combining both input generation and output checking and outperforming existing state-of-the-art methods in coverage."}}
{"id": "2509.20353", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.20353", "abs": "https://arxiv.org/abs/2509.20353", "authors": ["Viktoria Stray", "Elias Goldmann Brandtz\u00e6g", "Viggo Tellefsen Wivestad", "Astri Barbala", "Nils Brede Moe"], "title": "Developer Productivity With and Without GitHub Copilot: A Longitudinal Mixed-Methods Case Study", "comment": "Accepted for publication in the Proceedings of the 59th Hawaii\n  International Conference on System Sciences (HICSS 2026)", "summary": "This study investigates the real-world impact of the generative AI (GenAI)\ntool GitHub Copilot on developer activity and perceived productivity. We\nconducted a mixed-methods case study in NAV IT, a large public sector agile\norganization. We analyzed 26,317 unique non-merge commits from 703 of NAV IT's\nGitHub repositories over a two-year period, focusing on commit-based activity\nmetrics from 25 Copilot users and 14 non-users. The analysis was complemented\nby survey responses on their roles and perceived productivity, as well as 13\ninterviews. Our analysis of activity metrics revealed that individuals who used\nCopilot were consistently more active than non-users, even prior to Copilot's\nintroduction. We did not find any statistically significant changes in\ncommit-based activity for Copilot users after they adopted the tool, although\nminor increases were observed. This suggests a discrepancy between changes in\ncommit-based metrics and the subjective experience of productivity.", "AI": {"tldr": "GitHub Copilot users feel more productive, but their commit activity does not show significant change after adopting the tool; subjective perceptions of productivity may differ from objective measures.", "motivation": "To understand the actual impact of generative AI tools like GitHub Copilot on developer productivity and activity in a real organizational setting.", "method": "Mixed-methods case study: quantitative analysis of 26,317 non-merge commits from 703 repositories comparing Copilot users vs. non-users, complemented by surveys and 13 interviews.", "result": "Copilot users were consistently more active than non-users even before adopting Copilot. After adoption, no statistically significant changes in commit-based activity were identified, although small increases were seen.", "conclusion": "There is a discrepancy between objective commit-based metrics and developers' subjective experience of increased productivity with Copilot. The tool may not show measurable activity changes, but users perceive themselves as more productive."}}

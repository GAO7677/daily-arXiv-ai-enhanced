<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 5]
- [cs.PL](#cs.PL) [Total: 4]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [TrioXpert: An automated incident management framework for microservice system](https://arxiv.org/abs/2506.10043)
*Yongqian Sun,Yu Luo,Xidao Wen,Yuan Yuan,Xiaohui Nie,Shenglin Zhang,Tong Liu,Xi Luo*

Main category: cs.SE

TL;DR: TrioXpert框架利用多模态数据和大语言模型，不仅提升了微服务系统中异常检测、故障分类、根因定位等多项任务的表现，还增强了方法的可解释性。


<details>
  <summary>Details</summary>
Motivation: 现有自动化事件管理方法主要依赖单一模态数据（如指标、日志、追踪信息），且难以同时支持异常检测、故障分类、根因定位等多任务。此外，现有方法缺乏明确的推理证据，解释性不足。

Method: 提出了TrioXpert框架，能够充分利用多模态数据（数值和文本），分别为不同模态设计独立数据处理流程，并利用大语言模型（LLMs）协作推理，支持多任务处理的同时提升可解释性。

Result: 在两个主流微服务系统数据集上，TrioXpert在异常检测、故障分类、根因定位三项任务上分别提升了4.7%-57.7%、2.1%-40.6%、1.6%-163.1%的性能。

Conclusion: TrioXpert通过多模态数据融合与大语言模型协同推理，实现了微服务系统事件管理的多任务高性能和高可解释性。

Abstract: Automated incident management plays a pivotal role in large-scale
microservice systems. However, many existing methods rely solely on
single-modal data (e.g., metrics, logs, and traces) and struggle to
simultaneously address multiple downstream tasks, including anomaly detection
(AD), failure triage (FT), and root cause localization (RCL). Moreover, the
lack of clear reasoning evidence in current techniques often leads to
insufficient interpretability. To address these limitations, we propose
TrioXpert, an end-to-end incident management framework capable of fully
leveraging multimodal data. TrioXpert designs three independent data processing
pipelines based on the inherent characteristics of different modalities,
comprehensively characterizing the operational status of microservice systems
from both numerical and textual dimensions. It employs a collaborative
reasoning mechanism using large language models (LLMs) to simultaneously handle
multiple tasks while providing clear reasoning evidence to ensure strong
interpretability. We conducted extensive evaluations on two popular
microservice system datasets, and the experimental results demonstrate that
TrioXpert achieves outstanding performance in AD (improving by 4.7% to 57.7%),
FT (improving by 2.1% to 40.6%), and RCL (improving by 1.6% to 163.1%) tasks.

</details>


### [2] [Reward Models Enable Scalable Code Verification by Trading Accuracy for Throughput](https://arxiv.org/abs/2506.10056)
*Gabriel Orlanski,Nicholas Roberts,Aws Albarghouthi,Frederic Sala*

Main category: cs.SE

TL;DR: 本论文提出在大型语言模型代码生成任务中，结合速度快但准确率低的ORM和完整验证器的生成-剪枝-再排序流程，可以大幅提升验证速度，准确率损失很小，有助于构建可扩展且精准的程序排序系统。


<details>
  <summary>Details</summary>
Motivation: 当前主流观点认为综合性验证器（如完整测试集）优先于ORM，但很少关注相关的权衡。本文旨在挑战这种假设，探索速度和准确率的取舍。

Method: 系统地研究了速度和准确性之间的权衡，通过引入生成-剪枝-再排序的流程，先用速度较快但准确率较低的验证器移除错误解，然后再排序。

Result: 通过生成-剪枝-再排序方法，能够实现11.65倍的速度提升，同时准确率仅下降8.33%。分析显示该方法能有效剔除高排名但错误的解，提高排序系统的规模化和准确性。

Conclusion: ORM（Outcome Reward Model）在代码任务的验证阶段，即使有完整测试集，仍然通过速度与准确率的权衡实现了规模化验证，显著提升了系统效率而损失较小的准确率。

Abstract: The standard paradigm for solving coding tasks via large language models
(LLMs) is to generate-then-rank programs, where the latter step uses a verifier
in the ranking process. The growing consensus is that a comprehensive verifier
(e.g., a full test suite) should be prioritized over an outcome reward model
(ORM) whenever possible, with little consideration given to the trade-offs
involved. We aim to challenge this assumption by systematically exploring the
tradeoff between speed and accuracy. We find that ORMs play a crucial role in
scaling verification through trading accuracy for speed, even when a
comprehensive verifier is available. Their value becomes especially apparent
when used in a generate-prune-then-rank approach, where a faster but less
accurate verifier removes incorrect solutions prior to ranking -- leading to a
system that is 11.65x faster while only being 8.33% less accurate than the full
test suite. We analyze the generate-prune-then-rank approach and show that it
works by filtering out incorrect but highly ranked solutions. These findings
enable the design of scalable and accurate program ranking systems.

</details>


### [3] [Online Discovery of Simulation Models for Evolving Business Processes (Extended Version)](https://arxiv.org/abs/2506.10049)
*Francesco Vinci,Gyunam Park,Wil van der Aalst,Massimiliano de Leoni*

Main category: cs.SE

TL;DR: 针对现有流程仿真模型发现方法难以实时适应业务变动的问题，本文提出了结合增量流程发现和在线机器学习的技术，实现了对流程动态的快速适应，并验证了其在稳定性与概念漂移处理方面的优势。


<details>
  <summary>Details</summary>
Motivation: 现有的业务流程仿真模型自动发现方法对实时环境的适应能力不足。随着业务环境的快速变化，企业需要仿真系统能够及时反映流程变化以提高效率、降低成本、提升客户满意度。

Method: 提出了一种结合增量流程发现与在线机器学习的方法，实时从数据流中获取并更新仿真模型。该技术在优先考虑最新数据影响的同时，保留了历史数据的信息，实现对流程动态变化的持续适应。

Result: 通过对四个不同事件日志的实验，验证了该方法在仿真过程中对最近数据赋予更高权重同时保持历史信息的优势。该方法能够生成更稳定的仿真结果，并且在处理概念漂移过程中表现出更强的鲁棒性。

Conclusion: 本文提出的流式仿真模型自动发现方法能够更好地适应业务环境的实时变化，兼顾新旧数据，提升了仿真的稳定性和鲁棒性。

Abstract: Business Process Simulation (BPS) refers to techniques designed to replicate
the dynamic behavior of a business process. Many approaches have been proposed
to automatically discover simulation models from historical event logs,
reducing the cost and time to manually design them. However, in dynamic
business environments, organizations continuously refine their processes to
enhance efficiency, reduce costs, and improve customer satisfaction. Existing
techniques to process simulation discovery lack adaptability to real-time
operational changes. In this paper, we propose a streaming process simulation
discovery technique that integrates Incremental Process Discovery with Online
Machine Learning methods. This technique prioritizes recent data while
preserving historical information, ensuring adaptation to evolving process
dynamics. Experiments conducted on four different event logs demonstrate the
importance in simulation of giving more weight to recent data while retaining
historical knowledge. Our technique not only produces more stable simulations
but also exhibits robustness in handling concept drift, as highlighted in one
of the use cases.

</details>


### [4] [Solving Package Management via Hypergraph Dependency Resolution](https://arxiv.org/abs/2506.10803)
*Ryan Gibb,Patrick Ferris,David Allsopp,Michael Winston Dales,Mark Elvers,Thomas Gazagnaire,Sadiq Jaffer,Thomas Leonard,Jon Ludlam,Anil Madhavapeddy*

Main category: cs.SE

TL;DR: HyperRes通过超图模型实现不同包管理器跨生态系统的依赖解析，无需更换现有工具，促进包管理器互操作和依赖精确管理。


<details>
  <summary>Details</summary>
Motivation: 目前各种编程语言和操作系统都拥有各自的包管理器，但彼此之间缺乏互操作性，多语种项目难以跨生态系统精确表达依赖关系，外部系统和硬件依赖也无法明确、版本化地指定。

Method: 作者提出了HyperRes，一个基于超图的形式化系统，用于描述版本化依赖解析。HyperRes能够表达多种现有生态系统，并解决跨生态的依赖约束。同时，作者将几十种现有包管理器的依赖关系翻译到HyperRes中进行统一建模。

Result: 实验表明，HyperRes可以实现当前各自独立的包管理器生态系统间的依赖解析，不需要用户更换包管理器，并能针对特定部署环境精确定制依赖求解。

Conclusion: HyperRes为版本化依赖解析提供了一个统一、强大且可扩展的形式化系统，实现了包管理器间的互操作性和精细化依赖管理。

Abstract: Package managers are everywhere, with seemingly every language and operating
system implementing their own solution. The lack of interoperability between
these systems means that multi-lingual projects are unable to express precise
dependencies across language ecosystems, and external system and hardware
dependencies are typically implicit and unversioned. We define HyperRes, a
formal system for describing versioned dependency resolution using a hypergraph
that is expressive enough to model many ecosystems and solve dependency
constraints across them. We define translations from dozens of existing package
managers to HyperRes and comprehensively demonstrate that dependency resolution
can work across ecosystems that are currently distinct. This does not require
users to shift their choice of package managers; instead, HyperRes allows for
the translation of packaging metadata between ecosystems, and for solving to be
precisely specialised to a particular deployment environment.

</details>


### [5] [The Effects of GitHub Copilot on Computing Students' Programming Effectiveness, Efficiency, and Processes in Brownfield Programming Tasks](https://arxiv.org/abs/2506.10051)
*Md Istiak Hossain Shihab,Christopher Hundhausen,Ahsun Tariq,Summit Haque,Yunhan Qiao,Brian Mulanda*

Main category: cs.SE

TL;DR: 使用GitHub Copilot等生成式AI助手能帮助学生提高旧项目开发效率、减少手动编程和资料查找时间，但学生对AI建议的理解不足，教育者需创新教学应对。


<details>
  <summary>Details</summary>
Motivation: 在现今软件产业中，毕业生将大概率加入已有代码基础、由他人开发的“brownfield”项目团队，而生成式人工智能（GenAI）编码助手如GitHub Copilot正在迅速改变软件开发实践。但目前尚不清楚GenAI对学生程序员完成brownfield开发任务的影响。

Method: 本研究设计了对照实验，让10名本科计算机专业学生在遗留Web应用中，分别在有Copilot和无Copilot两种情况下完成高度相似的brownfield开发任务；通过表现分析、行为分析和访谈的混合方法研究其影响。

Result: 使用Copilot时，学生完成任务速度提升35%，解决方案进展提升50%，手动编程时间降低11%，网络搜索时间减少12%，以上结果均有统计学意义（p<0.05）；但学生对Copilot建议的工作方式和原理存在不理解的担忧。

Conclusion: GenAI助手（如Copilot）能显著提升学生在brownfield开发中的效率和进展，同时改变其编程行为。教育者有必要探索融合GenAI助手优势并提升学生对建议理解及反思的新教学方法。

Abstract: When graduates of computing degree programs enter the software industry, they
will most likely join teams working on legacy code bases developed by people
other than themselves. In these so-called brownfield software development
settings, generative artificial intelligence (GenAI) coding assistants like
GitHub Copilot are rapidly transforming software development practices, yet the
impact of GenAI on student programmers performing brownfield development tasks
remains underexplored. This paper investigates how GitHub Copilot influences
undergraduate students' programming performance, behaviors, and understanding
when completing brownfield programming tasks in which they add new code to an
unfamiliar code base. We conducted a controlled experiment in which 10
undergraduate computer science students completed highly similar brownfield
development tasks with and without Copilot in a legacy web application. Using a
mixed-methods approach combining performance analysis, behavioral analysis, and
exit interviews, we found that students completed tasks 35% faster (p < 0.05)
and made 50% more solution progress p (< 0.05) when using Copilot. Moreover,
our analysis revealed that, when using Copilot, students spent 11% less time
manually writing code (p < 0.05), and 12% less time conducting web searches (p
< 0.05), providing evidence of a fundamental shift in how they engaged in
programming. In exit interviews, students reported concerns about not
understanding how or why Copilot suggestions work. This research suggests the
need for computing educators to develop new pedagogical approaches that
leverage GenAI assistants' benefits while fostering reflection on how and why
GenAI suggestions address brownfield programming tasks. Complete study results
and analysis are presented at https://ghcopilot-icer.github.io/.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [6] [From Tool Calling to Symbolic Thinking: LLMs in a Persistent Lisp Metaprogramming Loop](https://arxiv.org/abs/2506.10021)
*Jordi de la Torre*

Main category: cs.PL

TL;DR: 本文提出一种将大语言模型与Lisp REPL环境深度集成的新架构，使模型可动态生成和进化工具，并提出了未来交互式AI系统的设计原则。


<details>
  <summary>Details</summary>
Motivation: 当前大语言模型（LLMs）在与外部环境交互及工具生成方面存在局限，亟需开发能够支持动态工具构建、状态记忆及交互的架构。

Method: 提出一种新颖架构，将大语言模型与持久的交互式Lisp环境集成。通过在生成过程中嵌入Lisp表达式，并利用中间件进行拦截，实现REPL的程序化交互。系统能够使LLM定义、调用并进化自己的工具。

Result: 系统实现了LLM与Lisp环境的无缝集成，支持有状态的外部记忆、反射式编程及动态工具创造，并提出了设计框架与架构原则，以指导未来的交互式AI系统开发。

Conclusion: 本研究为符号编程与神经语言生成的融合提供了实现范式，为构建更具交互性和扩展性的AI系统奠定了基础。

Abstract: We propose a novel architecture for integrating large language models (LLMs)
with a persistent, interactive Lisp environment. This setup enables LLMs to
define, invoke, and evolve their own tools through programmatic interaction
with a live REPL. By embedding Lisp expressions within generation and
intercepting them via a middleware layer, the system allows for stateful
external memory, reflective programming, and dynamic tool creation. We present
a design framework and architectural principles to guide future implementations
of interactive AI systems that integrate symbolic programming with neural
language generation.

</details>


### [7] [A Language-Agnostic Logical Relation for Message-Passing Protocols](https://arxiv.org/abs/2506.10026)
*Tesla Zhang,Sonya Simkin,Rui Li,Yue Yao,Stephanie Balzer*

Main category: cs.PL

TL;DR: 本文提出了一种与语言无关的逻辑关系和验证框架，能够在没有统一实现语言或类型系统的情况下，认证分布式异构消息传递系统的协议符合性，并在Coq中实现。


<details>
  <summary>Details</summary>
Motivation: 随着分布式和异构系统（如云计算和物联网）的普及，应用程序越来越多地采用并发、消息传递和与外部对象（如物理设备或外部代码）的交互。如何验证这些系统是否遵循预期的交互协议成为一大挑战，因为传统基于统一编程语言或类型系统的方法已不适用。

Method: 提出并实现了一个用于分布式异构消息传递系统协议符合性认证的框架。该框架基于标签转换语义，发展出第一个与语言无关的逻辑关系，并在Coq定理证明器中实现。提供了对具体实例和类型系统下的应用程序的两种情景验证方案。

Result: 框架能够验证异构系统中的协议符合性，无需依赖统一的实现语言或类型系统，并适用于包括外部对象在内的各类实现。通过在Coq中机制化逻辑关系，成功应用于实际案例，包括一次性和逐实例验证。

Conclusion: 提出的与语言无关的逻辑关系以及基于标签转移的技术，为异构消息传递系统的协议验证提供了理论基础和实用工具，能够推进分布式及物联网安全和可靠性的发展。

Abstract: Today's computing landscape has been gradually shifting to applications
targeting distributed and *heterogeneous* systems, such as cloud computing and
Internet of Things (IoT) applications. These applications are predominantly
*concurrent*, employ *message-passing*, and interface with *foreign objects*,
ranging from externally implemented code to actual physical devices such as
sensors. Verifying that the resulting systems adhere to the intended protocol
of interaction is challenging -- the usual assumption of a common
implementation language, let alone a type system, no longer applies, ruling out
any verification method based on them. This paper develops a framework for
certifying *protocol compliance* of heterogeneous message-passing systems. It
contributes the first mechanization of a *language-agnostic logical relation*,
asserting that its inhabitants comply with the protocol specified. This
definition relies entirely on a labelled transition-based semantics,
accommodating arbitrary inhabitants, typed and untyped alike, including foreign
objects. As a case study, the paper considers two scenarios: (1) *per-instance
verification* of a specific application or hardware device, and (2)
*once-and-for-all verification* of well-typed applications for a given type
system. The logical relation and both scenarios are mechanized in the Coq
theorem prover.

</details>


### [8] [Hazel Deriver: A Live Editor for Constructing Rule-Based Derivations](https://arxiv.org/abs/2506.10781)
*Zhiyao Zhong,Cyrus Omar*

Main category: cs.PL

TL;DR: 该文提出了一种在线编辑工具Hazel Deriver，通过分层支架支持和实时反馈帮助学生更容易地构建推导树。初步研究表明，它能降低难度并提升理解和参与，未来需关注引导与自主性的平衡。


<details>
  <summary>Details</summary>
Motivation: 学生在学习编程语言和形式逻辑课程时，通常难以构建基于规则的推导树，其原因包括推理规则应用复杂、缺乏即时反馈以及手写证明所需的人工劳动多。

Method: 提出了Hazel Deriver，这是一个基于Hazel实时编程环境的网页编辑器。该工具通过多层级的支架支持，提供结构化、交互性强、鼓励迭代探索和实时反馈的推导树构建体验。

Result: 初步用户研究显示，Hazel Deriver能减少推导任务的主观难度，同时提升学生的概念理解和参与度。

Conclusion: Hazel Deriver有效帮助学生提高了推导树的构建效率和理解程度，但在系统引导与学习者自主性之间的平衡问题仍需进一步探讨。

Abstract: Students in programming languages and formal logic courses often struggle
with constructing rule-based derivation trees due to the complexity of applying
inference rules, the lack of immediate feedback, and the manual effort required
for handwritten proofs. We present Hazel Deriver, a live, web-based editor
designed to scaffold derivation construction through multiple layers of
support. Built on the Hazel live programming environment, it provides a
structured, interactive experience that encourages iterative exploration and
real-time feedback. A preliminary user study with former students suggests that
Hazel Deriver reduces the perceived difficulty of derivation tasks while
improving conceptual understanding and engagement. We discuss the design of its
layered scaffolding features and raise questions about balancing system
guidance with learner autonomy.

</details>


### [9] [Choreographic Quick Changes: First-Class Location (Set) Polymorphism](https://arxiv.org/abs/2506.10913)
*Ashley Samuelson,Andrew K. Hirsch,Ethan Cecchetti*

Main category: cs.PL

TL;DR: 本文提出了支持动态节点选择与丰富类型特性的编舞语言λ_{QC}，在表达能力与系统安全性方面优于以往方案，并经过形式化验证。


<details>
  <summary>Details</summary>
Motivation: 现有的编舞编程语言虽然开辟了并发系统编程的新范式，但缺乏现代系统关键特性，例如在运行时动态地选择并通知负责特定计算的节点。

Method: 提出了一种新型的类型化编舞语言λ_{QC}，支持一等进程名、类型及位置多态性，并能表达代数与递归数据类型及多节点值；同时用Rocq工具对理论结果和无死锁保证进行了形式化和机械化验证。

Result: λ_{QC}在表达能力上超越了既有方法，支持更复杂的数据结构与动态分配；同时理论上确保了分布式系统的安全性与无死锁。

Conclusion: 该工作通过λ_{QC}完善了编舞编程在动态节点分配和类型多样性方面的不足，推动了分布式并发系统安全、高效开发。

Abstract: Choreographic programming is a promising new paradigm for programming
concurrent systems where a developer writes a single centralized program that
compiles to individual programs for each node. Existing choreographic
languages, however, lack critical features integral to modern systems, like the
ability of one node to dynamically compute who should perform a computation and
send that decision to others. This work addresses this gap with $\lambda_{QC}$,
the first typed choreographic language with \emph{first class process names}
and polymorphism over both types and (sets of) locations. $\lambda_{QC}$ also
improves expressive power over previous work by supporting algebraic and
recursive data types as well as multiply-located values. We formalize and
mechanically verify our results in Rocq, including the standard choreographic
guarantee of deadlock freedom.

</details>

<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 12]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Automated File-Level Logging Generation for Machine Learning Applications using LLMs: A Case Study using GPT-4o Mini](https://arxiv.org/abs/2508.04820)
*Mayra Sofia Ruiz Rodriguez,SayedHassan Khatoonabadi,Emad Shihab*

Main category: cs.SE

TL;DR: LLMs like GPT-4o mini can generate file-level logs in ML code, matching human log placement most of the time but often overlogging and missing project-specific conventions. Practical adoption needs addressing these issues.


<details>
  <summary>Details</summary>
Motivation: Logging is crucial for monitoring and debugging software systems, especially in ML projects, but most work evaluates code-level logs, leaving file-level log generation and its potential benefits underexplored.

Method: The authors collected 171 ML repositories with 4,073 Python files containing logs. They removed existing logs, used GPT-4o mini to generate new file-level logs, and evaluated the generated logs against human-written ones in terms of position, log level, variables, and text quality. Manual analysis identified patterns and challenges.

Result: GPT-4o mini placed logs in the same location as humans in 63.91% of cases but had an overlogging rate of 82.66%. Manual analysis revealed frequent overlogging at function boundaries, difficulty logging inside large code blocks, and poor alignment with project-specific logging conventions.

Conclusion: GPT-4o mini can generate file-level logs for ML projects reasonably well, but key limitations—overlogging, placement issues, and convention misalignment—must be resolved to make LLM-generated logs practical for real-world use.

Abstract: Logging is essential in software development, helping developers monitor
system behavior and aiding in debugging applications. Given the ability of
large language models (LLMs) to generate natural language and code, researchers
are exploring their potential to generate log statements. However, prior work
focuses on evaluating logs introduced in code functions, leaving file-level log
generation underexplored -- especially in machine learning (ML) applications,
where comprehensive logging can enhance reliability. In this study, we evaluate
the capacity of GPT-4o mini as a case study to generate log statements for ML
projects at file level. We gathered a set of 171 ML repositories containing
4,073 Python files with at least one log statement. We identified and removed
the original logs from the files, prompted the LLM to generate logs for them,
and evaluated both the position of the logs and log level, variables, and text
quality of the generated logs compared to human-written logs. In addition, we
manually analyzed a representative sample of generated logs to identify common
patterns and challenges. We find that the LLM introduces logs in the same place
as humans in 63.91% of cases, but at the cost of a high overlogging rate of
82.66%. Furthermore, our manual analysis reveals challenges for file-level
logging, which shows overlogging at the beginning or end of a function,
difficulty logging within large code blocks, and misalignment with
project-specific logging conventions. While the LLM shows promise for
generating logs for complete files, these limitations remain to be addressed
for practical implementation.

</details>


### [2] [Automated Bug Frame Retrieval from Gameplay Videos Using Vision-Language Models](https://arxiv.org/abs/2508.04895)
*Wentao Lu,Alexander Senchenko,Abram Hindle,Cor-Paul Bezemer*

Main category: cs.SE

TL;DR: The paper proposes an automated system that reduces gameplay bug-report videos to a single, most relevant frame, using FFmpeg and GPT-4o. This method greatly improves the efficiency of bug triage for games, achieving high accuracy and F1 scores, especially in certain bug categories, thereby saving developers time and effort.


<details>
  <summary>Details</summary>
Motivation: Game studios face a significant challenge in efficiently triaging thousands of bug reports that include gameplay videos. Manual review of these videos is slow, labour-intensive, and not scalable.

Method: The paper presents an automated pipeline that extracts keyframes from videos using FFmpeg and then leverages a vision-language model (GPT-4o) to select the frame that best matches the bug description. This drastically reduces the video to a single, most relevant frame.

Result: Keyframe extraction retains bug moments in 98.79% of cases, and the vision-language matching achieves an F1 score of 0.79 and Accuracy of 0.89 in top-1 frame retrieval. The system performs best on Lighting & Shadow, Physics & Collision, and UI & HUD bugs, with lower results for Animation & VFX.

Conclusion: Automating the review of gameplay videos through this pipeline significantly reduces manual effort and speeds up QA processes for bug verification and triage, benefiting game developers and QA teams.

Abstract: Modern game studios deliver new builds and patches at a rapid pace,
generating thousands of bug reports, many of which embed gameplay videos. To
verify and triage these bug reports, developers must watch the submitted
videos. This manual review is labour-intensive, slow, and hard to scale. In
this paper, we introduce an automated pipeline that reduces each video to a
single frame that best matches the reported bug description, giving developers
instant visual evidence that pinpoints the bug.
  Our pipeline begins with FFmpeg for keyframe extraction, reducing each video
to a median of just 1.90% of its original frames while still capturing bug
moments in 98.79 of cases. These keyframes are then evaluated by a
vision--language model (GPT-4o), which ranks them based on how well they match
the textual bug description and selects the most representative frame. We
evaluated this approach using real-world developer-submitted gameplay videos
and JIRA bug reports from a popular First-Person Shooter (FPS) game. The
pipeline achieves an overall F1 score of 0.79 and Accuracy of 0.89 for the
top-1 retrieved frame. Performance is highest for the Lighting & Shadow (F1 =
0.94), Physics & Collision (0.86), and UI & HUD (0.83) bug categories, and
lowest for Animation & VFX (0.51).
  By replacing video viewing with an immediately informative image, our
approach dramatically reduces manual effort and speeds up triage and regression
checks, offering practical benefits to quality assurance (QA) teams and
developers across the game industry.

</details>


### [3] [Charting Uncertain Waters: A Socio-Technical Framework for Navigating GenAI's Impact on Open Source Communities](https://arxiv.org/abs/2508.04921)
*Zixuan Feng,Reed Milewicz,Emerson Murphy-Hill,Tyler Menezes,Alexander Serebrenik,Igor Steinmacher,Anita Sarma*

Main category: cs.SE

TL;DR: Generative AI disrupts open source software (OSS) communities, introducing complexity and uncertainty. This paper uses a socio-technical scenario analysis to identify risks and opportunities in OSS practices, documentation, engagement, and governance, helping leaders proactively navigate and strengthen their communities.


<details>
  <summary>Details</summary>
Motivation: The rapid transformation of software creation and governance caused by Generative AI introduces uncertainty and threatens the collaborative nature of open source communities, necessitating clear frameworks for understanding and responding to these changes.

Method: Scenario-driven, conceptual exploration using a socio-technical analytical framework inspired by McLuhan's Tetrad.

Result: The study highlights risks and opportunities for OSS communities across four key domains (practices, documentation, engagement, governance), providing insights for leaders and researchers to guide ecosystem evolution beyond mere reactive measures.

Conclusion: By applying a socio-technical framework, OSS communities can better identify and address both risks and opportunities posed by Generative AI, thus enabling proactive resilience and adaptation.

Abstract: Open Source Software communities face a wave of uncertainty as Generative AI
rapidly transforms how software is created, maintained, and governed. Without
clear frameworks, communities risk being overwhelmed by the complexity and
ambiguity introduced by GenAI, threatening the collaborative ethos that
underpins OSS. We conduct a scenario-driven, conceptual exploration using a
socio-technical framework inspired by McLuhan's Tetrad to surface both risks
and opportunities for community resilience amid GenAI-driven disruption of OSS
development across four domains: software practices, documentation, community
engagement, and governance. By adopting this lens, OSS leaders and researchers
can proactively shape the future of their ecosystems, rather than simply
reacting to technological upheaval.

</details>


### [4] [Taxonomy of Faults in Attention-Based Neural Networks](https://arxiv.org/abs/2508.04925)
*Sigma Jahan,Saurabh Singh Rajput,Tushar Sharma,Mohammad Masudur Rahman*

Main category: cs.SE

TL;DR: The paper analyzes over 500 faults in attention-based neural networks, identifies unique categories of errors not covered by previous work, and proposes practical heuristics for diagnosing such faults, addressing a critical gap in deep learning diagnostics.


<details>
  <summary>Details</summary>
Motivation: Attention mechanisms are central to many advanced AI systems, but high-profile failures (e.g., nonsensical outputs from ChatGPT, faulty image generation in Gemini) suggest that existing fault taxonomies do not adequately address the unique problems introduced by attention architectures. Practitioners lack precise diagnostic tools to handle these specialized faults.

Method: The authors conducted a systematic empirical study by collecting and analyzing 555 real-world faults related to attention-based neural networks (ABNNs) from 96 projects and ten frameworks, using sources such as GitHub, Hugging Face, and Stack Overflow. They classified these faults, developed a new taxonomy with seven attention-specific fault categories, and investigated symptoms and root causes to identify diagnostic heuristics.

Result: The study reveals that more than half of the ABNN faults are caused by mechanisms unique to attention-based architectures. The new taxonomy identifies seven attention-specific fault categories previously uncaptured. Four evidence-based diagnostic heuristics were identified, collectively explaining 33.0% of attention-specific faults. This provides the first systematic diagnostic guidance for practitioners working with ABNNs.

Conclusion: Existing fault taxonomies are insufficient for attention-based neural networks. This study delivers a new taxonomy and empirically validated diagnostic heuristics, filling a crucial gap in understanding and troubleshooting ABNN faults.

Abstract: Attention mechanisms are at the core of modern neural architectures, powering
systems ranging from ChatGPT to autonomous vehicles and driving a major
economic impact. However, high-profile failures, such as ChatGPT's nonsensical
outputs or Google's suspension of Gemini's image generation due to attention
weight errors, highlight a critical gap: existing deep learning fault
taxonomies might not adequately capture the unique failures introduced by
attention mechanisms. This gap leaves practitioners without actionable
diagnostic guidance. To address this gap, we present the first comprehensive
empirical study of faults in attention-based neural networks (ABNNs). Our work
is based on a systematic analysis of 555 real-world faults collected from 96
projects across ten frameworks, including GitHub, Hugging Face, and Stack
Overflow. Through our analysis, we develop a novel taxonomy comprising seven
attention-specific fault categories, not captured by existing work. Our results
show that over half of the ABNN faults arise from mechanisms unique to
attention architectures. We further analyze the root causes and manifestations
of these faults through various symptoms. Finally, by analyzing symptom-root
cause associations, we identify four evidence-based diagnostic heuristics that
explain 33.0% of attention-specific faults, offering the first systematic
diagnostic guidance for attention-based models.

</details>


### [5] [Generative AI for Object-Oriented Programming: Writing the Right Code and Reasoning the Right Logic](https://arxiv.org/abs/2508.05005)
*Gang Xu,Airong Wang,Yushan Pan*

Main category: cs.SE

TL;DR: LLMs are drastically changing many fields, but their use in OOP remains largely unexplored. This paper investigates where LLMs could most benefit programmers in OOP workflows and proposes strategies to improve code reasoning and writing with these models.


<details>
  <summary>Details</summary>
Motivation: The rapid development of LLMs offers new possibilities in various domains, but their impact on object-oriented programming practices and education has not been fully understood or leveraged.

Method: The paper presents a vision paper focusing on OOP coding workflows. It identifies key stakeholders (programmers, mariners, experienced programmers), and pinpoints workflow stages where LLMs could provide substantial benefits. The authors propose augmentation strategies for reasoning and code writing tasks.

Result: Key opportunities for improvement in OOP workflows through LLM integration are highlighted. Concrete suggestions are made for how LLMs can be used to enhance both logical reasoning and code writing in OOP tasks.

Conclusion: The intersection between LLMs and OOP offers untapped potential to improve programming workflows and learning, by leveraging AI to boost reasoning and code writing capabilities. The paper underscores the importance of further research and evaluation in this area.

Abstract: We find ourselves in the midst of an explosion in artificial intelligence
research, particularly with large language models (LLMs). These models have
diverse applications spanning finance, commonsense knowledge graphs, medicine,
and visual analysis. In the world of Object-Oriented Programming(OOP), a robust
body of knowledge and methods has been developed for managing complex tasks
through object-oriented thinking. However, the intersection of LLMs with OOP
remains an underexplored territory. Empirically, we currently possess limited
understanding of how LLMs can enhance the effectiveness of OOP learning and
code writing, as well as how we can evaluate such AI-powered tools. Our work
aims to address this gap by presenting a vision from the perspectives of key
stakeholders involved in an OOP task: programmers, mariners, and experienced
programmers. We identify critical junctures within typical coding workflows
where the integration of LLMs can offer significant benefits. Furthermore, we
propose ways to augment existing logical reasoning and code writing, ultimately
enhancing the programming experience.

</details>


### [6] [An ML-based Approach to Predicting Software Change Dependencies: Insights from an Empirical Study on OpenStack](https://arxiv.org/abs/2508.05034)
*Arabat,Ali,Sayagh,Mohammed,Hassine,Jameleddine*

Main category: cs.SE

TL;DR: Dependency management in large software like OpenStack is challenging and often delayed. The paper presents ML-based methods to predict and discover dependencies earlier, showing high effectiveness in most metrics, but room to improve pairwise precision.


<details>
  <summary>Details</summary>
Motivation: As software complexity grows, managing dependencies across changes is crucial for effective CI/CD operations. Existing challenges include identifying dependencies that span multiple components and teams, often detected late in the process, putting development at risk of build failures or incomplete deployments.

Method: The authors conducted an empirical study on dependency management in OpenStack, followed by the development of a semi-automated approach using two machine learning models: one to predict the likelihood of dependencies among changes, and another to identify exact dependent change pairs.

Result: The study found that over half (51.08%) of dependencies in OpenStack are detected late during code review, with significant developer effort required. The proposed ML models perform well, with AUC scores of 79.33% and 91.89% and low Brier scores (0.11 and 0.014), though precision for identifying exact pairs could be improved.

Conclusion: Proactively identifying dependencies is essential for large-scale software development. The proposed ML-based approach helps developers detect dependencies earlier, potentially reducing development delays, though further enhancements in precision are needed.

Abstract: As software systems grow in complexity, accurately identifying and managing
dependencies among changes becomes increasingly critical. For instance, a
change that leverages a function must depend on the change that introduces it.
Establishing such dependencies allows CI/CD pipelines to build and orchestrate
changes effectively, preventing build failures and incomplete feature
deployments. In modern software systems, dependencies often span multiple
components across teams, creating challenges for development and deployment.
They serve various purposes, from enabling new features to managing
configurations, and can even involve traditionally independent changes like
documentation updates. To address these challenges, we conducted a preliminary
study on dependency management in OpenStack, a large-scale software system. Our
study revealed that a substantial portion of software changes in OpenStack over
the past 10 years are interdependent. Surprisingly, 51.08% of these
dependencies are identified during the code review phase-after a median delay
of 5.06 hours-rather than at the time of change creation. Developers often
spend a median of 57.12 hours identifying dependencies, searching among a
median of 463 other changes. To help developers proactively identify
dependencies, we propose a semi-automated approach that leverages two ML
models. The first model predicts the likelihood of dependencies among changes,
while the second identifies the exact pairs of dependent changes. Our proposed
models demonstrate strong performance, achieving average AUC scores of 79.33%
and 91.89%, and Brier scores of 0.11 and 0.014, respectively. Indeed, the
second model has a good top-k recall across all types of pairs, while the top-k
precision has room for improvement.

</details>


### [7] [LadyBug: A GitHub Bot for UI-Enhanced Bug Localization in Mobile Apps](https://arxiv.org/abs/2508.05085)
*Junayed Mahmud,James Chen,Terry Achille,Camilo Alvarez-Velez,Darren Dean Bansil,Patrick Ijieh,Samar Karanch,Nadeeshan De Silva,Oscar Chaparro,Andrian Marcus,Kevin Moran*

Main category: cs.SE

TL;DR: LadyBug is an open-source GitHub bot for Android apps that uses both bug report text and UI reproduction traces to accurately find buggy files. Tested on 80 bugs from 39 apps, it beats text-only methods in bug localization accuracy.


<details>
  <summary>Details</summary>
Motivation: Bug localization in large Android projects is challenging. Existing tools rely mainly on text retrieval, which often misses context. Including UI interactions in the process could provide more accurate results, motivating the development of LadyBug.

Method: LadyBug combines textual information from bug reports with UI traces recorded during bug reproduction. It ranks source files likely containing bugs. Evaluation is done using the RedWing benchmark with 80 bug reports from 39 different apps.

Result: Empirical results show LadyBug outperforms text-only baselines and that UI data significantly increases bug localization accuracy. LadyBug is open-source and available on GitHub.

Conclusion: LadyBug significantly improves bug localization accuracy in Android apps compared to traditional text-retrieval approaches, primarily due to its incorporation of UI interaction data.

Abstract: This paper introduces LadyBug, a GitHub bot that automatically localizes bugs
for Android apps by combining UI interaction information with text retrieval.
LadyBug connects to an Android app's GitHub repository, and is triggered when a
bug is reported in the corresponding issue tracker. Developers can then record
a reproduction trace for the bug on a device or emulator and upload the trace
to LadyBug via the GitHub issue tracker. This enables LadyBug to utilize both
the text from the original bug description, and UI information from the
reproduction trace to accurately retrieve a ranked list of files from the
project that most likely contain the reported bug.
  We empirically evaluated LadyBug using an automated testing pipeline and
benchmark called RedWing that contains 80 fully-localized and reproducible bug
reports from 39 Android apps. Our results illustrate that LadyBug outperforms
text-retrieval-based baselines and that the utilization of UI information leads
to a substantial increase in localization accuracy. LadyBug is an open-source
tool, available at https://github.com/LadyBugML/ladybug.
  A video showing the capabilities of Ladybug can be viewed here:
https://youtu.be/hI3tzbRK0Cw

</details>


### [8] [Posterior-GRPO: Rewarding Reasoning Processes in Code Generation](https://arxiv.org/abs/2508.05170)
*Lishui Fan,Yu Zhang,Mouxiang Chen,Zhongxin Liu*

Main category: cs.SE

TL;DR: The paper introduces novel methods to better align reasoning quality with final outcomes in RL-based code generation for LLMs. It tackles reward hacking, provides new benchmarks and training techniques, and outperforms previous state-of-the-art models.


<details>
  <summary>Details</summary>
Motivation: Current RL methods in code-generation focus solely on test-case outcomes, ignoring intermediate reasoning quality and suffering from reward hacking when directly supervising reasoning. There's a need for robust ways to evaluate and optimize reasoning processes during RL.

Method: The framework includes three main contributions: (1) the LCB-RB benchmark for reasoning process evaluation, (2) the OD-based method for reward model training to accurately score reasoning quality, and (3) the Posterior-GRPO RL algorithm, which selectively applies reasoning rewards to successful outcomes to avoid reward hacking.

Result: A 7B reward model trained with the OD-based method achieves SOTA on LCB-RB and generalizes well. The 7B parameter code-generation model trained with P-GRPO outperforms outcome-only baselines by 4.5%, matches GPT-4-Turbo on code tasks, and is effective on mathematical reasoning tasks.

Conclusion: The proposed unified framework for RL in code generation, alongside the P-GRPO method, effectively incorporates and aligns reasoning quality during training, achieving superior performance and robust generalization to various benchmarks, including mathematical reasoning.

Abstract: Reinforcement learning (RL) has significantly advanced code generation for
large language models (LLMs). However, current paradigms rely on outcome-based
rewards from test cases, neglecting the quality of the intermediate reasoning
process. While supervising the reasoning process directly is a promising
direction, it is highly susceptible to reward hacking, where the policy model
learns to exploit the reasoning reward signal without improving final outcomes.
To address this, we introduce a unified framework that can effectively
incorporate the quality of the reasoning process during RL. First, to enable
reasoning evaluation, we develop LCB-RB, a benchmark comprising preference
pairs of superior and inferior reasoning processes. Second, to accurately score
reasoning quality, we introduce an Optimized-Degraded based (OD-based) method
for reward model training. This method generates high-quality preference pairs
by systematically optimizing and degrading initial reasoning paths along
curated dimensions of reasoning quality, such as factual accuracy, logical
rigor, and coherence. A 7B parameter reward model with this method achieves
state-of-the-art (SOTA) performance on LCB-RB and generalizes well to other
benchmarks. Finally, we introduce Posterior-GRPO (P-GRPO), a novel RL method
that conditions process-based rewards on task success. By selectively applying
rewards to the reasoning processes of only successful outcomes, P-GRPO
effectively mitigates reward hacking and aligns the model's internal reasoning
with final code correctness. A 7B parameter model with P-GRPO achieves superior
performance across diverse code generation tasks, outperforming outcome-only
baselines by 4.5%, achieving comparable performance to GPT-4-Turbo. We further
demonstrate the generalizability of our approach by extending it to
mathematical tasks. Our models, dataset, and code are publicly available.

</details>


### [9] [AI-assisted JSON Schema Creation and Mapping](https://arxiv.org/abs/2508.05192)
*Felix Neubauer,Jürgen Pleiss,Benjamin Uekermann*

Main category: cs.SE

TL;DR: This paper presents a user-friendly, hybrid LLM and deterministic technique for creating and mapping data schemas from natural language, integrated with the open-source MetaConfigurator tool. It simplifies structured data modeling and integration for non-experts, with proven benefits in chemistry research.


<details>
  <summary>Details</summary>
Motivation: Many domains lack standardized data models, making it difficult for non-experts to create, modify, and integrate schemas for research datasets. This impedes data-driven progress and interoperability.

Method: A hybrid approach is introduced, combining large language models (LLMs) for interpreting natural language and generating JSON schemas and mappings, with deterministic techniques to validate and execute mapping rules. This solution is integrated into the open-source MetaConfigurator tool, which offers visual editing, validation, and code/form generation.

Result: The approach enables users, including non-experts, to create and modify JSON Schemas and establish schema mappings across diverse data formats (JSON, CSV, XML, YAML) using natural language. It ensures scalability and reliability by applying deterministic mapping rule execution.

Conclusion: Integrating natural language-driven schema generation and mapping with deterministic safeguards in MetaConfigurator greatly reduces barriers for non-experts in structured data modeling and integration, as demonstrated in the field of chemistry.

Abstract: Model-Driven Engineering (MDE) places models at the core of system and data
engineering processes. In the context of research data, these models are
typically expressed as schemas that define the structure and semantics of
datasets. However, many domains still lack standardized models, and creating
them remains a significant barrier, especially for non-experts. We present a
hybrid approach that combines large language models (LLMs) with deterministic
techniques to enable JSON Schema creation, modification, and schema mapping
based on natural language inputs by the user. These capabilities are integrated
into the open-source tool MetaConfigurator, which already provides visual model
editing, validation, code generation, and form generation from models. For data
integration, we generate schema mappings from heterogeneous JSON, CSV, XML, and
YAML data using LLMs, while ensuring scalability and reliability through
deterministic execution of generated mapping rules. The applicability of our
work is demonstrated in an application example in the field of chemistry. By
combining natural language interaction with deterministic safeguards, this work
significantly lowers the barrier to structured data modeling and data
integration for non-experts.

</details>


### [10] [STEPWISE-CODEX-Bench: Evaluating Complex Multi-Function Comprehension and Fine-Grained Execution Reasoning](https://arxiv.org/abs/2508.05193)
*Kaiwen Yan,Yuhang Chang,Zirui Guo,Yaling Mou,Jiang Ming,Jingwei Sun*

Main category: cs.SE

TL;DR: The paper introduces SX-Bench, a novel benchmark for evaluating complex code reasoning in LLMs. Unlike prior benchmarks, it focuses on multi-function tasks and fine-grained execution steps, revealing significant performance gaps among advanced models and providing a powerful tool for in-depth model assessment.


<details>
  <summary>Details</summary>
Motivation: Existing benchmarks for evaluating code understanding in large language models (LLMs) mainly focus on functional correctness or simple low-complexity reasoning, leading to saturated scores and insufficient discrimination among advanced models.

Method: The paper introduces STEPWISE-CODEX-Bench (SX-Bench), a new benchmark for testing multi-function understanding and execution reasoning in code. SX-Bench requires models to predict computation steps in reasoning tasks and includes scenarios involving chained function calls and complex control/data flow. It incorporates an automated pipeline using program synthesis, symbolic execution, and LLM-aided validation for generating and validating benchmark tasks.

Result: SX-Bench proved highly discriminative in experiments with over 20 mainstream and reasoning-enhanced models; even top-performing models like OpenAI-O3 could only achieve 78.37% accuracy on the hardest tasks, highlighting current limitations in complex code reasoning.

Conclusion: SX-Bench effectively reveals the limitations of current LLMs in multi-function understanding and complex execution reasoning, enabling deeper and more granular evaluation than previous benchmarks.

Abstract: In recent years, large language models (LLMs) have made significant progress
in code intelligence, yet systematically evaluating their code understanding
and reasoning abilities remains challenging. Mainstream benchmarks such as
HumanEval and MBPP primarily assess functional correctness, while reasoning
benchmarks like CRUXEVAL are limited to single-function, low-complexity
scenarios. As a result, advanced models achieve nearly saturated scores,
limiting their discriminative power. To address this, we present
STEPWISE-CODEX-Bench (SX-Bench), a novel benchmark designed for complex
multi-function understanding and fine-grained execution reasoning. SX-Bench
features tasks involving collaboration among multiple sub-functions (e.g.,
chained calls, nested loops), shifting evaluation towards overall control and
data flow modeling. It defines "computation steps" as the minimal execution
unit and requires models to predict the total number of steps in reasoning
tasks, thereby assessing a model's in-depth understanding of dynamic execution
beyond simple I/O matching. Evaluation on over 20 mainstream models (including
14 reasoning-enhanced models) demonstrates that SX-Bench is highly
discriminative: even the state-of-the-art OpenAI-O3 achieves only 78.37 percent
accuracy on Hard-Reasoning tasks, much lower than its saturated scores on
previous benchmarks, thereby revealing bottlenecks in complex and fine-grained
reasoning. We also release an automated pipeline combining program synthesis,
symbolic execution, and LLM-aided validation for efficient benchmark generation
and quality assurance. SX-Bench advances code evaluation from "single-function
verification" to "multi-function dynamic reasoning," providing a key tool for
the in-depth assessment of advanced code intelligence models.

</details>


### [11] [EvoGraph: Hybrid Directed Graph Evolution toward Software 3.0](https://arxiv.org/abs/2508.05199)
*Igor Costa,Christopher Baran*

Main category: cs.SE

TL;DR: EvoGraph is a new framework using small language models and graph theory to automatically modernize and maintain legacy software with high accuracy and efficiency, greatly reducing costs and lead times versus traditional and large-model-based methods.


<details>
  <summary>Details</summary>
Motivation: Modernizing and maintaining legacy software systems is challenging due to issues such as security vulnerabilities, outdated documentation, and the cost of translating between languages. Existing approaches often struggle with performance, semantic equivalence, and computational cost, especially when relying on large language models. The motivation is to create a more adaptive and efficient solution for code evolution and modernization.

Method: The paper presents EvoGraph, a framework that models all software artefacts (source code, build pipelines, documentation, and tickets) as a typed directed graph. It uses specialized small language models (SLMs) to apply mutation operators and employs multi-objective fitness functions to select the best outcomes. EvoGraph is empirically validated on several benchmarks and extended to handle various language modernization tasks with language-specific SLMs.

Result: EvoGraph achieves impressive results across multiple tasks: fixing 83% of known security vulnerabilities, translating COBOL to Java with 93% test-verified functional equivalence, and keeping documentation updated within two minutes. Compared with strong baselines, it reduces latency by 40% and feature lead time by a factor of seven. When extended to more languages, it achieves 82-96% semantic equivalence and reduces computational costs by 90% compared to large language models.

Conclusion: EvoGraph offers a promising and practical approach for adaptive, automatic modernization of legacy software, balancing adaptability and control. It effectively addresses empirical failure modes such as implicit contracts, performance preservation, and integration evolution, paving the way for adaptive Software 3.0 systems.

Abstract: We introduce **EvoGraph**, a framework that enables software systems to
evolve their own source code, build pipelines, documentation, and tickets.
EvoGraph represents every artefact in a typed directed graph, applies learned
mutation operators driven by specialized small language models (SLMs), and
selects survivors with a multi-objective fitness. On three benchmarks, EvoGraph
fixes 83% of known security vulnerabilities, translates COBOL to Java with 93%
functional equivalence (test verified), and maintains documentation freshness
within two minutes. Experiments show a 40% latency reduction and a sevenfold
drop in feature lead time compared with strong baselines. We extend our
approach to **evoGraph**, leveraging language-specific SLMs for modernizing
.NET, Lisp, CGI, ColdFusion, legacy Python, and C codebases, achieving 82-96%
semantic equivalence across languages while reducing computational costs by 90%
compared to large language models. EvoGraph's design responds to empirical
failure modes in legacy modernization, such as implicit contracts, performance
preservation, and integration evolution. Our results suggest a practical path
toward Software 3.0, where systems adapt continuously yet remain under
measurable control.

</details>


### [12] [A Conceptual Model and Methodology for Sustainability-aware, IoT-enhanced Business Processes](https://arxiv.org/abs/2508.05301)
*Victoria Torres Bosch,Ronny Seiger,Manuela Albert Albiol,Antoni Mestre Gascon,Pedro Jose Valderas Aranda*

Main category: cs.SE

TL;DR: The paper proposes a structured approach to use IoT for improving business process sustainability across all major dimensions, not just environmental, with case studies in tourism and healthcare showing how the method works in practice.


<details>
  <summary>Details</summary>
Motivation: While IoT has enabled advances in business processes through real-time data and automation, research on sustainability in BPM has mainly focused on environmental aspects. There is a need to address sustainability more comprehensively across all its dimensions (environmental, social, and economic).

Method: The authors propose a conceptual model that formally represents and connects sustainability concepts within BPM and IoT. They also develop a structured methodology for systematically analyzing and improving the sustainability of business processes using IoT. The model and methodology are demonstrated with examples from tourism and healthcare.

Result: The paper presents an approach that enables systematic analysis and enhancement of business process sustainability by leveraging IoT. The case studies from tourism and healthcare demonstrate the utility and applicability of the proposed model and methodology.

Conclusion: A holistic, systematic approach to integrating IoT with BPM can enhance the sustainability of business processes beyond just environmental factors. The proposed conceptual model and methodology are effective tools for identifying and realizing sustainability opportunities in diverse domains.

Abstract: The real-time data collection and automation capabilities offered by the
Internet of Things (IoT) are revolutionizing and transforming Business
Processes (BPs) into IoT-enhanced BPs, showing high potential for improving
sustainability. Although already studied in Business Process Management (BPM),
sustainability research has primarily focused on environmental concerns.
However, achieving a holistic and lasting impact requires a systematic approach
to address sustainability beyond the environmental dimension. This work
proposes a conceptual model and a structured methodology with the goal of
analyzing the potential of IoT to measure and improve the sustainability of
BPs. The conceptual model formally represents key sustainability concepts,
linking BPM and IoT by highlighting how IoT devices support and contribute to
sustainability. The methodology guides the systematic analysis of existing BPs,
identifies opportunities, and implements sustainability-aware, IoT-enhanced
BPs. The approach is illustrated through a running example from the tourism
domain and a case study in healthcare.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [13] [Consistent Updates for Scalable Microservices](https://arxiv.org/abs/2508.04829)
*Devora Chait-Roth,Kedar S. Namjoshi,Thomas Wies*

Main category: cs.PL

TL;DR: This paper solves the challenge of safely updating live microservices by presenting algorithms and a theory that guarantee consistency during mixed-mode operations, relying on semantic properties like commutativity. The work avoids inefficiency and risks of current methods, enabling atomic-feeling updates for clients.


<details>
  <summary>Details</summary>
Motivation: Online services using microservice architectures require updates to be made live (on the fly) without halting service, but this causes 'mixed mode' operations where old and new versions interact, risking inconsistency. Existing solutions either waste resources or degrade performance, while rolling updates can lead to failures.

Method: The paper introduces new algorithms that guarantee consistency during mixed-mode updates by leveraging semantic properties of service actions, such as commutativity. It develops a theoretical framework for reasoning about consistency and uses it to derive and validate these algorithms.

Result: The proposed algorithms can successfully maintain consistency in mixed-mode updates, unlike prior semantically oblivious methods. The framework formalizes the ideal of atomic updates from the client perspective, and the correctness of the algorithms is established theoretically.

Conclusion: Semantic understanding of service actions is essential for consistent mixed-mode updates in microservices. The introduced framework and algorithms solve the problem, allowing safe, efficient updates without sacrificing throughput or doubling resource needs.

Abstract: Online services are commonly implemented with a scalable microservice
architecture, where isomorphic worker processes service client requests,
recording persistent state in a backend data store. To maintain service, any
modifications to the service functionality must be made on the fly -- i.e., as
the service continues to process client requests -- but doing so is
challenging. The central difficulty is that of avoiding potential
inconsistencies caused by ''mixed mode'' operation, where workers of current
and new versions are concurrently active and interact via the data store. Some
update methods avoid mixed mode altogether, but only at the cost of substantial
inefficiency -- by doubling resources (memory and compute), or by halving
throughput. The alternative is a so-called ''rolling'' update, which is
uncontrolled and runs the risk of serious service failures arising from
inconsistent mixed-mode behavior.
  In this paper, we present the first algorithms that guarantee consistency for
mixed mode updates. The algorithms rely on semantic properties of service
actions, such as commutativity. We show that semantic awareness is required, by
proving that any semantically oblivious, mixed-mode update method cannot avoid
inconsistencies. Ideally, it should appear to every client that a service
update takes effect atomically; this ensures that a client is not exposed to
inconsistent mixed-mode behavior. We introduce a framework that formalizes this
intuition and develop foundational theory for reasoning about the consistency
of mixed-mode updates, applying that theory to derive the new algorithms and
establish their correctness.

</details>

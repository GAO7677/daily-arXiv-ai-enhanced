<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 12]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Automated File-Level Logging Generation for Machine Learning Applications using LLMs: A Case Study using GPT-4o Mini](https://arxiv.org/abs/2508.04820)
*Mayra Sofia Ruiz Rodriguez,SayedHassan Khatoonabadi,Emad Shihab*

Main category: cs.SE

TL;DR: This paper evaluates the capability of GPT-4o mini to automatically generate file-level log statements for machine learning projects. While the model places logs similarly to humans most of the time, it generates too many logs and fails to adapt to project-specific conventions, limiting its usefulness for automated logging without further improvement.


<details>
  <summary>Details</summary>
Motivation: The motivation behind this paper is the need for effective logging in software development, particularly in machine learning projects, to enhance reliability. The use of large language models to automate log statement generation is an emerging area, but prior studies have largely ignored file-level log generation, leaving a gap in understanding their efficacy outside the function level.

Method: The authors performed an empirical evaluation of GPT-4o mini, using it to generate log statements for Python files sourced from 171 ML repositories. They removed existing human-written log statements, prompted the LLM to generate new ones, and compared these generated logs against original logs based on placement, log level, variable use, and text quality. A manual qualitative analysis was also conducted to examine common generation patterns and challenges.

Result: GPT-4o mini generated log statements that matched human placement in 63.91% of cases. However, this came with a significant overlogging rate of 82.66%. The manual analysis highlighted notable problems including tendency to overlog at certain code locations (e.g., start/end of functions), inability to handle large code blocks effectively, and lack of adherence to project-specific logging conventions.

Conclusion: The study concludes that while LLMs show potential in generating file-level log statements, critical challenges such as overlogging and misalignment with project norms need to be solved before such models can be practically used in automated logging for ML projects.

Abstract: Logging is essential in software development, helping developers monitor
system behavior and aiding in debugging applications. Given the ability of
large language models (LLMs) to generate natural language and code, researchers
are exploring their potential to generate log statements. However, prior work
focuses on evaluating logs introduced in code functions, leaving file-level log
generation underexplored -- especially in machine learning (ML) applications,
where comprehensive logging can enhance reliability. In this study, we evaluate
the capacity of GPT-4o mini as a case study to generate log statements for ML
projects at file level. We gathered a set of 171 ML repositories containing
4,073 Python files with at least one log statement. We identified and removed
the original logs from the files, prompted the LLM to generate logs for them,
and evaluated both the position of the logs and log level, variables, and text
quality of the generated logs compared to human-written logs. In addition, we
manually analyzed a representative sample of generated logs to identify common
patterns and challenges. We find that the LLM introduces logs in the same place
as humans in 63.91% of cases, but at the cost of a high overlogging rate of
82.66%. Furthermore, our manual analysis reveals challenges for file-level
logging, which shows overlogging at the beginning or end of a function,
difficulty logging within large code blocks, and misalignment with
project-specific logging conventions. While the LLM shows promise for
generating logs for complete files, these limitations remain to be addressed
for practical implementation.

</details>


### [2] [Automated Bug Frame Retrieval from Gameplay Videos Using Vision-Language Models](https://arxiv.org/abs/2508.04895)
*Wentao Lu,Alexander Senchenko,Abram Hindle,Cor-Paul Bezemer*

Main category: cs.SE

TL;DR: This paper introduces an automated pipeline that uses keyframe extraction and a vision-language model to select a single, representative frame from gameplay bug report videos, matching the bug description. Tested on real game studio data, the method greatly reduces review effort, achieving strong accuracy and recall, and can improve bug triage efficiency for game QA teams.


<details>
  <summary>Details</summary>
Motivation: Game studios receive thousands of bug reports, many with gameplay videos, but verifying them requires tedious manual video review. This process is slow, labor-intensive, and doesn't scale well as patch frequency increases.

Method: The authors propose an automated pipeline: First, FFmpeg is used for keyframe extraction, drastically reducing the number of frames to review. Next, a vision-language model (GPT-4o) evaluates these keyframes against the bug's textual description and selects the best-matching frame for developers.

Result: On real-world gameplay videos and bug reports from a popular FPS title, the pipeline reduced frames to a median 1.90% of the original while capturing bug moments in 98.79% of cases. For selecting the single most relevant frame, their method achieved an F1 of 0.79 and accuracy of 0.89, with especially strong results for certain bug types.

Conclusion: Replacing manual video review with a single, automatically selected informative frame streamlines bug triage and significantly reduces QA and developer workload. The tool offers practical, effective benefits for studios handling large volumes of video-based bug reports.

Abstract: Modern game studios deliver new builds and patches at a rapid pace,
generating thousands of bug reports, many of which embed gameplay videos. To
verify and triage these bug reports, developers must watch the submitted
videos. This manual review is labour-intensive, slow, and hard to scale. In
this paper, we introduce an automated pipeline that reduces each video to a
single frame that best matches the reported bug description, giving developers
instant visual evidence that pinpoints the bug.
  Our pipeline begins with FFmpeg for keyframe extraction, reducing each video
to a median of just 1.90% of its original frames while still capturing bug
moments in 98.79 of cases. These keyframes are then evaluated by a
vision--language model (GPT-4o), which ranks them based on how well they match
the textual bug description and selects the most representative frame. We
evaluated this approach using real-world developer-submitted gameplay videos
and JIRA bug reports from a popular First-Person Shooter (FPS) game. The
pipeline achieves an overall F1 score of 0.79 and Accuracy of 0.89 for the
top-1 retrieved frame. Performance is highest for the Lighting & Shadow (F1 =
0.94), Physics & Collision (0.86), and UI & HUD (0.83) bug categories, and
lowest for Animation & VFX (0.51).
  By replacing video viewing with an immediately informative image, our
approach dramatically reduces manual effort and speeds up triage and regression
checks, offering practical benefits to quality assurance (QA) teams and
developers across the game industry.

</details>


### [3] [Charting Uncertain Waters: A Socio-Technical Framework for Navigating GenAI's Impact on Open Source Communities](https://arxiv.org/abs/2508.04921)
*Zixuan Feng,Reed Milewicz,Emerson Murphy-Hill,Tyler Menezes,Alexander Serebrenik,Igor Steinmacher,Anita Sarma*

Main category: cs.SE

TL;DR: Generative AI is rapidly changing OSS development, creating uncertainty and risk. This paper uses a socio-technical framework to explore and map the risks and opportunities in four critical domains, guiding OSS communities to proactively adapt rather than be overwhelmed.


<details>
  <summary>Details</summary>
Motivation: The motivation is to address the uncertainty and potential disruption that Generative AI (GenAI) brings to Open Source Software (OSS) communities, which lack clear frameworks for navigating these changes.

Method: The method is a scenario-driven, conceptual exploration using a socio-technical framework inspired by McLuhan's Tetrad. This approach analyzes the impact of GenAI on OSS across four domains: software practices, documentation, community engagement, and governance.

Result: The result is an identification of both risks and opportunities for OSS communities as they face GenAI-driven disruptions. The paper highlights how OSS leaders and researchers can use the framework to proactively manage these changes.

Conclusion: The conclusion is that by applying a structured socio-technical lens, OSS communities can build resilience and actively shape their ecosystems in response to GenAI challenges, rather than passively reacting.

Abstract: Open Source Software communities face a wave of uncertainty as Generative AI
rapidly transforms how software is created, maintained, and governed. Without
clear frameworks, communities risk being overwhelmed by the complexity and
ambiguity introduced by GenAI, threatening the collaborative ethos that
underpins OSS. We conduct a scenario-driven, conceptual exploration using a
socio-technical framework inspired by McLuhan's Tetrad to surface both risks
and opportunities for community resilience amid GenAI-driven disruption of OSS
development across four domains: software practices, documentation, community
engagement, and governance. By adopting this lens, OSS leaders and researchers
can proactively shape the future of their ecosystems, rather than simply
reacting to technological upheaval.

</details>


### [4] [Taxonomy of Faults in Attention-Based Neural Networks](https://arxiv.org/abs/2508.04925)
*Sigma Jahan,Saurabh Singh Rajput,Tushar Sharma,Mohammad Masudur Rahman*

Main category: cs.SE

TL;DR: The paper systematically studies faults in attention-based neural networks, develops a new categorization of these faults, and provides practical diagnostic guidelines, addressing a significant gap in current deep learning fault analysis.


<details>
  <summary>Details</summary>
Motivation: Although attention mechanisms are fundamental to modern neural networks and have broad economic and technological impacts, there have been high-profile failures directly linked to these mechanisms. Existing deep learning fault taxonomies do not sufficiently address attention-specific errors, leaving practitioners without proper diagnostic guidance.

Method: The authors conducted a systematic empirical analysis of 555 real-world faults from 96 attention-based neural network projects. These faults were collected from platforms such as GitHub, Hugging Face, and Stack Overflow and analyzed to create a new taxonomy of attention-specific faults. They further examined symptoms and root causes, developing diagnostic heuristics based on these findings.

Result: The study introduced a novel taxonomy with seven attention-specific fault categories, showing that over 50% of faults in attention-based models stem from mechanisms unique to attention. Four diagnostic heuristics were developed, capable of explaining 33% of attention-specific faults.

Conclusion: This paper fills a critical gap by providing the first systematic analysis and diagnostic guidance for faults in attention-based neural networks, with actionable taxonomy and evidence-based heuristics for practitioners.

Abstract: Attention mechanisms are at the core of modern neural architectures, powering
systems ranging from ChatGPT to autonomous vehicles and driving a major
economic impact. However, high-profile failures, such as ChatGPT's nonsensical
outputs or Google's suspension of Gemini's image generation due to attention
weight errors, highlight a critical gap: existing deep learning fault
taxonomies might not adequately capture the unique failures introduced by
attention mechanisms. This gap leaves practitioners without actionable
diagnostic guidance. To address this gap, we present the first comprehensive
empirical study of faults in attention-based neural networks (ABNNs). Our work
is based on a systematic analysis of 555 real-world faults collected from 96
projects across ten frameworks, including GitHub, Hugging Face, and Stack
Overflow. Through our analysis, we develop a novel taxonomy comprising seven
attention-specific fault categories, not captured by existing work. Our results
show that over half of the ABNN faults arise from mechanisms unique to
attention architectures. We further analyze the root causes and manifestations
of these faults through various symptoms. Finally, by analyzing symptom-root
cause associations, we identify four evidence-based diagnostic heuristics that
explain 33.0% of attention-specific faults, offering the first systematic
diagnostic guidance for attention-based models.

</details>


### [5] [Generative AI for Object-Oriented Programming: Writing the Right Code and Reasoning the Right Logic](https://arxiv.org/abs/2508.05005)
*Gang Xu,Airong Wang,Yushan Pan*

Main category: cs.SE

TL;DR: The paper explores how large language models (LLMs) can be integrated into object-oriented programming (OOP) to benefit different types of programmers. It identifies key workflow stages where LLMs could enhance logical reasoning and code writing, and outlines approaches for improved programming experiences, addressing an underexplored area of AI application.


<details>
  <summary>Details</summary>
Motivation: While LLMs have rapidly advanced and impacted diverse fields, their potential to improve OOP learning and development is still largely unexplored. The lack of empirical understanding motivates this investigation.

Method: The authors present a conceptual vision by analyzing OOP tasks from the perspectives of programmers, mentors, and experienced developers. They identify key workflow stages where LLMs could be beneficial and propose enhancements in logic and coding via AI tools.

Result: The study highlights critical points in OOP workflows for effective LLM integration and suggests methods to augment the programming experience through logical reasoning and better code generation.

Conclusion: This paper concludes that integrating large language models (LLMs) into object-oriented programming (OOP) workflows can offer significant advantages, providing enhanced logical reasoning and improved code writing for various stakeholders.

Abstract: We find ourselves in the midst of an explosion in artificial intelligence
research, particularly with large language models (LLMs). These models have
diverse applications spanning finance, commonsense knowledge graphs, medicine,
and visual analysis. In the world of Object-Oriented Programming(OOP), a robust
body of knowledge and methods has been developed for managing complex tasks
through object-oriented thinking. However, the intersection of LLMs with OOP
remains an underexplored territory. Empirically, we currently possess limited
understanding of how LLMs can enhance the effectiveness of OOP learning and
code writing, as well as how we can evaluate such AI-powered tools. Our work
aims to address this gap by presenting a vision from the perspectives of key
stakeholders involved in an OOP task: programmers, mariners, and experienced
programmers. We identify critical junctures within typical coding workflows
where the integration of LLMs can offer significant benefits. Furthermore, we
propose ways to augment existing logical reasoning and code writing, ultimately
enhancing the programming experience.

</details>


### [6] [An ML-based Approach to Predicting Software Change Dependencies: Insights from an Empirical Study on OpenStack](https://arxiv.org/abs/2508.05034)
*Arabat,Ali,Sayagh,Mohammed,Hassine,Jameleddine*

Main category: cs.SE

TL;DR: As software grows, managing change dependencies is vital but often delayed and effort-intensive. Studying OpenStack, authors found most dependencies are caught late, causing developer overhead. They propose and test two ML models to predict and identify dependencies, showing strong performance, but highlight a need to boost precision further.


<details>
  <summary>Details</summary>
Motivation: Modern software systems are highly complex and have dependencies that span multiple components and teams. Properly identifying and managing these dependencies is critical for preventing build failures and incomplete deployments. However, many dependencies are detected late in the development process, leading to increased effort and delay.

Method: The authors conducted a preliminary study on the OpenStack software system to examine interdependencies among its changes over 10 years. They then developed and evaluated a semi-automated approach using two machine learning models: one to predict the likelihood of dependencies and another to identify specific pairs of dependent changes.

Result: The study found that 51.08% of dependencies in OpenStack are identified during code review, with a median delay of 5.06 hours, and developers spend a median of 57.12 hours searching among hundreds of changes to identify dependencies. The proposed ML models performed well, with average AUC scores of 79.33% and 91.89%, and Brier scores of 0.11 and 0.014. The second model exhibited good top-k recall for all pair types, although its top-k precision could be improved.

Conclusion: Dependency management in large-scale software like OpenStack is a significant challenge, often leading to delays and requiring extensive manual effort. Semi-automated ML-based approaches can effectively predict and help identify dependencies, potentially improving development efficiency, though further refinement to improve precision is needed.

Abstract: As software systems grow in complexity, accurately identifying and managing
dependencies among changes becomes increasingly critical. For instance, a
change that leverages a function must depend on the change that introduces it.
Establishing such dependencies allows CI/CD pipelines to build and orchestrate
changes effectively, preventing build failures and incomplete feature
deployments. In modern software systems, dependencies often span multiple
components across teams, creating challenges for development and deployment.
They serve various purposes, from enabling new features to managing
configurations, and can even involve traditionally independent changes like
documentation updates. To address these challenges, we conducted a preliminary
study on dependency management in OpenStack, a large-scale software system. Our
study revealed that a substantial portion of software changes in OpenStack over
the past 10 years are interdependent. Surprisingly, 51.08% of these
dependencies are identified during the code review phase-after a median delay
of 5.06 hours-rather than at the time of change creation. Developers often
spend a median of 57.12 hours identifying dependencies, searching among a
median of 463 other changes. To help developers proactively identify
dependencies, we propose a semi-automated approach that leverages two ML
models. The first model predicts the likelihood of dependencies among changes,
while the second identifies the exact pairs of dependent changes. Our proposed
models demonstrate strong performance, achieving average AUC scores of 79.33%
and 91.89%, and Brier scores of 0.11 and 0.014, respectively. Indeed, the
second model has a good top-k recall across all types of pairs, while the top-k
precision has room for improvement.

</details>


### [7] [LadyBug: A GitHub Bot for UI-Enhanced Bug Localization in Mobile Apps](https://arxiv.org/abs/2508.05085)
*Junayed Mahmud,James Chen,Terry Achille,Camilo Alvarez-Velez,Darren Dean Bansil,Patrick Ijieh,Samar Karanch,Nadeeshan De Silva,Oscar Chaparro,Andrian Marcus,Kevin Moran*

Main category: cs.SE

TL;DR: LadyBug is a GitHub bot for Android apps that improves bug localization by combining bug report text with UI reproduction traces, greatly outperforming traditional text-only methods according to empirical benchmarks.


<details>
  <summary>Details</summary>
Motivation: Automatic bug localization in mobile apps, especially Android, is challenging because traditional approaches using only textual bug reports are often not accurate enough. Developers need efficient tools to pinpoint the location of bugs to speed up debugging and improve software quality.

Method: LadyBug is a GitHub bot that leverages both the textual content of bug reports and UI interaction traces recorded by developers as they reproduce bugs. It communicates with the app's GitHub repository and, once a bug is reported, accepts reproduction traces that provide UI context. It then applies text retrieval techniques combined with UI information to suggest a ranked list of files likely to contain the bug.

Result: Empirical evaluation using the RedWing benchmark (80 bug reports from 39 apps) shows that LadyBug outperforms baseline methods that rely solely on text retrieval. The integration of UI context leads to significantly higher bug localization accuracy.

Conclusion: Combining textual bug report data with UI interaction traces offers a practical and more accurate approach to automatic bug localization in Android apps. LadyBug effectively implements this strategy and is available as open-source software.

Abstract: This paper introduces LadyBug, a GitHub bot that automatically localizes bugs
for Android apps by combining UI interaction information with text retrieval.
LadyBug connects to an Android app's GitHub repository, and is triggered when a
bug is reported in the corresponding issue tracker. Developers can then record
a reproduction trace for the bug on a device or emulator and upload the trace
to LadyBug via the GitHub issue tracker. This enables LadyBug to utilize both
the text from the original bug description, and UI information from the
reproduction trace to accurately retrieve a ranked list of files from the
project that most likely contain the reported bug.
  We empirically evaluated LadyBug using an automated testing pipeline and
benchmark called RedWing that contains 80 fully-localized and reproducible bug
reports from 39 Android apps. Our results illustrate that LadyBug outperforms
text-retrieval-based baselines and that the utilization of UI information leads
to a substantial increase in localization accuracy. LadyBug is an open-source
tool, available at https://github.com/LadyBugML/ladybug.
  A video showing the capabilities of Ladybug can be viewed here:
https://youtu.be/hI3tzbRK0Cw

</details>


### [8] [Posterior-GRPO: Rewarding Reasoning Processes in Code Generation](https://arxiv.org/abs/2508.05170)
*Lishui Fan,Yu Zhang,Mouxiang Chen,Zhongxin Liu*

Main category: cs.SE

TL;DR: This paper proposes a reinforcement learning framework for code generation that rewards both the reasoning process and final outcomes. By introducing new benchmarks, a reward model, and a novel RL method, the authors achieve improved code generation accuracy and mitigate reward hacking, outperforming baseline methods and matching GPT-4-Turbo performance.


<details>
  <summary>Details</summary>
Motivation: Reinforcement learning (RL) has improved code generation in large language models (LLMs), but most methods use only final outcome rewards (like passing test cases), ignoring the quality of the intermediate reasoning. Directly supervising the reasoning process is promising, but existing approaches suffer from reward hacking, where models exploit the reward without improving real outcomes.

Method: The authors introduce a unified framework for incorporating reasoning process quality into RL for code generation. They develop LCB-RB, a benchmark with preference pairs for comparing reasoning processes. They propose an Optimized-Degraded based (OD-based) reward model training method, generating preference pairs by optimizing and degrading reasoning paths along key reasoning qualities. They introduce Posterior-GRPO (P-GRPO), an RL technique that applies process-based rewards only to reasoning leading to successful outcomes, reducing reward hacking.

Result: The 7B parameter reward model trained using the new method achieves state-of-the-art performance on LCB-RB and generalizes to other benchmarks. The 7B parameter P-GRPO model outperforms outcome-only baselines by 4.5% and matches GPT-4-Turbo in code generation tasks. The approach also generalizes to mathematical reasoning.

Conclusion: Rewarding reasoning process quality in RL, especially when conditioned on successful task completion, yields better code generation in LLMs and mitigates reward hacking. The proposed framework, datasets, and models advance the state-of-the-art and are publicly available.

Abstract: Reinforcement learning (RL) has significantly advanced code generation for
large language models (LLMs). However, current paradigms rely on outcome-based
rewards from test cases, neglecting the quality of the intermediate reasoning
process. While supervising the reasoning process directly is a promising
direction, it is highly susceptible to reward hacking, where the policy model
learns to exploit the reasoning reward signal without improving final outcomes.
To address this, we introduce a unified framework that can effectively
incorporate the quality of the reasoning process during RL. First, to enable
reasoning evaluation, we develop LCB-RB, a benchmark comprising preference
pairs of superior and inferior reasoning processes. Second, to accurately score
reasoning quality, we introduce an Optimized-Degraded based (OD-based) method
for reward model training. This method generates high-quality preference pairs
by systematically optimizing and degrading initial reasoning paths along
curated dimensions of reasoning quality, such as factual accuracy, logical
rigor, and coherence. A 7B parameter reward model with this method achieves
state-of-the-art (SOTA) performance on LCB-RB and generalizes well to other
benchmarks. Finally, we introduce Posterior-GRPO (P-GRPO), a novel RL method
that conditions process-based rewards on task success. By selectively applying
rewards to the reasoning processes of only successful outcomes, P-GRPO
effectively mitigates reward hacking and aligns the model's internal reasoning
with final code correctness. A 7B parameter model with P-GRPO achieves superior
performance across diverse code generation tasks, outperforming outcome-only
baselines by 4.5%, achieving comparable performance to GPT-4-Turbo. We further
demonstrate the generalizability of our approach by extending it to
mathematical tasks. Our models, dataset, and code are publicly available.

</details>


### [9] [AI-assisted JSON Schema Creation and Mapping](https://arxiv.org/abs/2508.05192)
*Felix Neubauer,Jürgen Pleiss,Benjamin Uekermann*

Main category: cs.SE

TL;DR: A new tool, MetaConfigurator, combines AI and deterministic methods to let users easily create and map data schemas (like JSON) using plain language, making complex data modeling and integration accessible to non-experts.


<details>
  <summary>Details</summary>
Motivation: In many domains, standardized models and schemas are lacking, making data modeling and integration a difficult task, especially for non-experts. There is a need to simplify schema creation and mapping processes to improve data engineering outcomes.

Method: The authors present a hybrid approach that leverages large language models (LLMs) alongside deterministic techniques. This enables users to create, modify, and map JSON Schemas using natural language inputs. The method is implemented in the open-source tool MetaConfigurator, which also includes features for model editing, validation, code and form generation, and integrates schema mapping functions for various data formats (JSON, CSV, XML, YAML). Deterministic execution is used for the generated mapping rules to ensure scalability and reliability.

Result: MetaConfigurator allows for natural language-based schema management and mapping, demonstrated effectively in a chemistry application. Schema mappings across diverse formats are automated, and deterministic execution ensures trustworthiness and efficiency. The tool significantly eases structured data modeling and integration tasks for non-experts.

Conclusion: By combining the strengths of LLMs for flexible natural language interaction and deterministic mechanisms for rule application, the work makes structured data modeling and integration more accessible, especially to users without extensive technical background.

Abstract: Model-Driven Engineering (MDE) places models at the core of system and data
engineering processes. In the context of research data, these models are
typically expressed as schemas that define the structure and semantics of
datasets. However, many domains still lack standardized models, and creating
them remains a significant barrier, especially for non-experts. We present a
hybrid approach that combines large language models (LLMs) with deterministic
techniques to enable JSON Schema creation, modification, and schema mapping
based on natural language inputs by the user. These capabilities are integrated
into the open-source tool MetaConfigurator, which already provides visual model
editing, validation, code generation, and form generation from models. For data
integration, we generate schema mappings from heterogeneous JSON, CSV, XML, and
YAML data using LLMs, while ensuring scalability and reliability through
deterministic execution of generated mapping rules. The applicability of our
work is demonstrated in an application example in the field of chemistry. By
combining natural language interaction with deterministic safeguards, this work
significantly lowers the barrier to structured data modeling and data
integration for non-experts.

</details>


### [10] [STEPWISE-CODEX-Bench: Evaluating Complex Multi-Function Comprehension and Fine-Grained Execution Reasoning](https://arxiv.org/abs/2508.05193)
*Kaiwen Yan,Yuhang Chang,Zirui Guo,Yaling Mou,Jiang Ming,Jingwei Sun*

Main category: cs.SE

TL;DR: SX-Bench is a new benchmark for evaluating large language models' code reasoning and multi-function understanding. It overcomes the limitations of saturated previous benchmarks by testing models on complex tasks and computation steps. Results show modern LLMs still struggle with deep reasoning, highlighting areas for future improvement.


<details>
  <summary>Details</summary>
Motivation: Current code benchmarks for large language models (LLMs) focus mainly on simple functional correctness or low-complexity reasoning, resulting in saturated scores for advanced models and failing to truly distinguish their deeper reasoning capabilities.

Method: The paper proposes STEPWISE-CODEX-Bench (SX-Bench), a new benchmark designed for multi-function reasoning and fine-grained code understanding. It involves complex tasks requiring collaboration between sub-functions and asks models to predict total computation steps, evaluating dynamic execution modeling. An automated pipeline using program synthesis, symbolic execution, and LLM validation is released for benchmark creation and quality assurance.

Result: SX-Bench was tested on over 20 mainstream models, including 14 reasoning-enhanced LLMs. Even state-of-the-art models like OpenAI-O3 only scored 78.37% accuracy on Hard-Reasoning tasks, much lower than their performances on previous benchmarks. This confirms SX-Bench's ability to reveal nuanced limitations in existing models' complex reasoning abilities.

Conclusion: SX-Bench shifts code evaluation from simple, single-function checks to complex, multi-function, dynamic reasoning tasks. It is a crucial tool for probing the advanced reasoning and understanding of LLMs beyond basic correctness, enabling more granular and meaningful assessments.

Abstract: In recent years, large language models (LLMs) have made significant progress
in code intelligence, yet systematically evaluating their code understanding
and reasoning abilities remains challenging. Mainstream benchmarks such as
HumanEval and MBPP primarily assess functional correctness, while reasoning
benchmarks like CRUXEVAL are limited to single-function, low-complexity
scenarios. As a result, advanced models achieve nearly saturated scores,
limiting their discriminative power. To address this, we present
STEPWISE-CODEX-Bench (SX-Bench), a novel benchmark designed for complex
multi-function understanding and fine-grained execution reasoning. SX-Bench
features tasks involving collaboration among multiple sub-functions (e.g.,
chained calls, nested loops), shifting evaluation towards overall control and
data flow modeling. It defines "computation steps" as the minimal execution
unit and requires models to predict the total number of steps in reasoning
tasks, thereby assessing a model's in-depth understanding of dynamic execution
beyond simple I/O matching. Evaluation on over 20 mainstream models (including
14 reasoning-enhanced models) demonstrates that SX-Bench is highly
discriminative: even the state-of-the-art OpenAI-O3 achieves only 78.37 percent
accuracy on Hard-Reasoning tasks, much lower than its saturated scores on
previous benchmarks, thereby revealing bottlenecks in complex and fine-grained
reasoning. We also release an automated pipeline combining program synthesis,
symbolic execution, and LLM-aided validation for efficient benchmark generation
and quality assurance. SX-Bench advances code evaluation from "single-function
verification" to "multi-function dynamic reasoning," providing a key tool for
the in-depth assessment of advanced code intelligence models.

</details>


### [11] [EvoGraph: Hybrid Directed Graph Evolution toward Software 3.0](https://arxiv.org/abs/2508.05199)
*Igor Costa,Christopher Baran*

Main category: cs.SE

TL;DR: EvoGraph enables automated, high-quality evolution of software systems, fixing vulnerabilities, modernizing codebases across languages, and reducing both computational and operational costs. This approach leverages small language models, outperforms standard baselines, and represents a step toward self-adaptive Software 3.0.


<details>
  <summary>Details</summary>
Motivation: Legacy modernization and maintenance of software systems are challenging, involving manual and error-prone updates of source code, build pipelines, documentation, and tickets. There's a need for automated, efficient, and reliable systems that self-evolve while maintaining key quality attributes.

Method: EvoGraph uses a typed directed graph to represent all software artefacts, applies mutation operators driven by specialized small language models (SLMs), and employs multi-objective fitness functions for selection. The approach is benchmarked across legacy modernization tasks and extended to various languages using language-specific SLMs.

Result: EvoGraph fixes 83% of security vulnerabilities, translates COBOL to Java at 93% functional equivalence, and maintains documentation freshness within two minutes. It reduces latency by 40% and feature lead time sevenfold compared to baselines. When extended to multiple languages, it achieves 82-96% semantic equivalence and a 90% reduction in computational costs versus large LLMs.

Conclusion: EvoGraph shows a practical pathway for automated software evolution, addressing key empirical modernization failure modes and enabling continuous adaptation of systems under measurable control.

Abstract: We introduce **EvoGraph**, a framework that enables software systems to
evolve their own source code, build pipelines, documentation, and tickets.
EvoGraph represents every artefact in a typed directed graph, applies learned
mutation operators driven by specialized small language models (SLMs), and
selects survivors with a multi-objective fitness. On three benchmarks, EvoGraph
fixes 83% of known security vulnerabilities, translates COBOL to Java with 93%
functional equivalence (test verified), and maintains documentation freshness
within two minutes. Experiments show a 40% latency reduction and a sevenfold
drop in feature lead time compared with strong baselines. We extend our
approach to **evoGraph**, leveraging language-specific SLMs for modernizing
.NET, Lisp, CGI, ColdFusion, legacy Python, and C codebases, achieving 82-96%
semantic equivalence across languages while reducing computational costs by 90%
compared to large language models. EvoGraph's design responds to empirical
failure modes in legacy modernization, such as implicit contracts, performance
preservation, and integration evolution. Our results suggest a practical path
toward Software 3.0, where systems adapt continuously yet remain under
measurable control.

</details>


### [12] [A Conceptual Model and Methodology for Sustainability-aware, IoT-enhanced Business Processes](https://arxiv.org/abs/2508.05301)
*Victoria Torres Bosch,Ronny Seiger,Manuela Albert Albiol,Antoni Mestre Gascon,Pedro Jose Valderas Aranda*

Main category: cs.SE

TL;DR: This paper introduces a comprehensive model and methodology for integrating IoT into business processes to improve sustainability across environmental, social, and economic dimensions, and demonstrates its effectiveness in tourism and healthcare examples.


<details>
  <summary>Details</summary>
Motivation: While IoT has enhanced business processes and initial research links IoT and BPM to environmental sustainability, most studies neglect a broader, systematic approach to sustainability—including social and economic dimensions. There is a gap in integrating holistic sustainability goals into IoT-enhanced business processes.

Method: The authors propose a conceptual model that formally represents key sustainability concepts and illustrates the link between BPM and IoT, showing how IoT can contribute to sustainability. A structured methodology is then developed to systematically analyze, identify, and implement sustainability-aware, IoT-enhanced business processes. The methodology is demonstrated with tourism and healthcare examples.

Result: The work provides a structured and formalized approach to connect IoT and BPM with holistic sustainability, beyond just the environmental aspect. It identifies specific opportunities and procedures for making BPs more sustainable using IoT, validated through practical examples.

Conclusion: A new conceptual and methodological framework is introduced, enabling organizations to systematically evaluate and enhance the sustainability of their business processes through IoT integration, covering environmental, social, and economic dimensions. The framework's applicability is shown in different domains, indicating its generalizability.

Abstract: The real-time data collection and automation capabilities offered by the
Internet of Things (IoT) are revolutionizing and transforming Business
Processes (BPs) into IoT-enhanced BPs, showing high potential for improving
sustainability. Although already studied in Business Process Management (BPM),
sustainability research has primarily focused on environmental concerns.
However, achieving a holistic and lasting impact requires a systematic approach
to address sustainability beyond the environmental dimension. This work
proposes a conceptual model and a structured methodology with the goal of
analyzing the potential of IoT to measure and improve the sustainability of
BPs. The conceptual model formally represents key sustainability concepts,
linking BPM and IoT by highlighting how IoT devices support and contribute to
sustainability. The methodology guides the systematic analysis of existing BPs,
identifies opportunities, and implements sustainability-aware, IoT-enhanced
BPs. The approach is illustrated through a running example from the tourism
domain and a case study in healthcare.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [13] [Consistent Updates for Scalable Microservices](https://arxiv.org/abs/2508.04829)
*Devora Chait-Roth,Kedar S. Namjoshi,Thomas Wies*

Main category: cs.PL

TL;DR: Updating microservices on the fly risks inconsistencies when old and new versions run together. The authors prove only semantic-aware (not generic) methods can guarantee consistency, and provide new algorithms and a framework to safely and efficiently handle mixed-mode updates.


<details>
  <summary>Details</summary>
Motivation: In microservice architectures, updating service functionality on the fly is necessary for maintaining availability. However, this process risks 'mixed mode' inconsistencies when old and new versions of workers operate simultaneously. Existing methods to avoid mixed mode are either inefficient or risky.

Method: The authors present new algorithms that leverage the semantics (e.g., commutativity) of service actions to ensure consistency during mixed-mode updates. They also formalize a framework and provide a theoretical foundation for reasoning about consistency in updates, proving their algorithms are correct.

Result: They show that any update method that does not consider semantics cannot avoid inconsistencies. Their semantic-aware algorithms are proven to guarantee consistency during mixed-mode updates without sacrificing efficiency.

Conclusion: The paper establishes that semantic-based approaches are necessary and effective for safe, efficient live updates in microservices. Their framework and algorithms enable atomic-appearing updates and avoid inconsistent behaviors.

Abstract: Online services are commonly implemented with a scalable microservice
architecture, where isomorphic worker processes service client requests,
recording persistent state in a backend data store. To maintain service, any
modifications to the service functionality must be made on the fly -- i.e., as
the service continues to process client requests -- but doing so is
challenging. The central difficulty is that of avoiding potential
inconsistencies caused by ''mixed mode'' operation, where workers of current
and new versions are concurrently active and interact via the data store. Some
update methods avoid mixed mode altogether, but only at the cost of substantial
inefficiency -- by doubling resources (memory and compute), or by halving
throughput. The alternative is a so-called ''rolling'' update, which is
uncontrolled and runs the risk of serious service failures arising from
inconsistent mixed-mode behavior.
  In this paper, we present the first algorithms that guarantee consistency for
mixed mode updates. The algorithms rely on semantic properties of service
actions, such as commutativity. We show that semantic awareness is required, by
proving that any semantically oblivious, mixed-mode update method cannot avoid
inconsistencies. Ideally, it should appear to every client that a service
update takes effect atomically; this ensures that a client is not exposed to
inconsistent mixed-mode behavior. We introduce a framework that formalizes this
intuition and develop foundational theory for reasoning about the consistency
of mixed-mode updates, applying that theory to derive the new algorithms and
establish their correctness.

</details>

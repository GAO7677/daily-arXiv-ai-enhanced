<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 16]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Structural Code Search using Natural Language Queries](https://arxiv.org/abs/2507.02107)
*Ben Limpanukorn,Yanjun Wang,Zach Patterson,Pranav Garg,Murali Krishna Ramanathan,Xiaofei Ma,Anoop Deoras,Miryung Kim*

Main category: cs.SE

TL;DR: This paper introduces a way for developers to use natural language, instead of complex languages, to perform powerful structural code searches. By leveraging LLMs to translate queries, the approach outperforms traditional code search methods on several benchmarks.


<details>
  <summary>Details</summary>
Motivation: Developers frequently need to search code to understand APIs, learn code patterns, and navigate codebases. Traditional keyword and regex searches are easy to use but limited, while advanced structural code searches are more powerful but require difficult-to-learn domain-specific languages (DSLs), creating a barrier for many developers.

Method: The authors propose an approach that combines large language models (LLMs) to interpret natural language (NL) queries and translate them into DSL-based queries for structural code search tools such as Semgrep and GQL. They evaluated this method by creating a new benchmark dataset with 400 queries across 10 Java projects.

Result: The LLM-based translation of natural language queries to DSL queries achieves high precision and recall (55%â€“70%) for structural code search. The method outperforms baseline approaches (semantic code search and LLM-based direct retrieval) by up to 57% and 14% on F1 scores, respectively.

Conclusion: Allowing developers to use natural language for structural code searches lowers the usability barrier and significantly improves search performance, making structural searches more accessible and effective.

Abstract: Searching code is a common task that developers perform to understand APIs,
learn common code patterns, and navigate code. Currently, developers most
commonly search using keywords and regular expressions that are easy to use and
widely available. Beyond keywords and regular expressions, structural code
search tools allow developers to search for code based on its syntactic
structure. This has numerous applications ranging from bug finding to
systematically refactoring code. However, these structural code search tools
operate on queries expressed in domain-specific languages (DSL) that can be
difficult to learn and write. We propose to allow developers to use natural
language to search for code structurally. Expressing queries in natural
language provides an intuitive way to search for code and lowers the barrier to
entry.
  In this work, we develop a novel general approach that combines the reasoning
capabilities of an LLM to interpret natural language search queries with the
power of structural search tools to efficiently and accurately retrieve
relevant code. We then instantiate this approach for two structural code search
DSLs: Semgrep and GQL. In our evaluation, we construct a new benchmark for
structural code search consisting of 400 queries over 10 Java projects. We show
that our approach for structural code search based on translating NL queries to
DSL queries using an LLM is effective and robust, achieving a high precision
and recall ranging from 55% - 70%. Further, our approach significantly
outperforms baselines based on semantic code search and LLM retrievals by up to
57% and 14% on F1 scores.

</details>


### [2] [How do Software Engineering Candidates Prepare for Technical Interviews?](https://arxiv.org/abs/2507.02068)
*Brian Bell,Teresa Thomas,Sang Won Lee,Chris Brown*

Main category: cs.SE

TL;DR: Aspiring software engineers struggle to prepare for technical interviews due to lack of authentic practice and inadequate curricular support, leading to stress and unpreparedness. The study suggests improvements for educational and recruitment stakeholders.


<details>
  <summary>Details</summary>
Motivation: Aspiring software engineers face complex technical interviews that are not adequately addressed in typical computing curricula, making preparation challenging.

Method: The authors conducted a survey with 131 candidates actively preparing for technical interviews to investigate their preparation methods and the role of education.

Result: Candidates rarely practice in settings that mimic real interviews, and formal courses do not sufficiently help them prepare, resulting in significant stress and feelings of unpreparedness.

Conclusion: There is a need to improve educational approaches and preparation resources for technical interviews, and the paper provides recommendations for stakeholders to better support candidates pursuing software engineering roles.

Abstract: To obtain employment, aspiring software engineers must complete technical
interviews -- a hiring process which involves candidates writing code while
communicating to an audience. However, the complexities of tech interviews are
difficult to prepare for and seldom faced in computing curricula. To this end,
we seek to understand how candidates prepare for technical interviews,
investigating the effects of preparation methods and the role of education. We
distributed a survey to candidates (n = 131) actively preparing for technical
interviews. Our results suggest candidates rarely train in authentic settings
and courses fail to support preparation efforts -- leading to stress and
unpreparedness. Based on our findings, we provide implications for stakeholders
to enhance tech interview preparation for candidates pursuing software
engineering roles.

</details>


### [3] [Can Internal Software Metrics Predict App Popularity at Launch? Yeas! and Nays!](https://arxiv.org/abs/2507.02110)
*Md Nahidul Islam Opu,Fatima Islam Mouri,Rick Kazman,Yuanfang Cai,Shaiful Chowdhury*

Main category: cs.SE

TL;DR: This study shows that internal code metrics extracted before app release can moderately predict whether an app will become popular, with machine learning classification models outperforming regression. The results suggest developers can partially use these metrics to anticipate app reception.


<details>
  <summary>Details</summary>
Motivation: The motivation of this paper is to predict the popularity of mobile apps before their release to give developers a competitive advantage. The study addresses the challenge of whether internal software metrics, which can be measured before deployment, are effective indicators of later app popularity.

Method: The authors use a dataset of 446 open-source Android apps and extract various internal code metrics at the system, class, and method levels, along with code smells and app metadata. They complement these features with external information such as user reviews, download counts, and permissions from the Google Play Store. The study evaluates both regression and binary classification models using different feature sets, including a minimal baseline, a handpicked domain-informed set, and a set identified by feature selection algorithms.

Result: Regression models struggle due to skewed data and achieve low explanatory power. Reframing the problem as a binary classification (Popular vs. Unpopular) yields much better results, with the best model (a Multilayer Perceptron using the selected feature set) reaching an F1-score of 0.72.

Conclusion: Internal code metrics, while limited in explaining popularity, can still act as useful predictors for app popularity, contradicting previous findings that internal metrics are poor indicators of software quality.

Abstract: Predicting mobile app popularity before release can provide developers with a
strategic advantage in a competitive marketplace, yet it remains a challenging
problem. This study explores whether internal software metrics, measurable from
source code before deployment, can predict an app's popularity, defined by user
ratings (calculated from user reviews) and DownloadsPerYear (yearly downloads).
Using a dataset of 446 open-source Android apps from F-Droid, we extract a wide
array of features, including system-, class-, and method-level code metrics,
code smells, and app metadata. Additional information, such as user reviews,
download counts, and uses-permission, was collected from the Google Play Store.
We evaluate regression and classification models across three feature sets: a
minimal Size-only baseline, a domain-informed Handpicked set, and a Voting set
derived via feature selection algorithms. Regression models perform poorly due
to skewed data, with low $R^2$ scores. However, when reframed as binary
classification (Popular vs. Unpopular), results improve significantly. The best
model, a Multilayer Perceptron using the Voting set, achieves F1-scores of
0.72. These results suggest that internal code metrics, although limited in
their explanatory power, can serve as useful indicators of app popularity. This
challenges earlier findings that dismissed internal metrics as predictors of
software quality.

</details>


### [4] [A Multimodal Approach Combining Biometrics and Self-Report Instruments for Monitoring Stress in Programming: Methodological Insights](https://arxiv.org/abs/2507.02118)
*Cristina Martinez Montes,Daniela Grassi,Nicole Novielli,Birgit Penzenstadle*

Main category: cs.SE

TL;DR: Self-reports and biometrics were used to measure stress during programming; stricter time limits failed to induce clear stress. Only minor biometric changes were detected. The study suggests improvements for future research on stress measurement.


<details>
  <summary>Details</summary>
Motivation: Traditional self-report instruments to assess well-being and stress have inherent biases, leading researchers to explore more objective measures such as physiological (biometric) indicators. This paper is motivated by the need to evaluate the validity and effectiveness of combining subjective (psychometric) and objective (biometric) measures in stress assessment during software engineering tasks.

Method: The study involved an experiment: participants completed a pre-survey, performed two programming tasks while wearing biometric sensors, completed brief post-task surveys, and attended a short exit interview. The experiment aimed to compare psychometric (self-reported) and biometric (physiological) data, specifically under time-constrained conditions intended to induce stress.

Result: The results were mixed. Psychometric instruments did not detect stress. Interview feedback indicated a range of experiences, with some participants feeling no stress and others reporting time pressure. Biometric data revealed a significant difference only in EDA (electrodermal activity) phasic peaks, with no other clear stress indicators.

Conclusion: The attempt to induce stress using stricter time limits was inadequate. The study highlights the challenges of reliably inducing and measuring stress in such settings and provides methodological recommendations for future research involving stress, biometrics, and self-report instruments.

Abstract: The study of well-being, stress and other human factors has traditionally
relied on self-report instruments to assess key variables. However, concerns
about potential biases in these instruments, even when thoroughly validated and
standardised, have driven growing interest in alternatives in combining these
measures with more objective methods, such as physiological measures.
  We aimed to (i) compare psychometric stress measures and biometric indicators
and (ii) identify stress-related patterns in biometric data during software
engineering tasks.
  We conducted an experiment where participants completed a pre-survey, then
programmed two tasks wearing biometric sensors, answered brief post-surveys for
each, and finally went through a short exit interview.
  Our results showed diverse outcomes; we found no stress in the psychometric
instruments. Participants in the interviews reported a mix of feeling no stress
and experiencing time pressure. Finally, the biometrics showed a significant
difference only in EDA phasic peaks.
  We conclude that our chosen way of inducing stress by imposing a stricter
time limit was insufficient. We offer methodological insights for future
studies working with stress, biometrics, and psychometric instruments.

</details>


### [5] [Towards Trustworthy Sentiment Analysis in Software Engineering: Dataset Characteristics and Tool Selection](https://arxiv.org/abs/2507.02137)
*Martin Obaidi,Marc Herrmann,Jil KlÃ¼nder,Kurt Schneider*

Main category: cs.SE

TL;DR: Sentiment analysis tool performance in software development communications varies across platforms. This paper analyzes multiple datasets/tools, shows dataset features are crucial for tool selection, and proposes a guiding approach to select the right tool based on dataset characteristics.


<details>
  <summary>Details</summary>
Motivation: Sentiment analysis is increasingly used to understand developer team dynamics and support trustworthy AI analytics, especially in requirements engineering. However, existing sentiment analysis tools often yield inconsistent performance across different platforms due to diverse communication styles and data properties.

Method: The study analyzes linguistic and statistical features of 10 developer communication datasets from five different platforms. It then evaluates the performance of 14 sentiment analysis tools on these datasets. Based on the evaluation, the researchers propose a mapping approach and develop a questionnaire that recommends the most suitable sentiment analysis tools for new datasets depending on their specific characteristics.

Result: The analysis reveals that datasets from different platforms differ significantly in their linguistic and statistical properties. Transformer-based models like SetFit and RoBERTa generally perform well across datasets, but the best tool for a given context still depends on the specific characteristics of that dataset. The proposed mapping approach allows for improved selection of sentiment analysis tools for new contexts.

Conclusion: Dataset characteristics play a key role in determining the best sentiment analysis tool for software engineering communication data. No tool universally outperforms others; rather, effectiveness is context-dependent. The authors' mapping approach and questionnaire aid selection, but continual evaluation is necessary as communication styles evolve.

Abstract: Software development relies heavily on text-based communication, making
sentiment analysis a valuable tool for understanding team dynamics and
supporting trustworthy AI-driven analytics in requirements engineering.
However, existing sentiment analysis tools often perform inconsistently across
datasets from different platforms, due to variations in communication style and
content.
  In this study, we analyze linguistic and statistical features of 10 developer
communication datasets from five platforms and evaluate the performance of 14
sentiment analysis tools. Based on these results, we propose a mapping approach
and questionnaire that recommends suitable sentiment analysis tools for new
datasets, using their characteristic features as input.
  Our results show that dataset characteristics can be leveraged to improve
tool selection, as platforms differ substantially in both linguistic and
statistical properties. While transformer-based models such as SetFit and
RoBERTa consistently achieve strong results, tool effectiveness remains
context-dependent. Our approach supports researchers and practitioners in
selecting trustworthy tools for sentiment analysis in software engineering,
while highlighting the need for ongoing evaluation as communication contexts
evolve.

</details>


### [6] [Enhancing COBOL Code Explanations: A Multi-Agents Approach Using Large Language Models](https://arxiv.org/abs/2507.02182)
*Fangjian Lei,Jiawen Liu,Shayan Noei,Ying Zou,Derek Truong,William Alexander*

Main category: cs.SE

TL;DR: A new multi-agent LLM approach can generate much better explanations for legacy COBOL code than previous methods, working even for long files, and thereby aids maintainability and understanding of these critical systems.


<details>
  <summary>Details</summary>
Motivation: COBOL is widely used in critical business and government systems but is hard to maintain due to its age, complexity, lack of documentation, and a shrinking pool of COBOL developers. Existing AI-based code explanation methods struggle with COBOL due to its unique structure and large code sizes exceeding LLM token limits.

Method: The authors propose a multi-agent system using two large language model (LLM)-based agents collaboratively to generate explanations at function, file, and project levels, effectively incorporating contextual information from COBOL codebases into prompts.

Result: The proposed approach was evaluated on 14 open-source COBOL projects and outperformed the baseline in various code explanation quality metrics, achieving significant improvements at both function and file levels. At the project level, the system successfully generated useful explanations for 82% of the projects.

Conclusion: The multi-agent LLM-based method provides significantly better code explanations for COBOL systems at multiple code granularities and helps mitigate documentation and maintenance challenges posed by COBOL's legacy nature and syntactic complexity.

Abstract: Common Business Oriented Language (COBOL) is a programming language used to
develop business applications that are widely adopted by financial, business,
and government agencies. Due to its age, complexity, and declining number of
COBOL developers, maintaining COBOL codebases is becoming increasingly
challenging. In particular, the lack of documentation makes it difficult for
new developers to effectively understand and maintain COBOL systems. Existing
research utilizes large language models (LLMs) to explain the functionality of
code snippets. However, COBOL presents unique challenges due to its
architectural and syntactical differences, which often cause its code to exceed
the token window size of LLMs. In this work, we propose a multi-agent approach
that leverages two LLM-based agents working collaboratively to generate
explanations for functions, files, and the overall project. These agents
incorporate together by utilizing contextual information from the codebase into
the code explanation prompts. We evaluate the effectiveness of our approach
using 14 open-source, real-world COBOL projects. Our results indicate that our
approach performs significantly better than the baseline in function code
explanation, with improvements of 12.67%, 18.59%, and 0.62% in terms of METEOR,
chrF, and SentenceBERT scores, respectively. At the file level, our approach
effectively explains both short and long COBOL files that exceed the token
window size of LLMs and surpass the baseline by 4.21%, 10.72%, and 14.68% in
explaining the purpose, functionality, and clarity of the generated
explanation. At the project level, our approach generates explanations that
convey the functionality and purpose of 82% of the selected projects.

</details>


### [7] [Precisely Detecting Python Type Errors via LLM-based Unit Test Generation](https://arxiv.org/abs/2507.02318)
*Chen Yang,Ziqi Wang,Yanjie Jiang,Lin Yang,Yuteng Zheng,Jianyi Zhou,Junjie Chen*

Main category: cs.SE

TL;DR: RTED is a novel tool that uses type-aware test generation with constraint analysis and reflective validation to detect Python type errors. It outperforms current tools by finding more bugs and reducing false positives, demonstrating its effectiveness on benchmarks and real projects.


<details>
  <summary>Details</summary>
Motivation: Type errors in Python can cause runtime failures, impacting software reliability and developer productivity. Existing static analysis tools often produce false positives, and test generation techniques lack focused guidance for exposing these bugs.

Method: RTED, a new type-aware test generation technique, is proposed. It combines step-by-step type constraint analysis with reflective validation to guide the process and reduce false positives.

Result: RTED outperforms four state-of-the-art techniques on BugsInPy and TypeBugs benchmarks, detecting 22-29 more type errors and achieving 173.9%-245.9% improvement in precision (fewer false positives). RTED also found 12 previously unknown type errors in real-world projects.

Conclusion: RTED is effective at automatically detecting Python type errors, producing more true positives and significantly fewer false positives than existing methods.

Abstract: Type errors in Python often lead to runtime failures, posing significant
challenges to software reliability and developer productivity. Existing static
analysis tools aim to detect such errors without execution but frequently
suffer from high false positive rates. Recently, unit test generation
techniques offer great promise in achieving high test coverage, but they often
struggle to produce bug-revealing tests without tailored guidance. To address
these limitations, we present RTED, a novel type-aware test generation
technique for automatically detecting Python type errors. Specifically, RTED
combines step-by-step type constraint analysis with reflective validation to
guide the test generation process and effectively suppress false positives. We
evaluated RTED on two widely-used benchmarks, BugsInPy and TypeBugs.
Experimental results show that RTED can detect 22-29 more benchmarked type
errors than four state-of-the-art techniques. RTED is also capable of producing
fewer false positives, achieving an improvement of 173.9%-245.9% in precision.
Furthermore, RTED successfully discovered 12 previously unknown type errors
from six real-world open-source Python projects.

</details>


### [8] [VeFIA: An Efficient Inference Auditing Framework for Vertical Federated Collaborative Software](https://arxiv.org/abs/2507.02376)
*Chung-ju Huang,Ziqi Zhang,Yinggui Wang,Binghui Wang,Tao Wei,Leye Wang*

Main category: cs.SE

TL;DR: This paper proposes VeFIA, a framework for auditing inference execution correctness in Vertical Federated Learning systems using TEEs and random sampling, offering high detection accuracy without compromising privacy or performance.


<details>
  <summary>Details</summary>
Motivation: Existing Vertical Federated Learning (VFL) systems do not have mechanisms to ensure or audit the execution correctness of the inference software at the data parties, risking undetected errors or tampering.

Method: The authors propose the Vertical Federated Inference Auditing (VeFIA) framework, which leverages Trusted Execution Environments (TEE) and a coordinator to enable the task party to validate the inference software's execution correctness at data parties. VeFIA uses random sampling validation, ensuring privacy and without introducing additional online inference latency.

Result: VeFIA can reliably detect if abnormal inference execution exceeds 5.4%, achieving a 99.99% detection probability, and offers 100% positive and negative predictive value as well as true positive rate in experiments.

Conclusion: VeFIA provides a practical, privacy-preserving, and highly accurate solution for auditing the execution correctness of inference software in VFL, representing a first in addressing this overlooked aspect of VFL security.

Abstract: Vertical Federated Learning (VFL) is a distributed AI software deployment
mechanism for cross-silo collaboration without accessing participants' data.
However, existing VFL work lacks a mechanism to audit the execution correctness
of the inference software of the data party. To address this problem, we design
a Vertical Federated Inference Auditing (VeFIA) framework. VeFIA helps the task
party to audit whether the data party's inference software is executed as
expected during large-scale inference without leaking the data privacy of the
data party or introducing additional latency to the inference system. The core
of VeFIA is that the task party can use the inference results from a framework
with Trusted Execution Environments (TEE) and the coordinator to validate the
correctness of the data party's computation results. VeFIA guarantees that, as
long as the abnormal inference exceeds 5.4%, the task party can detect
execution anomalies in the inference software with a probability of 99.99%,
without incurring any additional online inference latency. VeFIA's random
sampling validation achieves 100% positive predictive value, negative
predictive value, and true positive rate in detecting abnormal inference. To
the best of our knowledge, this is the first paper to discuss the correctness
of inference software execution in VFL.

</details>


### [9] [Meta-Fair: AI-Assisted Fairness Testing of Large Language Models](https://arxiv.org/abs/2507.02533)
*Miguel Romero-Arjona,JosÃ© A. Parejo,Juan C. Alonso,Ana B. SÃ¡nchez,Aitor Arrieta,Sergio Segura*

Main category: cs.SE

TL;DR: Meta-Fair introduces an automated, scalable method for detecting bias in large language models using metamorphic testing and LLM-driven test generation plus evaluation. It achieves high precision and effectiveness, offering a promising alternative to resource-heavy manual fairness testing methods.


<details>
  <summary>Details</summary>
Motivation: Ensuring fairness in AI systems, particularly large language models (LLMs), is challenging due to the resource-intensive and non-scalable nature of current manual and heuristic-based fairness assessments. This motivates new, automated methods that can generalize across domains and scale efficiently.

Method: The proposed method, Meta-Fair, uses metamorphic testing by applying controlled modifications (metamorphic relations, MRs) to input prompts, then examines how LLM outputs change accordingly. LLMs are also leveraged for generating diverse test cases and for evaluating the output responses for bias.

Result: Experiments on 12 pre-trained LLMs, across 14 metamorphic relations and 5 bias dimensions with 7,900 generated test cases, show that Meta-Fair detects bias effectively: it achieves 92% average precision and uncovers bias in 29% of executions. LLMs also proved reliable as evaluators, with the top models reaching F1-scores up to 0.79. While non-determinism affects consistency, better MR design can reduce these impacts.

Conclusion: Meta-Fair demonstrates high effectiveness and significant automation potential for fairness testing in LLMs, reducing dependence on manual resources. While there are remaining challenges in generalization, Meta-Fair represents a promising direction for scalable, automated LLM fairness evaluation.

Abstract: Fairness--the absence of unjustified bias--is a core principle in the
development of Artificial Intelligence (AI) systems, yet it remains difficult
to assess and enforce. Current approaches to fairness testing in large language
models (LLMs) often rely on manual evaluation, fixed templates, deterministic
heuristics, and curated datasets, making them resource-intensive and difficult
to scale. This work aims to lay the groundwork for a novel, automated method
for testing fairness in LLMs, reducing the dependence on domain-specific
resources and broadening the applicability of current approaches. Our approach,
Meta-Fair, is based on two key ideas. First, we adopt metamorphic testing to
uncover bias by examining how model outputs vary in response to controlled
modifications of input prompts, defined by metamorphic relations (MRs). Second,
we propose exploiting the potential of LLMs for both test case generation and
output evaluation, leveraging their capability to generate diverse inputs and
classify outputs effectively. The proposal is complemented by three open-source
tools supporting LLM-driven generation, execution, and evaluation of test
cases. We report the findings of several experiments involving 12 pre-trained
LLMs, 14 MRs, 5 bias dimensions, and 7.9K automatically generated test cases.
The results show that Meta-Fair is effective in uncovering bias in LLMs,
achieving an average precision of 92% and revealing biased behaviour in 29% of
executions. Additionally, LLMs prove to be reliable and consistent evaluators,
with the best-performing models achieving F1-scores of up to 0.79. Although
non-determinism affects consistency, these effects can be mitigated through
careful MR design. While challenges remain to ensure broader applicability, the
results indicate a promising path towards an unprecedented level of automation
in LLM testing.

</details>


### [10] [LLMREI: Automating Requirements Elicitation Interviews with LLMs](https://arxiv.org/abs/2507.02564)
*Alexander Korn,Samuel Gorsch,Andreas Vogelsang*

Main category: cs.SE

TL;DR: The paper introduces LLMREI, a chatbot that automates requirements elicitation interviews using prompting-based methods. It performs similarly to humans in terms of errors, extracts most relevant requirements, and adapts questions to context. Fine-tuning was ineffective. LLMREI is particularly promising for large-scale stakeholder interviews.


<details>
  <summary>Details</summary>
Motivation: Requirements elicitation interviews are essential but depend on skilled, resource-intensive analysts. These interviews are prone to human error, bias, and miscommunication, thus motivating efforts to automate and improve efficiency while maintaining quality.

Method: The paper introduces LLMREI, a chatbot designed to automate requirements elicitation interviews. It compares two main approaches: zero-shot prompting and least-to-most prompting, evaluating them in 33 simulated stakeholder interviews. Fine-tuning was considered but discarded after poor preliminary results. The chatbot is assessed on error minimization, requirements extraction, and adaptability in questioning.

Result: LLMREI made a similar number of errors as human interviewers, extracted a large portion of requirements, and was able to generate context-dependent questions. Fine-tuning approaches were abandoned due to inferior early performance.

Conclusion: LLMREI demonstrates potential as an automated requirements elicitation tool that can operate at a similar error rate to humans, handle substantial requirements extraction, and adapt its questions effectively. The most significant impact is anticipated for scenarios involving interviews with large numbers of stakeholders, enhancing scalability and efficiency.

Abstract: Requirements elicitation interviews are crucial for gathering system
requirements but heavily depend on skilled analysts, making them
resource-intensive, susceptible to human biases, and prone to miscommunication.
Recent advancements in Large Language Models present new opportunities for
automating parts of this process. This study introduces LLMREI, a chat bot
designed to conduct requirements elicitation interviews with minimal human
intervention, aiming to reduce common interviewer errors and improve the
scalability of requirements elicitation. We explored two main approaches,
zero-shot prompting and least-to-most prompting, to optimize LLMREI for
requirements elicitation and evaluated its performance in 33 simulated
stakeholder interviews. A third approach, fine-tuning, was initially considered
but abandoned due to poor performance in preliminary trials. Our study assesses
the chat bot's effectiveness in three key areas: minimizing common interview
errors, extracting relevant requirements, and adapting its questioning based on
interview context and user responses. Our findings indicate that LLMREI makes a
similar number of errors compared to human interviewers, is capable of
extracting a large portion of requirements, and demonstrates a notable ability
to generate highly context-dependent questions. We envision the greatest
benefit of LLMREI in automating interviews with a large number of stakeholders.

</details>


### [11] [Human-Machine Collaboration and Ethical Considerations in Adaptive Cyber-Physical Systems](https://arxiv.org/abs/2507.02578)
*Zoe Pfister*

Main category: cs.SE

TL;DR: This paper tackles the challenges of merging human-machine teams into adaptive cyber-physical systems by innovating on feedback loop integration and establishing strong ethics and privacy frameworks from the outset of system development.


<details>
  <summary>Details</summary>
Motivation: Adaptive Cyber-Physical Systems (CPS) are increasingly integrating human-machine collaboration, but achieving seamless teamwork (Human-Machine Teaming, HMT) is challenging due to operational differences between humans and machines and privacy concerns regarding monitoring human behavior.

Method: The research proposes novel methods and processes to integrate HMT into adaptive CPS by focusing on principles of human-machine interaction within adaptive feedback loops, such as MAPE-K. Additionally, it develops frameworks to integrate, verify, and validate ethics and human values across the entire system lifecycle, beginning with requirements engineering.

Result: The research outcomes include new integration processes for HMT in adaptive CPS and comprehensive frameworks for upholding human values and privacy throughout system development and operation.

Conclusion: Successfully addressing seamless integration of HMT into adaptive CPS requires both advanced human-machine interaction techniques for feedback loop integration and ethical frameworks ensuring human value alignment, starting from early design stages.

Abstract: Adaptive Cyber-Physical Systems (CPS) are systems that integrate both
physical and computational capabilities, which can adjust in response to
changing parameters. Furthermore, they increasingly incorporate human-machine
collaboration, allowing them to benefit from the individual strengths of humans
and machines. Human-Machine Teaming (HMT) represents the most advanced paradigm
of human-machine collaboration, envisioning seamless teamwork between humans
and machines. However, achieving effective and seamless HMT in adaptive CPS is
challenging. While adaptive CPS already benefit from feedback loops such as
MAPE-K, there is still a gap in integrating humans into these feedback loops
due to different operational cadences of humans and machines. Further, HMT
requires constant monitoring of human operators, collecting potentially
sensitive information about their actions and behavior. Respecting the privacy
and human values of the actors of the CPS is crucial for the success of
human-machine teams. This research addresses these challenges by: (1)
developing novel methods and processes for integrating HMT into adaptive CPS,
focusing on human-machine interaction principles and their incorporation into
adaptive feedback loops found in CPS, and (2) creating frameworks for
integrating, verifying, and validating ethics and human values throughout the
system lifecycle, starting from requirements engineering.

</details>


### [12] [Do Research Software Engineers and Software Engineering Researchers Speak the Same Language?](https://arxiv.org/abs/2507.02665)
*Timo Kehrer,Robert Haines,Guido Juckeland,Shurui Zhou,David E. Bernholdt*

Main category: cs.SE

TL;DR: Researchers analyzed how Research Software Engineers (RSEs) and Software Engineering Researchers (SERs) use different terminologies, often causing communication issues. By mapping these differences, they found opportunities for mutual learning and laid groundwork for future collaborative efforts.


<details>
  <summary>Details</summary>
Motivation: There is anecdotal evidence that Research Software Engineers (RSEs) and Software Engineering Researchers (SERs) struggle to communicate effectively due to differences in terminologies for similar concepts. This has prompted the authors to investigate the extent and nature of these divergences to improve interdisciplinary understanding.

Method: The authors employed a systematic methodology to map and compare SE fundamentals from the Software Engineering Researcher (SER) community and how they are interpreted by the Research Software Engineer (RSE) community. They identified aligned concepts, knowledge gaps, and areas for adaptation. This process involved terminology mapping and sets the stage for future crowd-sourced validation and extension.

Result: Preliminary results indicate there are both opportunities for mutual learning and collaboration between the RSE and SER communities. The systematic mapping exposed aligned concepts and knowledge gaps, highlighting areas where adaptation is possible.

Conclusion: A systematic methodology for terminology mapping can highlight differences and commonalities between RSEs and SERs, improving understanding. These findings provide a foundation for further collaboration and can be extended and validated through crowd-sourcing approaches.

Abstract: Anecdotal evidence suggests that Research Software Engineers (RSEs) and
Software Engineering Researchers (SERs) often use different terminologies for
similar concepts, creating communication challenges. To better understand these
divergences, we have started investigating how SE fundamentals from the SER
community are interpreted within the RSE community, identifying aligned
concepts, knowledge gaps, and areas for potential adaptation. Our preliminary
findings reveal opportunities for mutual learning and collaboration, and our
systematic methodology for terminology mapping provides a foundation for a
crowd-sourced extension and validation in the future.

</details>


### [13] [RLHGNN: Reinforcement Learning-driven Heterogeneous Graph Neural Network for Next Activity Prediction in Business Processes](https://arxiv.org/abs/2507.02690)
*Jiaxing Wang,Yifeng Yu,Jiahan Song,Bin Cao,Jing Fan,Ji Zhang*

Main category: cs.SE

TL;DR: RLHGNN adapts graph structures using reinforcement learning to accurately model and predict the next activity in business processes, outperforming other methods with fast, real-time predictions.


<details>
  <summary>Details</summary>
Motivation: Sequence-based methods for next activity prediction struggle with non-sequential relationships in complex business processes, while existing graph-based methods are limited by homogeneous and static structures. There's a need for adaptive, expressive models that can deal with diverse process complexities and relations.

Method: The authors propose RLHGNN, which transforms event logs into heterogeneous process graphs with three edge types and uses flexible graph structures tailored to process complexity. A reinforcement learning approach (Markov Decision Process) is used to find the optimal graph structure per process instance, and heterogeneous graph convolution with relation-specific aggregation is employed for prediction.

Result: RLHGNN achieves superior predictive performance on six real-world datasets compared to existing methods, with the added advantage of very low prediction latency (about 1 ms), making it well-suited for real-time applications.

Conclusion: RLHGNN is an effective and efficient solution for next activity prediction in service-oriented architectures, outperforming state-of-the-art methods and supporting real-time process monitoring with low inference latency.

Abstract: Next activity prediction represents a fundamental challenge for optimizing
business processes in service-oriented architectures such as microservices
environments, distributed enterprise systems, and cloud-native platforms, which
enables proactive resource allocation and dynamic service composition. Despite
the prevalence of sequence-based methods, these approaches fail to capture
non-sequential relationships that arise from parallel executions and
conditional dependencies. Even though graph-based approaches address structural
preservation, they suffer from homogeneous representations and static
structures that apply uniform modeling strategies regardless of individual
process complexity characteristics. To address these limitations, we introduce
RLHGNN, a novel framework that transforms event logs into heterogeneous process
graphs with three distinct edge types grounded in established process mining
theory. Our approach creates four flexible graph structures by selectively
combining these edges to accommodate different process complexities, and
employs reinforcement learning formulated as a Markov Decision Process to
automatically determine the optimal graph structure for each specific process
instance. RLHGNN then applies heterogeneous graph convolution with
relation-specific aggregation strategies to effectively predict the next
activity. This adaptive methodology enables precise modeling of both sequential
and non-sequential relationships in service interactions. Comprehensive
evaluation on six real-world datasets demonstrates that RLHGNN consistently
outperforms state-of-the-art approaches. Furthermore, it maintains an inference
latency of approximately 1 ms per prediction, representing a highly practical
solution suitable for real-time business process monitoring applications. The
source code is available at https://github.com/Joker3993/RLHGNN.

</details>


### [14] [Sustainability Flags for the Identification of Sustainability Posts in Q&A Platforms](https://arxiv.org/abs/2507.02695)
*Sahar Ahmadisakha,Lech Bialek,Mohamed Soliman,Vasilios Andrikopoulos*

Main category: cs.SE

TL;DR: The paper introduces 'sustainability flags' as practical tools to help identify sustainability topics in cloud architecture discussions, showing they improve clarity and performance over traditional definition-based methods.


<details>
  <summary>Details</summary>
Motivation: Sustainability in software systems, especially with the rise of cloud computing, is increasingly important. However, it's difficult to recognize sustainability concepts in software architecture discussions due to a lack of clear guidelines.

Method: The authors propose the notion of 'sustainability flags', which are pointers that help identify relevant sustainability topics in discussions. These flags were developed through thematic analysis of best practices from cloud providers and then evaluated in a controlled experiment for their effectiveness in identifying sustainability-related content in cloud architecture posts.

Result: The preliminary results show that sustainability flags lead to fewer posts being classified as sustainability-related compared to control groups, but do so with higher certainty and significantly better performance. Users also found the flags more useful and understandable than simply relying on general definitions.

Conclusion: Sustainability flags provide a more effective, clear, and user-friendly way to identify sustainability-related architectural discussions in cloud environments compared to traditional definition-based approaches.

Abstract: In recent years, sustainability in software systems has gained significant
attention, especially with the rise of cloud computing and the shift towards
cloud-based architectures. This shift has intensified the need to identify
sustainability in architectural discussions to take informed architectural
decisions. One source to see these decisions is in online Q&A forums among
practitioners' discussions. However, recognizing sustainability concepts within
software practitioners' discussions remains challenging due to the lack of
clear and distinct guidelines for this task. To address this issue, we
introduce the notion of sustainability flags as pointers in relevant
discussions, developed through thematic analysis of multiple sustainability
best practices from cloud providers. This study further evaluates the
effectiveness of these flags in identifying sustainability within cloud
architecture posts, using a controlled experiment. Preliminary results suggest
that the use of flags results in classifying fewer posts as
sustainability-related compared to a control group, with moderately higher
certainty and significantly improved performance. Moreover, sustainability
flags are perceived as more useful and understandable than relying solely on
definitions for identifying sustainability.

</details>


### [15] [Legal Requirements Translation from Law](https://arxiv.org/abs/2507.02846)
*Anmol Singhal,Travis Breaux*

Main category: cs.SE

TL;DR: This paper presents an automated approach for encoding legal text as executable Python code, using textual entailment and in-context learning. It outperforms previous methods, reducing manual effort and improving adaptability to new regulations, with strong evaluation results on U.S. data breach laws.


<details>
  <summary>Details</summary>
Motivation: Small organizations and startups often lack legal expertise, making compliance with legal regulations challenging. Extracting legal requirements from complex legal text is resource-intensive and prior automated methods have notable limitations, such as poor generalization and not modeling interrelationships among metadata attributes.

Method: The paper proposes an automated approach using textual entailment and in-context learning to generate canonical representations of legal text as Python code. This uses a manually designed Python class structure as a domain-specific metamodel, capturing structure, semantics, and interrelationships of legal metadata, reducing the need for manual labeling of data.

Result: The approach was evaluated on 13 U.S. state data breach notification laws and achieved approximately 89.4% passing test cases, with precision of 82.2 and recall of 88.7.

Conclusion: Automatically generating executable, structured representations of legal text can improve legal compliance for software systems, especially for organizations with limited legal resources. The approach reduces manual effort and generalizes better to new legislation compared to previous methods.

Abstract: Software systems must comply with legal regulations, which is a
resource-intensive task, particularly for small organizations and startups
lacking dedicated legal expertise. Extracting metadata from regulations to
elicit legal requirements for software is a critical step to ensure compliance.
However, it is a cumbersome task due to the length and complex nature of legal
text. Although prior work has pursued automated methods for extracting
structural and semantic metadata from legal text, key limitations remain: they
do not consider the interplay and interrelationships among attributes
associated with these metadata types, and they rely on manual labeling or
heuristic-driven machine learning, which does not generalize well to new
documents. In this paper, we introduce an approach based on textual entailment
and in-context learning for automatically generating a canonical representation
of legal text, encodable and executable as Python code. Our representation is
instantiated from a manually designed Python class structure that serves as a
domain-specific metamodel, capturing both structural and semantic legal
metadata and their interrelationships. This design choice reduces the need for
large, manually labeled datasets and enhances applicability to unseen
legislation. We evaluate our approach on 13 U.S. state data breach notification
laws, demonstrating that our generated representations pass approximately 89.4%
of test cases and achieve a precision and recall of 82.2 and 88.7,
respectively.

</details>


### [16] [Requirements Elicitation Follow-Up Question Generation](https://arxiv.org/abs/2507.02858)
*Yuchen Shen,Anmol Singhal,Travis Breaux*

Main category: cs.SE

TL;DR: Using GPT-4o, the study shows that AI-generated follow-up questions are as effective as, and sometimes superior to, human-made ones in requirements interviews, especially when guided by common mistake patterns. This suggests LLMs can significantly aid interviewers during elicitation sessions.


<details>
  <summary>Details</summary>
Motivation: Interviewers, especially those unfamiliar with a domain, face challenges such as cognitive overload and information processing limitations when formulating real-time questions during software requirements elicitation. There is a need for tools to help interviewers generate effective follow-up questions and improve the overall interview process.

Method: The study investigates the use of GPT-4o, a large language model, to automatically generate follow-up interview questions during requirements elicitation. The methodology includes building on a framework of common interviewer mistake types and developing methods to generate questions based on interviewee responses. Two controlled experiments were conducted: one comparing LLM-generated and human-authored questions with minimal guidance, and another evaluating LLM-generated questions guided by interviewer mistake types.

Result: LLM-generated questions were found to be on par with human-authored questions in terms of clarity, relevancy, and informativeness in both experiments. When guided by interviewer mistake types, LLM-generated questions outperformed human-authored ones.

Conclusion: LLMs have the potential to assist interviewers in real-time by generating high-quality follow-up questions, thereby improving the effectiveness of requirements elicitation interviews, especially when leveraging knowledge of common interviewer mistakes.

Abstract: Interviews are a widely used technique in eliciting requirements to gather
stakeholder needs, preferences, and expectations for a software system.
Effective interviewing requires skilled interviewers to formulate appropriate
interview questions in real time while facing multiple challenges, including
lack of familiarity with the domain, excessive cognitive load, and information
overload that hinders how humans process stakeholders' speech. Recently, large
language models (LLMs) have exhibited state-of-the-art performance in multiple
natural language processing tasks, including text summarization and entailment.
To support interviewers, we investigate the application of GPT-4o to generate
follow-up interview questions during requirements elicitation by building on a
framework of common interviewer mistake types. In addition, we describe methods
to generate questions based on interviewee speech. We report a controlled
experiment to evaluate LLM-generated and human-authored questions with minimal
guidance, and a second controlled experiment to evaluate the LLM-generated
questions when generation is guided by interviewer mistake types. Our findings
demonstrate that, for both experiments, the LLM-generated questions are no
worse than the human-authored questions with respect to clarity, relevancy, and
informativeness. In addition, LLM-generated questions outperform human-authored
questions when guided by common mistakes types. This highlights the potential
of using LLMs to help interviewers improve the quality and ease of requirements
elicitation interviews in real time.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [17] [DecoRTL: A Run-time Decoding Framework for RTL Code Generation with LLMs](https://arxiv.org/abs/2507.02226)
*Mohammad Akyash,Kimia Azar,Hadi Kamali*

Main category: cs.PL

TL;DR: Standard LLM decoding methods fail for RTL code because they don't account for structural/semantic needs. DecoRTL adapts decoding with syntax-aware, contrastive sampling and temperature adjustment, improving code validity and correctness on benchmarks with little overhead.


<details>
  <summary>Details</summary>
Motivation: Recent advances in large language models (LLMs) have shown potential for automating register transfer level (RTL) code generation, but conventional decoding strategiesâ€”crafted for natural languageâ€”struggle with RTL's unique structural and semantic constraints, resulting in flawed code outputs.

Method: The paper first empirically analyzes token-level entropy in LLM-generated RTL to pinpoint sources of decoding failures, identifying areas of structural ambiguity and semantic complexity. Based on these insights, the authors propose DecoRTL: a novel inference-time decoding strategy featuring (i) self-consistency sampling to generate/re-rank candidates for correctness and diversity, and (ii) syntax-aware temperature adjustment, lowering temperature for syntax-critical tokens and raising it for exploratory regions, with no extra model fine-tuning.

Result: DecoRTL significantly improves syntactic validity, functional correctness, and diversity of generated RTL code compared to standard decoding, with negligible performance overhead, as demonstrated on multiple LLMs using the VerilogEval benchmark.

Conclusion: DecoRTL effectively addresses the disparity between LLM decoding strategies for natural language and the specific needs of RTL code generation, yielding more correct and diverse output without slowing inference or requiring model changes.

Abstract: As one of their many applications, large language models (LLMs) have recently
shown promise in automating register transfer level (RTL) code generation.
However, conventional LLM decoding strategies, originally designed for natural
language, often fail to meet the structural and semantic demands of RTL,
leading to hallucinated, repetitive, or invalid code outputs. In this paper, we
first investigate the root causes of these decoding failures through an
empirical analysis of token-level entropy during RTL generation. Our findings
reveal that LLMs exhibit low confidence in regions of structural ambiguity or
semantic complexity, showing that standard decoding strategies fail to
differentiate between regions requiring determinism (syntax-critical regions)
and those that benefit from creative exploratory variability (design-critical
regions). Then, to overcome this, we introduce DecoRTL, a novel run-time
decoding strategy, that is both syntax-aware and contrastive for RTL code
generation. DecoRTL integrates two complementary components: (i)
self-consistency sampling, which generates multiple candidates and re-ranks
them based on token-level agreement to promote correctness while maintaining
diversity; and (ii) syntax-aware temperature adaptation, which classifies
tokens by their syntactical and functional roles and adjusts the sampling
temperature accordingly, enforcing low temperature for syntax-critical tokens
and higher temperature for exploratory ones. Our approach operates entirely at
inference time without requiring any additional model fine-tuning. Through
evaluations on multiple open-source LLMs using the VerilogEval benchmark, we
demonstrate significant improvements in syntactic validity, functional
correctness, and output diversity, while the execution overhead (performance
overhead) is imperceptible.

</details>

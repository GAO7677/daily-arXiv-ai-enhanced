<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 12]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Automated File-Level Logging Generation for Machine Learning Applications using LLMs: A Case Study using GPT-4o Mini](https://arxiv.org/abs/2508.04820)
*Mayra Sofia Ruiz Rodriguez,SayedHassan Khatoonabadi,Emad Shihab*

Main category: cs.SE

TL;DR: GPT-4o can generate log statements for complete ML project files and often matches human log placements, but it tends to overlog and doesn’t always align with project conventions, limiting its current practical utility.


<details>
  <summary>Details</summary>
Motivation: Logging is vital for monitoring and debugging software, especially in ML applications where robust logs can ensure reliability. With the rise of LLMs like GPT-4o, researchers want to assess their ability to generate meaningful log statements, particularly at the file level—a less explored area in prior work.

Method: The study collected 171 machine learning repositories comprising 4,073 Python files containing log statements. Original logs were removed, and the GPT-4o mini LLM was prompted to generate log statements for these files. The evaluation compared LLM-generated logs to human-written ones in terms of position, log level, variables, and text quality. A manual analysis of a representative sample was also performed to glean common patterns and challenges.

Result: GPT-4o matched human log positioning in 63.91% of cases but had a high overlogging rate of 82.66%. Manual analysis highlighted specific challenges, such as a tendency to overlog at function boundaries, struggles with logging inside large blocks, and misalignments with project-specific conventions.

Conclusion: While GPT-4o demonstrates promise in generating file-level log statements, its overlogging and alignment issues must be solved before it can be deployed in practical scenarios.

Abstract: Logging is essential in software development, helping developers monitor
system behavior and aiding in debugging applications. Given the ability of
large language models (LLMs) to generate natural language and code, researchers
are exploring their potential to generate log statements. However, prior work
focuses on evaluating logs introduced in code functions, leaving file-level log
generation underexplored -- especially in machine learning (ML) applications,
where comprehensive logging can enhance reliability. In this study, we evaluate
the capacity of GPT-4o mini as a case study to generate log statements for ML
projects at file level. We gathered a set of 171 ML repositories containing
4,073 Python files with at least one log statement. We identified and removed
the original logs from the files, prompted the LLM to generate logs for them,
and evaluated both the position of the logs and log level, variables, and text
quality of the generated logs compared to human-written logs. In addition, we
manually analyzed a representative sample of generated logs to identify common
patterns and challenges. We find that the LLM introduces logs in the same place
as humans in 63.91% of cases, but at the cost of a high overlogging rate of
82.66%. Furthermore, our manual analysis reveals challenges for file-level
logging, which shows overlogging at the beginning or end of a function,
difficulty logging within large code blocks, and misalignment with
project-specific logging conventions. While the LLM shows promise for
generating logs for complete files, these limitations remain to be addressed
for practical implementation.

</details>


### [2] [Automated Bug Frame Retrieval from Gameplay Videos Using Vision-Language Models](https://arxiv.org/abs/2508.04895)
*Wentao Lu,Alexander Senchenko,Abram Hindle,Cor-Paul Bezemer*

Main category: cs.SE

TL;DR: The paper presents a vision-language-based automated pipeline that summarizes bug-report gameplay videos into single, highly relevant frames, greatly reducing manual review time and improving triage efficiency for game QA teams.


<details>
  <summary>Details</summary>
Motivation: Game studios must process thousands of bug reports with attached gameplay videos, but manual review of videos is slow, labor-intensive, and does not scale well.

Method: The authors developed an automated pipeline that first uses FFmpeg to extract keyframes (about 1.90% of original frames). Then, a vision-language model (GPT-4o) ranks these keyframes based on their similarity to the textual bug description, selecting the most representative frame.

Result: The pipeline successfully identifies informative frames, capturing bug moments in 98.79% of cases, with an overall F1 score of 0.79 and accuracy of 0.89 on real-world developer-submitted bug reports. It performs best in Lighting & Shadow, Physics & Collision, and UI & HUD bug categories, and less well in Animation & VFX

Conclusion: The approach enables QA teams and developers to replace manual video review with instant, informative images, significantly reducing manual effort and speeding up the bug triage and regression check process in the game industry.

Abstract: Modern game studios deliver new builds and patches at a rapid pace,
generating thousands of bug reports, many of which embed gameplay videos. To
verify and triage these bug reports, developers must watch the submitted
videos. This manual review is labour-intensive, slow, and hard to scale. In
this paper, we introduce an automated pipeline that reduces each video to a
single frame that best matches the reported bug description, giving developers
instant visual evidence that pinpoints the bug.
  Our pipeline begins with FFmpeg for keyframe extraction, reducing each video
to a median of just 1.90% of its original frames while still capturing bug
moments in 98.79 of cases. These keyframes are then evaluated by a
vision--language model (GPT-4o), which ranks them based on how well they match
the textual bug description and selects the most representative frame. We
evaluated this approach using real-world developer-submitted gameplay videos
and JIRA bug reports from a popular First-Person Shooter (FPS) game. The
pipeline achieves an overall F1 score of 0.79 and Accuracy of 0.89 for the
top-1 retrieved frame. Performance is highest for the Lighting & Shadow (F1 =
0.94), Physics & Collision (0.86), and UI & HUD (0.83) bug categories, and
lowest for Animation & VFX (0.51).
  By replacing video viewing with an immediately informative image, our
approach dramatically reduces manual effort and speeds up triage and regression
checks, offering practical benefits to quality assurance (QA) teams and
developers across the game industry.

</details>


### [3] [Charting Uncertain Waters: A Socio-Technical Framework for Navigating GenAI's Impact on Open Source Communities](https://arxiv.org/abs/2508.04921)
*Zixuan Feng,Reed Milewicz,Emerson Murphy-Hill,Tyler Menezes,Alexander Serebrenik,Igor Steinmacher,Anita Sarma*

Main category: cs.SE

TL;DR: The paper explores how Generative AI disrupts Open Source Software communities and uses a socio-technical framework to highlight risks and opportunities, encouraging proactive adaptation in development, documentation, engagement, and governance.


<details>
  <summary>Details</summary>
Motivation: The paper is motivated by the uncertainty and challenges introduced by Generative AI (GenAI) in Open Source Software (OSS) communities. The emergence of GenAI risks overwhelming these communities and threatening their collaborative foundations due to increased complexity and ambiguity.

Method: The authors use a scenario-driven, conceptual exploration. They employ a socio-technical framework inspired by McLuhan's Tetrad to analyze risks and opportunities across software practices, documentation, community engagement, and governance.

Result: The use of this framework enables the identification of both risks and opportunities for OSS communities in the face of GenAI disruption, offering a proactive approach to managing change in practice, documentation, engagement, and governance.

Conclusion: OSS leaders and researchers can use the insights from this analysis to shape their communities proactively instead of just responding passively to AI-driven changes.

Abstract: Open Source Software communities face a wave of uncertainty as Generative AI
rapidly transforms how software is created, maintained, and governed. Without
clear frameworks, communities risk being overwhelmed by the complexity and
ambiguity introduced by GenAI, threatening the collaborative ethos that
underpins OSS. We conduct a scenario-driven, conceptual exploration using a
socio-technical framework inspired by McLuhan's Tetrad to surface both risks
and opportunities for community resilience amid GenAI-driven disruption of OSS
development across four domains: software practices, documentation, community
engagement, and governance. By adopting this lens, OSS leaders and researchers
can proactively shape the future of their ecosystems, rather than simply
reacting to technological upheaval.

</details>


### [4] [Taxonomy of Faults in Attention-Based Neural Networks](https://arxiv.org/abs/2508.04925)
*Sigma Jahan,Saurabh Singh Rajput,Tushar Sharma,Mohammad Masudur Rahman*

Main category: cs.SE

TL;DR: This paper systematically analyzes real-world failures in attention-based neural networks, creating a novel taxonomy and diagnostic heuristics tailored to these faults. It offers practitioners crucial frameworks for identifying and resolving unique attention-related errors.


<details>
  <summary>Details</summary>
Motivation: Modern neural systems rely on attention mechanisms, which have introduced new fault types not captured in traditional taxonomies. Practitioners lack diagnostic frameworks specific to these mechanisms, especially given notable failures in widely-used AI systems.

Method: The authors conduct a systematic analysis of 555 real-world faults in attention-based neural networks, drawing data from 96 projects and ten frameworks. They classify these faults and develop a specific taxonomy.

Result: They identify seven new fault categories exclusive to attention architectures. Over half of the faults are attention-specific. They establish associations between fault symptoms and root causes and propose four evidence-based diagnostic heuristics that explain a third of such faults.

Conclusion: The paper fills a crucial gap by providing a comprehensive taxonomy and actionable diagnostics for faults in attention-based neural networks. This guidance enables better troubleshooting and reliability in modern AI systems.

Abstract: Attention mechanisms are at the core of modern neural architectures, powering
systems ranging from ChatGPT to autonomous vehicles and driving a major
economic impact. However, high-profile failures, such as ChatGPT's nonsensical
outputs or Google's suspension of Gemini's image generation due to attention
weight errors, highlight a critical gap: existing deep learning fault
taxonomies might not adequately capture the unique failures introduced by
attention mechanisms. This gap leaves practitioners without actionable
diagnostic guidance. To address this gap, we present the first comprehensive
empirical study of faults in attention-based neural networks (ABNNs). Our work
is based on a systematic analysis of 555 real-world faults collected from 96
projects across ten frameworks, including GitHub, Hugging Face, and Stack
Overflow. Through our analysis, we develop a novel taxonomy comprising seven
attention-specific fault categories, not captured by existing work. Our results
show that over half of the ABNN faults arise from mechanisms unique to
attention architectures. We further analyze the root causes and manifestations
of these faults through various symptoms. Finally, by analyzing symptom-root
cause associations, we identify four evidence-based diagnostic heuristics that
explain 33.0% of attention-specific faults, offering the first systematic
diagnostic guidance for attention-based models.

</details>


### [5] [Generative AI for Object-Oriented Programming: Writing the Right Code and Reasoning the Right Logic](https://arxiv.org/abs/2508.05005)
*Gang Xu,Airong Wang,Yushan Pan*

Main category: cs.SE

TL;DR: The paper explores how large language models (LLMs) can be integrated with Object-Oriented Programming (OOP) to improve learning, code writing, and overall programming workflow, outlines stakeholder perspectives, and proposes enhancements to current logical reasoning and coding practices.


<details>
  <summary>Details</summary>
Motivation: There is rapid growth in artificial intelligence research, especially in large language models (LLMs). Despite LLMs' wide application, their impact on Object-Oriented Programming (OOP) practices is not well understood. The paper seeks to investigate how LLMs might benefit OOP learning, code writing, and evaluation.

Method: The paper adopts a stakeholder-driven approach, exploring the perspectives of different participants in OOP tasks (e.g., programmers, trainers, and experienced developers). It identifies critical points in coding workflows where LLMs could bring value and suggests improvements for logical reasoning and code writing.

Result: The authors identify key stages in OOP workflows where integrating LLMs is beneficial. They also propose methods to enhance logical reasoning and code-writing effectiveness with LLMs, aiming to improve the programming experience.

Conclusion: LLMs have the potential to significantly enhance OOP-related activities. Addressing current knowledge gaps and strategically incorporating LLMs within coding workflows can lead to more effective learning and development in OOP.

Abstract: We find ourselves in the midst of an explosion in artificial intelligence
research, particularly with large language models (LLMs). These models have
diverse applications spanning finance, commonsense knowledge graphs, medicine,
and visual analysis. In the world of Object-Oriented Programming(OOP), a robust
body of knowledge and methods has been developed for managing complex tasks
through object-oriented thinking. However, the intersection of LLMs with OOP
remains an underexplored territory. Empirically, we currently possess limited
understanding of how LLMs can enhance the effectiveness of OOP learning and
code writing, as well as how we can evaluate such AI-powered tools. Our work
aims to address this gap by presenting a vision from the perspectives of key
stakeholders involved in an OOP task: programmers, mariners, and experienced
programmers. We identify critical junctures within typical coding workflows
where the integration of LLMs can offer significant benefits. Furthermore, we
propose ways to augment existing logical reasoning and code writing, ultimately
enhancing the programming experience.

</details>


### [6] [An ML-based Approach to Predicting Software Change Dependencies: Insights from an Empirical Study on OpenStack](https://arxiv.org/abs/2508.05034)
*Arabat,Ali,Sayagh,Mohammed,Hassine,Jameleddine*

Main category: cs.SE

TL;DR: In complex software systems like OpenStack, over half of change dependencies are detected late, often during code review. The authors studied this problem and proposed two machine learning models that can proactively predict and identify such dependencies. Their models demonstrated strong performance, suggesting that semi-automated dependency management could significantly reduce inefficiencies in software development workflows.


<details>
  <summary>Details</summary>
Motivation: As software systems grow in complexity, managing dependencies among code changes becomes crucial. Dependencies influence CI/CD process stability, feature deployment, and team collaboration, yet are challenging to detect, especially in large, multi-component projects. The study is motivated by the need to address inefficiencies and delays in identifying these interdependencies.

Method: The authors conducted a preliminary study on dependency management within OpenStack, analyzing a decade's worth of software changes to understand the prevalence and detection timeline of dependencies. They then designed a semi-automated solution comprising two machine learning models: one to predict the likelihood of dependencies and another to identify exact dependency pairs.

Result: The study found that a large proportion (51.08%) of dependencies are discovered during code review, not at the time of change creation, with significant delays in detection. Their proposed ML models for proactive dependency identification showed strong performance: Model 1 achieved an AUC of 79.33% (Brier score 0.11), and Model 2 achieved an AUC of 91.89% (Brier score 0.014), with the second model showing good top-k recall and some room for improvement in precision.

Conclusion: The paper concludes that a substantial percentage of dependencies in a large software project are detected late, resulting in wasted developer effort and process delays. Semi-automated ML-based approaches can substantially improve the proactive identification of dependencies, improving efficiency in managing changes across complex systems.

Abstract: As software systems grow in complexity, accurately identifying and managing
dependencies among changes becomes increasingly critical. For instance, a
change that leverages a function must depend on the change that introduces it.
Establishing such dependencies allows CI/CD pipelines to build and orchestrate
changes effectively, preventing build failures and incomplete feature
deployments. In modern software systems, dependencies often span multiple
components across teams, creating challenges for development and deployment.
They serve various purposes, from enabling new features to managing
configurations, and can even involve traditionally independent changes like
documentation updates. To address these challenges, we conducted a preliminary
study on dependency management in OpenStack, a large-scale software system. Our
study revealed that a substantial portion of software changes in OpenStack over
the past 10 years are interdependent. Surprisingly, 51.08% of these
dependencies are identified during the code review phase-after a median delay
of 5.06 hours-rather than at the time of change creation. Developers often
spend a median of 57.12 hours identifying dependencies, searching among a
median of 463 other changes. To help developers proactively identify
dependencies, we propose a semi-automated approach that leverages two ML
models. The first model predicts the likelihood of dependencies among changes,
while the second identifies the exact pairs of dependent changes. Our proposed
models demonstrate strong performance, achieving average AUC scores of 79.33%
and 91.89%, and Brier scores of 0.11 and 0.014, respectively. Indeed, the
second model has a good top-k recall across all types of pairs, while the top-k
precision has room for improvement.

</details>


### [7] [LadyBug: A GitHub Bot for UI-Enhanced Bug Localization in Mobile Apps](https://arxiv.org/abs/2508.05085)
*Junayed Mahmud,James Chen,Terry Achille,Camilo Alvarez-Velez,Darren Dean Bansil,Patrick Ijieh,Samar Karanch,Nadeeshan De Silva,Oscar Chaparro,Andrian Marcus,Kevin Moran*

Main category: cs.SE

TL;DR: LadyBug is an open-source GitHub bot that uses both bug report text and UI traces to automatically localize bugs in Android apps, significantly outperforming traditional methods.


<details>
  <summary>Details</summary>
Motivation: Bug localization in Android apps is challenging, with traditional text-retrieval methods having limited accuracy. There is a need for effective and automated tools to help developers identify buggy files using both textual and UI interaction data.

Method: The authors designed LadyBug, a GitHub bot that collects bug reproduction traces and descriptions from issue trackers. LadyBug combines UI interaction data from these traces with traditional text retrieval to rank files likely containing a new bug. The tool was evaluated empirically using the RedWing benchmark, involving automated tests on 80 documented bugs from 39 Android apps.

Result: LadyBug significantly outperformed standard text-retrieval baselines in bug localization accuracy. Including UI information resulted in a substantial improvement in the ability to localize bugs. The tool is open source and publicly available.

Conclusion: Integrating UI interaction information with text retrieval enables more accurate and effective bug localization in Android apps. LadyBug demonstrates this synergy, outperforming traditional approaches and providing a practical, automated solution for developers.

Abstract: This paper introduces LadyBug, a GitHub bot that automatically localizes bugs
for Android apps by combining UI interaction information with text retrieval.
LadyBug connects to an Android app's GitHub repository, and is triggered when a
bug is reported in the corresponding issue tracker. Developers can then record
a reproduction trace for the bug on a device or emulator and upload the trace
to LadyBug via the GitHub issue tracker. This enables LadyBug to utilize both
the text from the original bug description, and UI information from the
reproduction trace to accurately retrieve a ranked list of files from the
project that most likely contain the reported bug.
  We empirically evaluated LadyBug using an automated testing pipeline and
benchmark called RedWing that contains 80 fully-localized and reproducible bug
reports from 39 Android apps. Our results illustrate that LadyBug outperforms
text-retrieval-based baselines and that the utilization of UI information leads
to a substantial increase in localization accuracy. LadyBug is an open-source
tool, available at https://github.com/LadyBugML/ladybug.
  A video showing the capabilities of Ladybug can be viewed here:
https://youtu.be/hI3tzbRK0Cw

</details>


### [8] [Posterior-GRPO: Rewarding Reasoning Processes in Code Generation](https://arxiv.org/abs/2508.05170)
*Lishui Fan,Yu Zhang,Mouxiang Chen,Zhongxin Liu*

Main category: cs.SE

TL;DR: The paper introduces a framework to improve reinforcement learning for code generation by rewarding high-quality reasoning processes and mitigating reward hacking. They provide new benchmarks, a robust reward training method, and a novel RL algorithm that aligns reasoning quality with successful outcomes—resulting in substantial performance gains over traditional outcome-based methods and matching state-of-the-art models.


<details>
  <summary>Details</summary>
Motivation: Current reinforcement learning (RL) methods for code generation with large language models (LLMs) focus mainly on outcome-based rewards (such as passing test cases), overlooking the quality of the intermediate reasoning process. Directly rewarding reasoning quality is promising but suffers from reward hacking, where models exploit the reward signal without improving actual outcomes.

Method: 1. Developed LCB-RB, a benchmark with preference pairs comparing superior and inferior reasoning processes. 2. Introduced Optimized-Degraded (OD-based) reward model training, which creates high-quality pairs by systematically optimizing and degrading reasoning paths across dimensions like factual accuracy, logical rigor, and coherence. 3. Proposed Posterior-GRPO (P-GRPO), an RL method that conditions process-based rewards on successful outcomes, reducing reward hacking and better aligning reasoning with code correctness.

Result: A 7B parameter reward model trained with OD-based method achieved state-of-the-art results on LCB-RB and generalized well to other benchmarks. The model trained with P-GRPO outperformed outcome-only baselines by 4.5% and matched GPT-4-Turbo performance on diverse code generation tasks. The approach also generalized to mathematical tasks.

Conclusion: Incorporating reasoning process quality into RL for code generation is effective and can be done robustly with the proposed framework. LCB-RB, OD-based reward training, and P-GRPO together mitigate reward hacking and significantly improve code generation performance, reaching results comparable to leading models like GPT-4-Turbo.

Abstract: Reinforcement learning (RL) has significantly advanced code generation for
large language models (LLMs). However, current paradigms rely on outcome-based
rewards from test cases, neglecting the quality of the intermediate reasoning
process. While supervising the reasoning process directly is a promising
direction, it is highly susceptible to reward hacking, where the policy model
learns to exploit the reasoning reward signal without improving final outcomes.
To address this, we introduce a unified framework that can effectively
incorporate the quality of the reasoning process during RL. First, to enable
reasoning evaluation, we develop LCB-RB, a benchmark comprising preference
pairs of superior and inferior reasoning processes. Second, to accurately score
reasoning quality, we introduce an Optimized-Degraded based (OD-based) method
for reward model training. This method generates high-quality preference pairs
by systematically optimizing and degrading initial reasoning paths along
curated dimensions of reasoning quality, such as factual accuracy, logical
rigor, and coherence. A 7B parameter reward model with this method achieves
state-of-the-art (SOTA) performance on LCB-RB and generalizes well to other
benchmarks. Finally, we introduce Posterior-GRPO (P-GRPO), a novel RL method
that conditions process-based rewards on task success. By selectively applying
rewards to the reasoning processes of only successful outcomes, P-GRPO
effectively mitigates reward hacking and aligns the model's internal reasoning
with final code correctness. A 7B parameter model with P-GRPO achieves superior
performance across diverse code generation tasks, outperforming outcome-only
baselines by 4.5%, achieving comparable performance to GPT-4-Turbo. We further
demonstrate the generalizability of our approach by extending it to
mathematical tasks. Our models, dataset, and code are publicly available.

</details>


### [9] [AI-assisted JSON Schema Creation and Mapping](https://arxiv.org/abs/2508.05192)
*Felix Neubauer,Jürgen Pleiss,Benjamin Uekermann*

Main category: cs.SE

TL;DR: This paper presents a hybrid approach using LLMs and deterministic techniques, integrated into an open-source tool, to enable easier data modeling and integration by letting non-experts create and map schemas via natural language, making structured data workflows more accessible.


<details>
  <summary>Details</summary>
Motivation: Many domains lack standardized data models, and creating these models is a difficult task for non-experts, hindering effective data integration and use.

Method: The paper proposes a hybrid method that leverages both large language models (LLMs) and deterministic techniques to allow users to create, modify, and map JSON Schemas using natural language inputs. This approach is implemented in the open-source tool MetaConfigurator, which also provides visual editing, validation, and code generation.

Result: Schema mappings can be created from diverse data sources (JSON, CSV, XML, YAML) using LLMs, while the reliability and scalability of mappings are maintained through deterministic execution. The approach’s effectiveness is shown in a chemistry application example.

Conclusion: Combining natural language interface with deterministic safeguards in MetaConfigurator makes structured data modeling and integration much more accessible to non-experts, helping to lower the entry barrier in various domains.

Abstract: Model-Driven Engineering (MDE) places models at the core of system and data
engineering processes. In the context of research data, these models are
typically expressed as schemas that define the structure and semantics of
datasets. However, many domains still lack standardized models, and creating
them remains a significant barrier, especially for non-experts. We present a
hybrid approach that combines large language models (LLMs) with deterministic
techniques to enable JSON Schema creation, modification, and schema mapping
based on natural language inputs by the user. These capabilities are integrated
into the open-source tool MetaConfigurator, which already provides visual model
editing, validation, code generation, and form generation from models. For data
integration, we generate schema mappings from heterogeneous JSON, CSV, XML, and
YAML data using LLMs, while ensuring scalability and reliability through
deterministic execution of generated mapping rules. The applicability of our
work is demonstrated in an application example in the field of chemistry. By
combining natural language interaction with deterministic safeguards, this work
significantly lowers the barrier to structured data modeling and data
integration for non-experts.

</details>


### [10] [STEPWISE-CODEX-Bench: Evaluating Complex Multi-Function Comprehension and Fine-Grained Execution Reasoning](https://arxiv.org/abs/2508.05193)
*Kaiwen Yan,Yuhang Chang,Zirui Guo,Yaling Mou,Jiang Ming,Jingwei Sun*

Main category: cs.SE

TL;DR: Current code benchmarks can't fully evaluate advanced LLMs' reasoning abilities. SX-Bench introduces a challenging benchmark focused on multi-function, step-wise reasoning tasks. Top models perform worse here than on older benchmarks, revealing limitations and providing a new tool for deeper assessment in code intelligence.


<details>
  <summary>Details</summary>
Motivation: Existing benchmarks for evaluating large language models (LLMs) on code intelligence are limited; they mostly measure functional correctness or assess reasoning in simple, single-function contexts. This results in saturated scores for advanced models, making it difficult to distinguish their true capabilities, especially in complex code reasoning.

Method: The paper introduces STEPWISE-CODEX-Bench (SX-Bench), a new benchmark for evaluating LLMs' understanding of complex multi-function code and fine-grained execution reasoning. SX-Bench uses tasks that require cooperation across multiple sub-functions and defines 'computation steps' as the main evaluation unit. Models must predict the number of computation steps, focusing on dynamic execution reasoning. The benchmark generation pipeline uses program synthesis, symbolic execution, and LLM-assisted validation.

Result: SX-Bench was tested on over 20 mainstream models, including 14 reasoning-focused LLMs. The results show that SX-Bench is much more discriminative: top models like OpenAI-O3 achieved 78.37% accuracy on difficult reasoning tasks—much lower than previous benchmarks where scores are nearly saturated. This demonstrates remaining bottlenecks for code reasoning in current LLMs.

Conclusion: SX-Bench enables systematic and fine-grained evaluation of LLMs' reasoning abilities in complex, multi-function code scenarios. It advances the state of code evaluation and uncovers performance gaps even in leading models, highlighting areas for further improvement.

Abstract: In recent years, large language models (LLMs) have made significant progress
in code intelligence, yet systematically evaluating their code understanding
and reasoning abilities remains challenging. Mainstream benchmarks such as
HumanEval and MBPP primarily assess functional correctness, while reasoning
benchmarks like CRUXEVAL are limited to single-function, low-complexity
scenarios. As a result, advanced models achieve nearly saturated scores,
limiting their discriminative power. To address this, we present
STEPWISE-CODEX-Bench (SX-Bench), a novel benchmark designed for complex
multi-function understanding and fine-grained execution reasoning. SX-Bench
features tasks involving collaboration among multiple sub-functions (e.g.,
chained calls, nested loops), shifting evaluation towards overall control and
data flow modeling. It defines "computation steps" as the minimal execution
unit and requires models to predict the total number of steps in reasoning
tasks, thereby assessing a model's in-depth understanding of dynamic execution
beyond simple I/O matching. Evaluation on over 20 mainstream models (including
14 reasoning-enhanced models) demonstrates that SX-Bench is highly
discriminative: even the state-of-the-art OpenAI-O3 achieves only 78.37 percent
accuracy on Hard-Reasoning tasks, much lower than its saturated scores on
previous benchmarks, thereby revealing bottlenecks in complex and fine-grained
reasoning. We also release an automated pipeline combining program synthesis,
symbolic execution, and LLM-aided validation for efficient benchmark generation
and quality assurance. SX-Bench advances code evaluation from "single-function
verification" to "multi-function dynamic reasoning," providing a key tool for
the in-depth assessment of advanced code intelligence models.

</details>


### [11] [EvoGraph: Hybrid Directed Graph Evolution toward Software 3.0](https://arxiv.org/abs/2508.05199)
*Igor Costa,Christopher Baran*

Main category: cs.SE

TL;DR: EvoGraph automates evolution of code, documentation, and processes using specialized small language models, fixing vulnerabilities and modernizing legacy systems with high accuracy and efficiency, showing promise for continuous, self-adapting software.


<details>
  <summary>Details</summary>
Motivation: Many software systems face challenges with legacy code modernization, vulnerability mitigation, and maintenance of documentation and processes. The paper is motivated by the need to automate and optimize system evolution using advanced AI techniques.

Method: The authors propose EvoGraph, a framework that models software artifacts as a typed directed graph. It applies mutation operators, which are guided by specialized small language models (SLMs), and uses multi-objective fitness functions to select improved versions. Experiments are conducted on benchmarks and legacy systems using EvoGraph and its variant evoGraph that utilize language-specific SLMs.

Result: On benchmarks, EvoGraph fixes 83% of security vulnerabilities, translates COBOL to Java with 93% verified functional equivalence, maintains documentation freshness within two minutes, reduces latency by 40%, and drops feature lead time sevenfold. The extension (evoGraph) achieves 82–96% semantic equivalence across legacy and modern languages, while reducing computational costs by 90% compared to large language models.

Conclusion: EvoGraph provides a feasible path toward automated and measurable software system evolution, effectively modernizing legacy code bases while reducing costs, improving performance, and maintaining control.

Abstract: We introduce **EvoGraph**, a framework that enables software systems to
evolve their own source code, build pipelines, documentation, and tickets.
EvoGraph represents every artefact in a typed directed graph, applies learned
mutation operators driven by specialized small language models (SLMs), and
selects survivors with a multi-objective fitness. On three benchmarks, EvoGraph
fixes 83% of known security vulnerabilities, translates COBOL to Java with 93%
functional equivalence (test verified), and maintains documentation freshness
within two minutes. Experiments show a 40% latency reduction and a sevenfold
drop in feature lead time compared with strong baselines. We extend our
approach to **evoGraph**, leveraging language-specific SLMs for modernizing
.NET, Lisp, CGI, ColdFusion, legacy Python, and C codebases, achieving 82-96%
semantic equivalence across languages while reducing computational costs by 90%
compared to large language models. EvoGraph's design responds to empirical
failure modes in legacy modernization, such as implicit contracts, performance
preservation, and integration evolution. Our results suggest a practical path
toward Software 3.0, where systems adapt continuously yet remain under
measurable control.

</details>


### [12] [A Conceptual Model and Methodology for Sustainability-aware, IoT-enhanced Business Processes](https://arxiv.org/abs/2508.05301)
*Victoria Torres Bosch,Ronny Seiger,Manuela Albert Albiol,Antoni Mestre Gascon,Pedro Jose Valderas Aranda*

Main category: cs.SE

TL;DR: This paper introduces a model and methodology for using IoT to boost business process sustainability in more than just the environmental dimension, showing practical applications in tourism and healthcare.


<details>
  <summary>Details</summary>
Motivation: Current sustainability research in BPM is mainly limited to environmental aspects, while real and lasting impact requires addressing broader sustainability dimensions. IoT offers new opportunities to enhance and measure sustainability in business processes.

Method: The paper proposes a conceptual model linking BPM, sustainability, and IoT, and presents a methodology for systematically analyzing and redesigning business processes to enhance sustainability using IoT. The methodology is demonstrated with examples from tourism and healthcare.

Result: A formalized model and methodology for integrating IoT into business processes to systematically identify and implement sustainability improvements were developed. The effectiveness of the approach was illustrated with case studies in tourism and healthcare.

Conclusion: A conceptual model and structured methodology can effectively analyze and improve the sustainability of business processes by leveraging IoT technologies, extending the sustainability focus beyond just environmental concerns.

Abstract: The real-time data collection and automation capabilities offered by the
Internet of Things (IoT) are revolutionizing and transforming Business
Processes (BPs) into IoT-enhanced BPs, showing high potential for improving
sustainability. Although already studied in Business Process Management (BPM),
sustainability research has primarily focused on environmental concerns.
However, achieving a holistic and lasting impact requires a systematic approach
to address sustainability beyond the environmental dimension. This work
proposes a conceptual model and a structured methodology with the goal of
analyzing the potential of IoT to measure and improve the sustainability of
BPs. The conceptual model formally represents key sustainability concepts,
linking BPM and IoT by highlighting how IoT devices support and contribute to
sustainability. The methodology guides the systematic analysis of existing BPs,
identifies opportunities, and implements sustainability-aware, IoT-enhanced
BPs. The approach is illustrated through a running example from the tourism
domain and a case study in healthcare.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [13] [Consistent Updates for Scalable Microservices](https://arxiv.org/abs/2508.04829)
*Devora Chait-Roth,Kedar S. Namjoshi,Thomas Wies*

Main category: cs.PL

TL;DR: This paper presents novel, semantic-aware algorithms for updating microservices without inconsistency or major inefficiency, proving that semantic properties are necessary for safe live updates and introducing a theoretical framework for guaranteed consistency.


<details>
  <summary>Details</summary>
Motivation: In scalable microservice architectures, updating service functionality without downtime or inconsistency is crucial. Typical approaches either cause inefficiency or risk inconsistency when current and new versions are active together (mixed mode).

Method: The paper introduces semantic-aware algorithms that use properties like commutativity to manage mixed mode updates. It provides a new theoretical framework for reasoning about consistency and formally establishes the correctness of these algorithms.

Result: The algorithms guarantee consistency during mixed mode updates, ensuring that service updates appear atomic to clients. The theory also proves that semantic-agnostic methods cannot avoid inconsistencies in such scenarios.

Conclusion: Semantic awareness is essential for safe, consistent updates in microservice architectures. The proposed framework and algorithms solve the problem of inconsistent mixed-mode updates without major inefficiency.

Abstract: Online services are commonly implemented with a scalable microservice
architecture, where isomorphic worker processes service client requests,
recording persistent state in a backend data store. To maintain service, any
modifications to the service functionality must be made on the fly -- i.e., as
the service continues to process client requests -- but doing so is
challenging. The central difficulty is that of avoiding potential
inconsistencies caused by ''mixed mode'' operation, where workers of current
and new versions are concurrently active and interact via the data store. Some
update methods avoid mixed mode altogether, but only at the cost of substantial
inefficiency -- by doubling resources (memory and compute), or by halving
throughput. The alternative is a so-called ''rolling'' update, which is
uncontrolled and runs the risk of serious service failures arising from
inconsistent mixed-mode behavior.
  In this paper, we present the first algorithms that guarantee consistency for
mixed mode updates. The algorithms rely on semantic properties of service
actions, such as commutativity. We show that semantic awareness is required, by
proving that any semantically oblivious, mixed-mode update method cannot avoid
inconsistencies. Ideally, it should appear to every client that a service
update takes effect atomically; this ensures that a client is not exposed to
inconsistent mixed-mode behavior. We introduce a framework that formalizes this
intuition and develop foundational theory for reasoning about the consistency
of mixed-mode updates, applying that theory to derive the new algorithms and
establish their correctness.

</details>

{"id": "2508.15109", "categories": ["cs.PL", "D.3.0; F.3.1"], "pdf": "https://arxiv.org/pdf/2508.15109", "abs": "https://arxiv.org/abs/2508.15109", "authors": ["Ziteng Wang", "Ruijie Fang", "Linus Zheng", "Dixin Tang", "Isil Dillig"], "title": "Homomorphism Calculus for User-Defined Aggregations", "comment": null, "summary": "Data processing frameworks like Apache Spark and Flink provide built-in\nsupport for user-defined aggregation functions (UDAFs), enabling the\nintegration of domain-specific logic. However, for these frameworks to support\n\\emph{efficient} UDAF execution, the function needs to satisfy a\n\\emph{homomorphism property}, which ensures that partial results from\nindependent computations can be merged correctly. Motivated by this problem,\nthis paper introduces a novel \\emph{homomorphism calculus} that can both verify\nand refute whether a UDAF is a dataframe homomorphism. If so, our calculus also\nenables the construction of a corresponding merge operator which can be used\nfor incremental computation and parallel execution. We have implemented an\nalgorithm based on our proposed calculus and evaluate it on real-world UDAFs,\ndemonstrating that our approach significantly outperforms two leading\nsynthesizers.", "AI": {"tldr": "This paper proposes and evaluates a new calculus to verify and synthesize efficient aggregation functions in data frameworks, improving over prior state-of-the-art methods.", "motivation": "User-defined aggregation functions (UDAFs) are important for integrating domain-specific logic in data processing frameworks like Apache Spark and Flink, but efficient execution requires UDAFs to fulfill a homomorphism property\u2014which can be challenging to verify.", "method": "The paper introduces a novel homomorphism calculus to automatically verify or refute whether a UDAF is a dataframe homomorphism. The calculus can also construct a necessary merge operator for incremental and parallel computation if the property is satisfied. An algorithm was implemented based on this calculus and evaluated on real-world UDAFs.", "result": "The proposed approach enables both verification and synthesis of merge operators for UDAFs. Experimental evaluation on real-world scenarios shows that the new method significantly outperforms two leading existing synthesizers.", "conclusion": "The homomorphism calculus provides an effective, automated way to support efficient UDAF execution in modern data frameworks by ensuring the required homomorphism property and constructing necessary operators. The approach improves verification and synthesis effectiveness compared to existing methods."}}
{"id": "2508.15137", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15137", "abs": "https://arxiv.org/abs/2508.15137", "authors": ["Ruijie Fang", "Zachary Kincaid", "Thomas Reps"], "title": "Software Model Checking via Summary-Guided Search (Extended Version)", "comment": "Preliminary manuscript of extended version of paper that will appear\n  in OOPSLA 2025. 36 pages", "summary": "In this work, we describe a new software model-checking algorithm called GPS.\nGPS treats the task of model checking a program as a directed search of the\nprogram states, guided by a compositional, summary-based static analysis. The\nsummaries produced by static analysis are used both to prune away infeasible\npaths and to drive test generation to reach new, unexplored program states. GPS\ncan find both proofs of safety and counter-examples to safety (i.e., inputs\nthat trigger bugs), and features a novel two-layered search strategy that\nrenders it particularly efficient at finding bugs in programs featuring long,\ninput-dependent error paths. To make GPS refutationally complete (in the sense\nthat it will find an error if one exists, if it is allotted enough time), we\nintroduce an instrumentation technique and show that it helps GPS achieve\nrefutation-completeness without sacrificing overall performance. We benchmarked\nGPS on a suite of benchmarks including both programs from the Software\nVerification Competition (SV-COMP) and from prior literature, and found that\nour implementation of GPS outperforms state-of-the-art software model checkers\n(including the top performers in SV-COMP ReachSafety-Loops category), both in\nterms of the number of benchmarks solved and in terms of running time.", "AI": {"tldr": "GPS is a new model-checking algorithm that outperforms top tools by combining static analysis with a novel search strategy, quickly finding bugs or proving safety even in complex programs.", "motivation": "Existing software model-checkers face challenges in efficiently finding bugs and proving safety, especially in programs with complex, input-dependent error paths. There is also a need for approaches that can provably find errors when they exist.", "method": "The paper introduces a new model-checking algorithm, GPS. GPS uses compositional, summary-based static analysis to direct the search for program bugs and safety proofs. It employs a two-layered search strategy and incorporates a new instrumentation technique to ensure refutational completeness without sacrificing performance.", "result": "GPS was tested on benchmarks from SV-COMP and existing literature, outperforming state-of-the-art model checkers in both the number of benchmarks solved and running time.", "conclusion": "The proposed GPS model-checking algorithm is both efficient and effective, capable of proving safety, finding bugs in complex programs, and delivering superior performance compared to leading alternatives."}}
{"id": "2508.15157", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.15157", "abs": "https://arxiv.org/abs/2508.15157", "authors": ["David M Kahn", "Jan Hoffmann", "Runming Li"], "title": "Big-Stop Semantics: A Simple Way to Get the Benefits of Small-Step Semantics in a Big-Step Judgment", "comment": "26 pages, 27 figures", "summary": "As evident in the programming language literature, many practitioners favor\nspecifying dynamic program behavior using big-step over small-step semantics.\nUnlike small-step semantics, which must dwell on every intermediate program\nstate, big-step semantics conveniently jump directly to the ever-important\nresult of the computation. Big-step semantics also typically involve fewer\ninference rules than their small-step counterparts. However, in exchange for\nergonomics, big-step semantics give up power: Small-step semantics describes\nprogram behaviors that are outside the grasp of big-step semantics, notably\ndivergence. This work presents a little-known extension of big-step semantics\nwith inductive definitions that captures diverging computations without\nintroducing error states. This big-stop semantics is illustrated for typed,\nuntyped, and effectful variants of PCF, as well as a while-loop-based\nimperative language. Big-stop semantics extends the standard big-step inference\nrules with a few additional rules to define an evaluation judgment that is\nequivalent to the reflexive-transitive closure of small-step transitions. This\nsimple extension contrasts with other solutions in the literature which\nsacrifice ergonomics by introducing many additional inference rules, global\nstate, and/or less-commonly-understood reasoning principles like coinduction.", "AI": {"tldr": "The paper introduces big-stop semantics, an ergonomic extension to big-step semantics, enabling it to accurately model diverging program behaviors without significant complexity or loss of clarity.", "motivation": "Big-step semantics in programming language analysis are popular for their simplicity and focus on final computation results, using fewer and more ergonomic rules compared to small-step semantics. However, they are limited as they cannot express some behaviors such as divergence (infinite computation). There is a gap in extending big-step semantics to account for such behaviors without losing their ergonomic advantage.", "method": "The paper introduces an extension to traditional big-step semantics, called 'big-stop semantics.' This approach augments the standard set of inference rules with a small number of additional rules to accurately capture diverging computations. The method is applied and demonstrated on typed, untyped, and effectful variants of PCF (Programming Computable Functions), as well as an imperative language using while-loops.", "result": "Big-stop semantics successfully describes diverging behaviors without the need to introduce error states or rely on complex features like global state or coinduction. The approach remains ergonomic, retaining the hallmark simplicity and directness of big-step semantics, while achieving an evaluation judgment equivalent to the reflexive-transitive closure of small-step semantics.", "conclusion": "Big-stop semantics offers a simple yet powerful extension to big-step semantics, enabling the expression of diverging computations while maintaining ease of use. Unlike other methods, it achieves this without sacrificing ergonomics or introducing significant theoretical overhead."}}
{"id": "2508.15166", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.15166", "abs": "https://arxiv.org/abs/2508.15166", "authors": ["Jingbo Wang", "Shashin Halalingaiah", "Weiyi Chen", "Chao Wang", "Isil Dillig"], "title": "Probabilistic Inference for Datalog with Correlated Inputs", "comment": "Accepted for publication at OOPSLA 2025 (R2)", "summary": "Probabilistic extensions of logic programming languages, such as ProbLog,\nintegrate logical reasoning with probabilistic inference to evaluate\nprobabilities of output relations; however, prior work does not account for\npotential statistical correlations among input facts. This paper introduces\nPraline, a new extension to Datalog designed for precise probabilistic\ninference in the presence of (partially known) input correlations. We formulate\nthe inference task as a constrained optimization problem, where the solution\nyields sound and precise probability bounds for output facts. However, due to\nthe complexity of the resulting optimization problem, this approach alone often\ndoes not scale to large programs. To address scalability, we propose a more\nefficient $\\delta$-exact inference algorithm that leverages constraint solving,\nstatic analysis, and iterative refinement. Our empirical evaluation on\nchallenging real-world benchmarks, including side-channel analysis,\ndemonstrates that our method not only scales effectively but also delivers\ntight probability bounds.", "AI": {"tldr": "Praline, a new Datalog extension, enables precise and scalable probabilistic inference with input correlations by combining optimization and efficient algorithms, achieving strong results on real-world problems.", "motivation": "Probabilistic logic programming languages often overlook statistical correlations among input facts, which can lead to inaccurate results. There is a need to effectively incorporate such correlations for precise inference.", "method": "The paper introduces Praline, an extension to Datalog, which frames probabilistic inference as a constrained optimization problem to yield precise probability bounds. Additionally, a scalable \u03b4-exact inference algorithm is developed using constraint solving, static analysis, and iterative refinement.", "result": "Praline provides sound and precise probability bounds even when input correlations are only partially known. The proposed inference algorithm scales well and produces tight probability bounds on real-world datasets, such as side-channel analysis benchmarks.", "conclusion": "Integrating input correlations into probabilistic inference for logic programming is feasible and effective. Praline enables precise and scalable inference with correlated inputs, outperforming traditional approaches in both scalability and result quality."}}
{"id": "2508.15135", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15135", "abs": "https://arxiv.org/abs/2508.15135", "authors": ["Sumudu Liyanage", "Sherlock A. Licorish", "Markus Wagner", "Stephen G. MacDonell"], "title": "On the need to perform comprehensive evaluations of automated program repair benchmarks: Sorald case study", "comment": null, "summary": "In supporting the development of high-quality software, especially necessary\nin the era of LLMs, automated program repair (APR) tools aim to improve code\nquality by automatically addressing violations detected by static analysis\nprofilers. Previous research tends to evaluate APR tools only for their ability\nto clear violations, neglecting their potential introduction of new (sometimes\nsevere) violations, changes to code functionality and degrading of code\nstructure. There is thus a need for research to develop and assess\ncomprehensive evaluation frameworks for APR tools. This study addresses this\nresearch gap, and evaluates Sorald (a state-of-the-art APR tool) as a proof of\nconcept. Sorald's effectiveness was evaluated in repairing 3,529 SonarQube\nviolations across 30 rules within 2,393 Java code snippets extracted from Stack\nOverflow. Outcomes show that while Sorald fixes specific rule violations, it\nintroduced 2,120 new faults (32 bugs, 2088 code smells), reduced code\nfunctional correctness--as evidenced by a 24% unit test failure rate--and\ndegraded code structure, demonstrating the utility of our framework. Findings\nemphasize the need for evaluation methodologies that capture the full spectrum\nof APR tool effects, including side effects, to ensure their safe and effective\nadoption.", "AI": {"tldr": "Evaluating APR tools solely on their violation-fixing capability is insufficient; this study shows that tools like Sorald can introduce new faults and worsen code quality, highlighting the necessity of holistic evaluation frameworks.", "motivation": "Automated Program Repair (APR) tools are widely used to fix code issues detected by static analysis, but existing research mainly evaluates them based on their ability to fix specific violations. Side effects\u2014such as introducing new faults, changing program behavior, or degrading code structure\u2014are often overlooked. Thus, a comprehensive evaluation framework for APR tools is needed.", "method": "The study proposes and uses a comprehensive evaluation framework, using Sorald (a state-of-the-art APR tool) as a case study. It repairs 3,529 SonarQube violations (across 30 rules) in 2,393 Java code snippets from Stack Overflow, and assesses new violations, bugs, code smells, unit test pass rate, and code structure after repair.", "result": "Sorald was able to fix the targeted rule violations but also introduced 2,120 new faults (32 bugs and 2,088 code smells), led to a 24% failure rate in unit tests (loss of functional correctness), and degraded code structure.", "conclusion": "APR tools, while effective in addressing specific violations, can introduce significant negative side effects. Comprehensive evaluation frameworks are necessary to properly assess their impacts and ensure their safe deployment."}}
{"id": "2508.15264", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.15264", "abs": "https://arxiv.org/abs/2508.15264", "authors": ["Patrick Redmond", "Jonathan Castello", "Jos\u00e9 Manuel Calder\u00f3n Trilla", "Lindsey Kuper"], "title": "Exploring the Theory and Practice of Concurrency in the Entity-Component-System Pattern", "comment": "This is an extended version (with appendices) of the OOPSLA 2025\n  paper", "summary": "The Entity-Component-System (ECS) software design pattern, long used in game\ndevelopment, encourages a clean separation of identity (entities), data\nproperties (components), and computational behaviors (systems). Programs\nwritten using the ECS pattern are naturally concurrent, and the pattern offers\nmodularity, flexibility, and performance benefits that have led to a\nproliferation of ECS frameworks. Nevertheless, the ECS pattern is little-known\nand not well understood outside of a few domains. Existing explanations of the\nECS pattern tend to be mired in the concrete details of particular ECS\nframeworks, or they explain the pattern in terms of imperfect metaphors or in\nterms of what it is not. We seek a rigorous understanding of the ECS pattern\nvia the design of a formal model, Core ECS, that abstracts away the details of\nspecific implementations to reveal the essence of software using the ECS\npattern. We identify a class of Core ECS programs that behave deterministically\nregardless of scheduling, enabling use of the ECS pattern as a\ndeterministic-by-construction concurrent programming model. With Core ECS as a\npoint of comparison, we then survey several real-world ECS frameworks and find\nthat they all leave opportunities for deterministic concurrency unexploited.\nOur findings point out a space for new ECS implementation techniques that\nbetter leverage such opportunities.", "AI": {"tldr": "The paper formalizes the ECS pattern with a model (Core ECS) that uncovers untapped opportunities for deterministic concurrency in current frameworks, paving the way for better designs.", "motivation": "The Entity-Component-System (ECS) software design pattern is popular in game development due to its modularity and performance, but its principles are not well understood outside limited domains. Existing explanations are tied to specific frameworks or rely on incomplete analogies.", "method": "The authors design a formal, abstract model called 'Core ECS' to distill the essential features of the ECS pattern. They use this model to analyze and compare several existing real-world ECS frameworks.", "result": "The analysis reveals a class of Core ECS programs that are deterministically concurrent, regardless of scheduling. Real-world ECS frameworks examined in this context often do not fully exploit deterministic concurrency opportunities offered by the pattern.", "conclusion": "A formal understanding of the ECS pattern is achieved through Core ECS, which identifies unexplored opportunities in existing frameworks for deterministic concurrency. This suggests possibilities for improved ECS implementations."}}
{"id": "2508.15411", "categories": ["cs.SE", "cs.CL", "cs.LG", "cs.MA"], "pdf": "https://arxiv.org/pdf/2508.15411", "abs": "https://arxiv.org/abs/2508.15411", "authors": ["Frederik Vandeputte"], "title": "Foundational Design Principles and Patterns for Building Robust and Adaptive GenAI-Native Systems", "comment": null, "summary": "Generative AI (GenAI) has emerged as a transformative technology,\ndemonstrating remarkable capabilities across diverse application domains.\nHowever, GenAI faces several major challenges in developing reliable and\nefficient GenAI-empowered systems due to its unpredictability and inefficiency.\nThis paper advocates for a paradigm shift: future GenAI-native systems should\nintegrate GenAI's cognitive capabilities with traditional software engineering\nprinciples to create robust, adaptive, and efficient systems.\n  We introduce foundational GenAI-native design principles centered around five\nkey pillars -- reliability, excellence, evolvability, self-reliance, and\nassurance -- and propose architectural patterns such as GenAI-native cells,\norganic substrates, and programmable routers to guide the creation of resilient\nand self-evolving systems. Additionally, we outline the key ingredients of a\nGenAI-native software stack and discuss the impact of these systems from\ntechnical, user adoption, economic, and legal perspectives, underscoring the\nneed for further validation and experimentation. Our work aims to inspire\nfuture research and encourage relevant communities to implement and refine this\nconceptual framework.", "AI": {"tldr": "GenAI is transformative but unreliable and inefficient in practice. This paper proposes new design principles and architectures to create robust, adaptive GenAI-native systems that blend AI power with classic engineering, aiming for resilient software that evolves itself and works well in real-world situations.", "motivation": "Generative AI is powerful but faces reliability and efficiency challenges in real-world systems, motivating the need for a new system design approach.", "method": "The paper defines 'GenAI-native' systems, introduces five core design principles, proposes architectural patterns, and discusses implementation ingredients and multidimensional impact.", "result": "The authors present a conceptual framework for integrating GenAI and traditional software engineering, arguing it will lead to more robust, adaptive, and efficient systems. They identify areas for future validation and research.", "conclusion": "GenAI-native systems, built on foundational principles and new architectural patterns, can address current GenAI limitations and promote the creation of resilient, self-evolving software."}}
{"id": "2508.15333", "categories": ["cs.PL", "F.3.3"], "pdf": "https://arxiv.org/pdf/2508.15333", "abs": "https://arxiv.org/abs/2508.15333", "authors": ["Francesco Dagnino", "Paola Giannini", "Violet Ka I Pun", "Ulises Torrella"], "title": "Fair Termination for Resource-Aware Active Objects", "comment": "18 pages, 12 pages of appendix, 12 figures, APLAS 2025", "summary": "Active object systems are a model of distributed computation that has been\nadopted for modelling distributed systems and business process workflows. This\nfield of modelling is, in essence, concurrent and resource-aware, motivating\nthe development of resource-aware formalisations on the active object model.\nThe contributions of this work are the development of a core calculus for\nresource-aware active objects together with a type system ensuring that\nwell-typed programs are fairly terminating, i.e., they can always eventually\nterminate. To achieve this, we combine techniques from graded semantics and\ntype systems, which are quite well understood for sequential programs, with\nthose for fair termination, which have been developed for synchronous~sessions.", "AI": {"tldr": "This work presents a formalism and type system for distributed active object systems, ensuring that well-typed programs will always eventually terminate, addressing both resource-awareness and fairness.", "motivation": "Active object systems, widely used in modeling distributed computation and workflows, require accurate and efficient approaches to handle inherent concurrency and resource constraints. There is a lack of formal models ensuring resource-awareness and fair termination in such settings.", "method": "The paper develops a core calculus specifically for resource-aware active objects. It also introduces a type system, drawing on techniques from graded semantics (commonly applied to sequential programs) and fair termination (developed for synchronous sessions).", "result": "The proposed system guarantees that any well-typed program is fairly terminating, meaning it will eventually terminate. The combination of graded semantics and fair-termination techniques in the type system is key to achieving this property.", "conclusion": "A novel formal model for resource-aware active object systems has been developed, supported by a type system that ensures fair termination of programs. This model advances reliable modeling and verification for distributed and concurrent applications."}}
{"id": "2508.15423", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2508.15423", "abs": "https://arxiv.org/abs/2508.15423", "authors": ["Ruiqi Wang", "Zezhou Yang", "Cuiyun Gao", "Xin Xia", "Qing Liao"], "title": "An Empirical Study of Knowledge Distillation for Code Understanding Tasks", "comment": "Accepted by ICSE 2026 (Cycle 1)", "summary": "Pre-trained language models (PLMs) have emerged as powerful tools for code\nunderstanding. However, deploying these PLMs in large-scale applications faces\npractical challenges due to their computational intensity and inference\nlatency. Knowledge distillation (KD), a promising model compression and\nacceleration technique, addresses these limitations by transferring knowledge\nfrom large teacher models to compact student models, enabling efficient\ninference while preserving most of the teacher models' capabilities. While this\ntechnique has shown remarkable success in natural language processing and\ncomputer vision domains, its potential for code understanding tasks remains\nlargely underexplored.\n  In this paper, we systematically investigate the effectiveness and usage of\nKD in code understanding tasks. Our study encompasses two popular types of KD\nmethods, i.e., logit-based and feature-based KD methods, experimenting across\neight student models and two teacher PLMs from different domains on three\ndownstream tasks. The experimental results indicate that KD consistently offers\nnotable performance boosts across student models with different sizes compared\nwith standard fine-tuning. Notably, code-specific PLM demonstrates better\neffectiveness as the teacher model. Among all KD methods, the latest\nfeature-based KD methods exhibit superior performance, enabling student models\nto retain up to 98% teacher performance with merely 5% parameters. Regarding\nstudent architecture, our experiments reveal that similarity with teacher\narchitecture does not necessarily lead to better performance. We further\ndiscuss the efficiency and behaviors in the KD process and inference, summarize\nthe implications of findings, and identify promising future directions.", "AI": {"tldr": "Knowledge distillation, especially feature-based methods, enables much smaller models to achieve near-teacher performance on code understanding tasks, overcoming deployment challenges for large PLMs.", "motivation": "Deploying pre-trained language models for code understanding is limited by their high computational demands and latency. The study aims to explore whether knowledge distillation can help compress these models efficiently without sacrificing much performance, specifically for code-related tasks, a relatively underexplored area.", "method": "The paper systematically benchmarks two knowledge distillation methods (logit-based and feature-based) using two teacher PLMs from different domains, and eight different student models, on three downstream code understanding tasks.", "result": "Knowledge distillation consistently improves performance of student models across sizes compared to standard fine-tuning. Code-specific teacher models yield the best results. Feature-based KD methods allow student models to retain up to 98% of teacher performance using only 5% of teacher parameters. Student and teacher architecture similarity does not guarantee better performance.", "conclusion": "KD techniques, especially feature-based ones, are highly effective for compressing code understanding PLMs, maintaining most performance while drastically reducing size and computational requirements. The findings suggest directions for more efficient large-scale deployment and further research into KD in code tasks."}}
{"id": "2508.15576", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.15576", "abs": "https://arxiv.org/abs/2508.15576", "authors": ["Andreas L\u00f6\u00f6w", "Seung Hoon Park", "Daniele Nantes-Sobrinho", "Sacha-\u00c9lie Ayoun", "Opale Sj\u00f6stedt", "Philippa Gardner"], "title": "Compositional Symbolic Execution for the Next 700 Memory Models (Extended Version)", "comment": null, "summary": "Multiple successful compositional symbolic execution (CSE) tools and\nplatforms exploit separation logic (SL) for compositional verification and/or\nincorrectness separation logic (ISL) for compositional bug-finding, including\nVeriFast, Viper, Gillian, CN, and Infer-Pulse. Previous work on the Gillian\nplatform, the only CSE platform that is parametric on the memory model, meaning\nthat it can be instantiated to different memory models, suggests that the\nability to use custom memory models allows for more flexibility in supporting\nanalysis of a wide range of programming languages, for implementing custom\nautomation, and for improving performance. However, the literature lacks a\nsatisfactory formal foundation for memory-model-parametric CSE platforms.\n  In this paper, inspired by Gillian, we provide a new formal foundation for\nmemory-model-parametric CSE platforms. Our foundation advances the state of the\nart in four ways. First, we mechanise our foundation (in the interactive\ntheorem prover Rocq). Second, we validate our foundation by instantiating it to\na broad range of memory models, including models for C and CHERI. Third,\nwhereas previous memory-model-parametric work has only covered SL analyses, we\ncover both SL and ISL analyses. Fourth, our foundation is based on standard\ndefinitions of SL and ISL (including definitions of function specification\nvalidity, to ensure sound interoperation with other tools and platforms also\nbased on standard definitions).", "AI": {"tldr": "The paper delivers a formal and mechanized foundation for compositional symbolic execution platforms that are parametric on memory models, supporting both separation logic and incorrectness separation logic, and validated against multiple memory models. This enables more flexible analysis across programming languages and standards-compliant integration with other tools.", "motivation": "The motivation stems from the lack of a rigorous formal foundation for compositional symbolic execution (CSE) platforms that are parametric on memory models, as evidenced by limitations in current tools like Gillian. The ability to flexibly support various programming languages and custom analyses through memory model parametricity presents both challenges and opportunities for improved verification and bug-finding.", "method": "The authors provide a new formal foundation for memory-model-parametric CSE platforms. They mechanize this foundation using the Rocq interactive theorem prover, validate it by instantiating to diverse memory models (including C and CHERI), and extend its applicability to both separation logic (SL) and incorrectness separation logic (ISL) analyses, all while adhering to established SL and ISL definitions for specification validity.", "result": "The foundation is successfully mechanized and validated through instantiation to several memory models. It supports both SL and ISL analyses, going beyond previous works that focused only on SL. The approach allows for sound interaction with other tools due to its adherence to standard definitions.", "conclusion": "This work advances the compositional verification and bug-finding capabilities of CSE platforms by supplying a rigorous, flexible, and standardized foundation for memory-model-parametric analysis, facilitating broader support for various languages and analyses."}}
{"id": "2508.15495", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15495", "abs": "https://arxiv.org/abs/2508.15495", "authors": ["Dongjun Yu", "Xiao Yan", "Zhenrui Li", "Jipeng Xiao", "Haochuan He", "Yongda Yu", "Hao Zhang", "Guoping Rong", "Xiaobo Huang"], "title": "SynthCoder: A Synthetical Strategy to Tune LLMs for Code Completion", "comment": null, "summary": "Code completion is a prominent application of Large Language Models (LLMs) in\nsoftware engineering. Due to the near real-time response requirements of this\ntask, base models with small to medium-sized parameters are typically employed,\nsupplemented by various optimization and post-training techniques. However,\nthese optimization methods often have trade-offs, leading to a seesaw effect\nwhere performance improvements on certain datasets or metrics are accompanied\nby degradations on others -- sometimes even falling below the baseline model's\nperformance. This paper proposes SynthCoder, a model that integrates leading\nindustry practices to achieve state-of-the-art performance on the\nFill-in-the-Middle (FIM) code completion task. In specific, we first construct\na diverse dataset by combining Abstract Syntax Tree (AST) node extraction with\nheuristics that simulate developer behavior. Then we enrich our training corpus\nwith cross-file contextual information using the BM25 algorithm and call\ngraphs, enhancing the model's ability to perform code completion in both\nfile-level and repository-level scenarios. As the last step, we employ a\ntwo-stage training process using the Seed-Coder-8B-Base as the base model.\nFirst, we fine-tune the model using Curriculum Learning technology. Following\nthis, we perform alignment using Direct Preference Optimization (DPO) with\npreference pairs generated through Rejection Sampling. Experimental results\ndemonstrate that our final model excels on mainstream repository-level code\ncompletion benchmarks, including aiXcoder, ExecRepoBench, CrossCodeEval, and\nCoLT. Furthermore, our carefully curated training set effectively mitigates the\nmodel's tendency to just repeat existing code, a common issue existing in\nvarious code completion models.", "AI": {"tldr": "SynthCoder integrates diverse training data, cross-file context, and multi-stage fine-tuning to set new performance standards in FIM code completion, outperforming previous models and resolving common pitfalls like code repetition.", "motivation": "Existing code completion LLMs must balance real-time responses with performance optimization, but current optimization methods often improve some metrics at the expense of others, even degrading baseline performance. There's a need for a solution that consistently excels across relevant benchmarks and scenarios.", "method": "The paper introduces SynthCoder, which 1) constructs a diverse dataset by extracting AST nodes and simulating developer actions; 2) enriches the training data with cross-file context using BM25 and call graphs; 3) adopts a two-stage training (curriculum learning followed by Direct Preference Optimization on preference pairs generated via rejection sampling) using Seed-Coder-8B-Base as the foundation.", "result": "SynthCoder achieves state-of-the-art results on several mainstream repository-level code completion benchmarks. Its training approach also reduces the model's tendency to simply repeat existing code, outperforming various existing solutions on these metrics.", "conclusion": "SynthCoder, through improved data diversity, contextual enrichment, and sophisticated training strategies, delivers superior fill-in-the-middle code completion performance, addressing trade-offs seen in existing optimization approaches. It provides strong, generalizable results across multiple real-world benchmarks."}}
{"id": "2508.15750", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2508.15750", "abs": "https://arxiv.org/abs/2508.15750", "authors": ["Celeste Barnaby", "Qiaochu Chen", "Ramya Ramalingam", "Osbert Bastani", "Isil Dillig"], "title": "Active Learning for Neurosymbolic Program Synthesis", "comment": null, "summary": "The goal of active learning for program synthesis is to synthesize the\ndesired program by asking targeted questions that minimize user interaction.\nWhile prior work has explored active learning in the purely symbolic setting,\nsuch techniques are inadequate for the increasingly popular paradigm of\nneurosymbolic program synthesis, where the synthesized program incorporates\nneural components. When applied to the neurosymbolic setting, such techniques\ncan -- and, in practice, do -- return an unintended program due to\nmispredictions of neural components. This paper proposes a new active learning\ntechnique that can handle the unique challenges posed by neural network\nmispredictions. Our approach is based upon a new evaluation strategy called\nconstrained conformal evaluation (CCE), which accounts for neural\nmispredictions while taking into account user-provided feedback. Our proposed\nmethod iteratively makes CCE more precise until all remaining programs are\nguaranteed to be observationally equivalent. We have implemented this method in\na tool called SmartLabel and experimentally evaluated it on three neurosymbolic\ndomains. Our results demonstrate that SmartLabel identifies the ground truth\nprogram for 98% of the benchmarks, requiring under 5 rounds of user interaction\non average. In contrast, prior techniques for active learning are only able to\nconverge to the ground truth program for at most 65% of the benchmarks.", "AI": {"tldr": "This paper introduces SmartLabel, an active learning approach for neurosymbolic program synthesis that handles neural mispredictions using constrained conformal evaluation, achieving much higher accuracy and fewer user interactions than previous methods.", "motivation": "Active learning for program synthesis aims to reduce user interaction by asking smarter questions. However, previous techniques mostly address symbolic settings and do not work well for neurosymbolic program synthesis, where unpredictable neural network errors undermine prior methods.", "method": "The authors propose a new active learning technique based on 'constrained conformal evaluation' (CCE), which specifically addresses the problem of neural network mispredictions in neurosymbolic program synthesis. The method iteratively refines the evaluation until all candidate programs are observationally indistinguishable, using user-provided feedback.", "result": "Their system, SmartLabel, was tested on three neurosymbolic domains. SmartLabel found the correct (ground truth) program in 98% of cases, typically needing fewer than 5 user interactions, outperforming prior active learning methods which only succeeded in up to 65% of benchmarks.", "conclusion": "The paper demonstrates that their new CCE-based approach for active learning efficiently finds the correct neurosymbolic programs, handling neural network errors and significantly reducing user effort compared to previous techniques."}}
{"id": "2508.15496", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15496", "abs": "https://arxiv.org/abs/2508.15496", "authors": ["Elena Masserini", "Diego Clerissi", "Daniela Micucci", "Jo\u00e3o R. Campos", "Leonardo Mariani"], "title": "Towards the Assessment of Task-based Chatbots: From the TOFU-R Snapshot to the BRASATO Curated Dataset", "comment": "10 pages, 10 figure, Accepted at IEEE International Symposium on\n  Software Reliability Engineering (ISSRE) 2025", "summary": "Task-based chatbots are increasingly being used to deliver real services, yet\nassessing their reliability, security, and robustness remains underexplored,\nalso due to the lack of large-scale, high-quality datasets. The emerging\nautomated quality assessment techniques targeting chatbots often rely on\nlimited pools of subjects, such as custom-made toy examples, or outdated, no\nlonger available, or scarcely popular agents, complicating the evaluation of\nsuch techniques. In this paper, we present two datasets and the tool support\nnecessary to create and maintain these datasets. The first dataset is RASA\nTASK-BASED CHATBOTS FROM GITHUB (TOFU-R), which is a snapshot of the Rasa\nchatbots available on GitHub, representing the state of the practice in\nopen-source chatbot development with Rasa. The second dataset is BOT RASA\nCOLLECTION (BRASATO), a curated selection of the most relevant chatbots for\ndialogue complexity, functional complexity, and utility, whose goal is to ease\nreproducibility and facilitate research on chatbot reliability.", "AI": {"tldr": "This paper addresses the gap in chatbot reliability assessment by releasing two comprehensive datasets and tools, facilitating robust and reproducible research in the field.", "motivation": "There is a lack of large-scale, high-quality datasets for assessing chatbot reliability and quality, and current automated assessment techniques suffer from limited evaluation subjects.", "method": "The authors collect and curate two datasets: TOFU-R, a snapshot of open-source Rasa task-based chatbots from GitHub, and BRASATO, a curated set of chatbots chosen for dialogue and functional complexity as well as utility.", "result": "Two publicly available datasets (TOFU-R and BRASATO) along with tool support are introduced, making it easier for researchers to evaluate and reproduce studies on chatbot reliability.", "conclusion": "The paper provides two new datasets and supporting tools that enable better research on evaluating chatbot reliability, security, and robustness."}}
{"id": "2508.15503", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15503", "abs": "https://arxiv.org/abs/2508.15503", "authors": ["Sebastian Baltes", "Florian Angermeir", "Chetan Arora", "Marvin Mu\u00f1oz Bar\u00f3n", "Chunyang Chen", "Lukas B\u00f6hme", "Fabio Calefato", "Neil Ernst", "Davide Falessi", "Brian Fitzgerald", "Davide Fucci", "Marcos Kalinowski", "Stefano Lambiase", "Daniel Russo", "Mircea Lungu", "Lutz Prechelt", "Paul Ralph", "Christoph Treude", "Stefan Wagner"], "title": "Evaluation Guidelines for Empirical Studies in Software Engineering involving LLMs", "comment": "Draft of evaluation guidelines for empirical studies in software\n  engineering involving LLMs (see also llm-guidelines.org)", "summary": "Large language models (LLMs) are increasingly being integrated into software\nengineering (SE) research and practice, yet their non-determinism, opaque\ntraining data, and evolving architectures complicate the reproduction and\nreplication of empirical studies. We present a community effort to scope this\nspace, introducing a taxonomy of LLM-based study types together with eight\nguidelines for designing and reporting empirical studies involving LLMs. The\nguidelines present essential (must) criteria as well as desired (should)\ncriteria and target transparency throughout the research process. Our\nrecommendations, contextualized by our study types, are: (1) to declare LLM\nusage and role; (2) to report model versions, configurations, and fine-tuning;\n(3) to document tool architectures; (4) to disclose prompts and interaction\nlogs; (5) to use human validation; (6) to employ an open LLM as a baseline; (7)\nto report suitable baselines, benchmarks, and metrics; and (8) to openly\narticulate limitations and mitigations. Our goal is to enable reproducibility\nand replicability despite LLM-specific barriers to open science. We maintain\nthe study types and guidelines online as a living resource for the community to\nuse and shape (llm-guidelines.org).", "AI": {"tldr": "This paper proposes a taxonomy and eight clear guidelines for conducting and reporting empirical studies using large language models in software engineering, aiming to boost reproducibility and transparency despite inherent LLM complexities. Guidelines are available and maintained online as an ongoing resource.", "motivation": "The motivation is to address the challenges in reproducibility and replicability in empirical software engineering studies that use large language models (LLMs), due to factors such as the non-deterministic nature of LLMs, opaque training datasets, and rapidly changing architectures.", "method": "This paper presents a community effort that produces (1) a taxonomy of empirical study types involving LLMs and (2) eight comprehensive guidelines targeting transparent research design and reporting for studies using LLMs. These guidelines specify both essential (must) and desired (should) practices, contextualized via various study types, and are maintained as an evolving online resource.", "result": "The paper introduces a set of eight detailed guidelines addressing key areas such as LLM documentation, tool architecture reporting, disclosure of prompts, use of baselines, and human validation. These guidelines, along with the study taxonomy, are published and maintained online (llm-guidelines.org) as a living resource for the community.", "conclusion": "By clarifying and standardizing how LLMs are used and reported in empirical software engineering studies, the paper aims to overcome LLM-specific barriers and promote higher reproducibility and replicability of research outcomes. The living guidelines are intended to evolve with the field."}}
{"id": "2508.15512", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15512", "abs": "https://arxiv.org/abs/2508.15512", "authors": ["Markus Borg", "Martin Larsson", "Philip Breid", "Nadim Hagatulah"], "title": "QUPER-MAn: Benchmark-Guided Target Setting for Maintainability Requirements", "comment": "Accepted at the 1st International Workshop on Responsible Software\n  Engineering", "summary": "Maintainable source code is essential for sustainable development in any\nsoftware organization. Unfortunately, many studies show that maintainability\noften receives less attention than its importance warrants. We argue that\nrequirements engineering can address this gap the problem by fostering\ndiscussions and setting appropriate targets in a responsible manner. In this\npreliminary work, we conducted an exploratory study of industry practices\nrelated to requirements engineering for maintainability. Our findings confirm\nprevious studies: maintainability remains a second-class quality concern.\nExplicit requirements often make sweeping references to coding conventions.\nTools providing maintainability proxies are common but typically only used in\nimplicit requirements related to engineering practices. To address this, we\npropose QUPER-MAn, a maintainability adaption of the QUPER model, which was\noriginally developed to help organizations set targets for performance\nrequirements. Developed using a design science approach, QUPER-MAn, integrates\nmaintainability benchmarks and supports target setting. We posit that it can\nshift maintainability from an overlooked development consequence to an actively\nmanaged goal driven by informed and responsible engineering decisions.", "AI": {"tldr": "Maintainability of software is still undervalued in industry practices. An exploratory study highlights this gap and introduces QUPER-MAn, a model based on QUPER, to set explicit maintainability targets and benchmarks, aiming to integrate maintainability as a first-class engineering concern.", "motivation": "Maintainable source code is critical for sustainable software development, but it often receives inadequate attention in the industry. The paper seeks to address why maintainability is undervalued and proposes to improve it through requirements engineering.", "method": "The authors conducted an exploratory study of industry practices concerning requirements engineering for software maintainability and used a design science approach to develop a new model called QUPER-MAn.", "result": "The study confirmed that maintainability is still a low-priority concern, often only mentioned in general terms through coding conventions or implied via certain tool usage. The QUPER-MAn model was proposed as a means to make maintainability an explicit, measurable, and manageable target.", "conclusion": "QUPER-MAn could transform maintainability from an implicit aspect of engineering to an explicit, actively managed requirement by helping organizations set concrete maintainability goals and benchmarks."}}
{"id": "2508.15536", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15536", "abs": "https://arxiv.org/abs/2508.15536", "authors": ["Yi Zhang", "He Jiang", "Xiaochen Li", "Shikai Guo", "Peiyu Zou", "Zun Wang"], "title": "A Novel Mutation Based Method for Detecting FPGA Logic Synthesis Tool Bugs", "comment": null, "summary": "FPGA (Field-Programmable Gate Array) logic synthesis tools are key components\nin the EDA (Electronic Design Automation) toolchain. They convert hardware\ndesigns written in description languages such as Verilog into gate-level\nrepresentations for FPGAs. However, defects in these tools may lead to\nunexpected behaviors and pose security risks. Therefore, it is crucial to\nharden these tools through testing. Although several methods have been proposed\nto automatically test FPGA logic synthesis tools, the challenge remains of\ninsufficient semantic and logical complexity in test programs. In this paper,\nwe propose VERMEI, a new method for testing FPGA logic synthesis tools. VERMEI\nconsists of three modules: preprocessing, equivalent mutation, and bug\nidentification. The preprocessing module identifies zombie logic (inactive code\nwith no impact on the circuit output) in seed programs through simulation and\ncoverage analysis. The equivalent mutation module generates equivalent variants\nof seed programs by pruning or inserting logic fragments in zombie areas. It\nuses Bayesian sampling to extract logic fragments from historical Verilog\ndesigns, making the generated variants have complex control flows and\nstructures. The bug identification module, based on differential testing,\ncompares the synthesized outputs of seed and variant programs to identify bugs.\nExperiments on Yosys, Vivado, and Quartus demonstrate that VERMEI outperforms\nthe state-of-the-art methods. Within five months, VERMEI reported 15 bugs to\nvendors, 9 of which were confirmed as new.", "AI": {"tldr": "The paper introduces VERMEI, a new framework to thoroughly test FPGA synthesis tools by generating semantically rich test cases. VERMEI identifies and mutates inactive code, using machine-learning approaches to increase complexity, enabling it to outpace existing methods. It found 15 bugs (9 new) across major tools, demonstrating its superior effectiveness.", "motivation": "FPGA logic synthesis tools play a critical role in converting hardware designs into functional circuits, but defects in these tools may cause unexpected behaviors and security risks. Existing automatic testing methods do not generate test programs with sufficient semantic and logical complexity, limiting their effectiveness. The motivation is to develop a more effective testing approach to expose hidden bugs in FPGA synthesis tools.", "method": "The paper presents VERMEI, a novel testing method for FPGA logic synthesis tools, composed of three modules. The preprocessing module identifies 'zombie logic' (inactive code) through simulation and coverage analysis. The equivalent mutation module generates program variants with complex control flows by reorganizing logic fragments, using Bayesian sampling from historical Verilog designs, and focusing operations in zombie logic areas. The bug identification module uses differential testing to compare the synthesized outputs between original and mutated programs to uncover synthesis tool bugs.", "result": "Experiments on three major FPGA synthesis tools (Yosys, Vivado, and Quartus) show that VERMEI surpasses previous state-of-the-art methods in finding defects. Over five months, VERMEI detected 15 bugs, 9 of which were acknowledged as new by tool vendors.", "conclusion": "VERMEI is an effective and advanced method for testing FPGA logic synthesis tools, especially in generating logically complex test programs, leading to the discovery of previously unknown bugs. The modular design and use of Bayesian sampling enhance both efficiency and bug detection capability."}}
{"id": "2508.15570", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15570", "abs": "https://arxiv.org/abs/2508.15570", "authors": ["Marion Wiese", "Kamila Serwa", "Anastasia Besier", "Ariane S. Marion-Jetten", "Eva Bittner"], "title": "Establishing Technical Debt Management -- A Five-Step Workshop Approach and an Action Research Study", "comment": "Accepted for publication by the Journal of Systems and Software --\n  Special Issue on Managing Technical Debt in Software-Intensive Products and\n  Services", "summary": "Context. Technical debt (TD) items are constructs in a software system\nproviding short-term benefits but hindering future changes. TD management (TDM)\nis frequently researched but rarely adopted in practice. Goal. This study aimed\nto establish a TDM process in an IT company based on a predefined workshop\nconcept. We analyzed which research approaches practitioners adopted for each\nTD activity and the TDM's long-term effect on TD awareness. Method. We used\naction research (five action cycles in 16 months) with an IT team that creates\nIT solutions for signal processing. To examine TD awareness, we (1) analyzed\nquestionnaires completed during each workshop, (2) observed team meetings, (3)\nadopted a method from psychology for measuring awareness in decision-making\nsituations called TD-SAGAT, and (4) evaluated the backlog data. Results.\nPractitioners preferred TD repayment and prioritization based on the system's\nevolution and cost calculations, i.e., repayment of so-called low-hanging\nfruits. Reminders in the backlog items, such as checkboxes or text templates,\nled to a sustainable rise in TD awareness. Conclusions. We showed that a\nworkshop-based approach is feasible and leads to sustainable process changes.\nNew ideas for TDM applicable to other IT teams emerged, e.g., using a\nre-submission date, using a Talked about TD checkbox, and using visualizations\nfor TD prioritization.", "AI": {"tldr": "The paper demonstrates that a workshop-based approach can effectively implement sustainable technical debt management practices in IT teams, increasing TD awareness and yielding practical management tools that other teams can adopt.", "motivation": "Technical debt (TD) management is widely researched but seldom implemented effectively in practice. The study seeks to bridge the gap between research and real-world application by establishing an actionable TDM process within an IT company.", "method": "The study used an action research method involving five action cycles over 16 months with an IT team. Researchers collected data using questionnaires during workshops, observed team meetings, applied a psychological measurement method (TD-SAGAT) to gauge awareness in decision-making, and analyzed backlog data.", "result": "Practitioners preferred TD repayment and prioritization strategies that focused on immediate, easy fixes and cost calculations. Simple interventions like adding checkbox reminders or text templates in backlog items significantly increased long-term TD awareness within the team.", "conclusion": "A workshop-based TDM process is feasible and leads to sustainable changes in TD management behaviors in IT teams. New, practical approaches, such as re-submission dates, special checkboxes, and visual prioritization, were successfully identified for broader application."}}
{"id": "2508.15584", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2508.15584", "abs": "https://arxiv.org/abs/2508.15584", "authors": ["Maria Teresa Rossi", "Leonardo Mariani", "Oliviero Riganelli"], "title": "From PREVENTion to REACTion: Enhancing Failure Resolution in Naval Systems", "comment": null, "summary": "Complex and large industrial systems often misbehave, for instance, due to\nwear, misuse, or faults. To cope with these incidents, it is important to\ntimely detect their occurrences, localize the sources of the problems, and\nimplement the appropriate countermeasures. This paper reports our experience\nwith a state-of-the-art failure prediction method, PREVENT, and its extension\nwith a troubleshooting module, REACT, applied to naval systems developed by\nFincantieri. Our results show how to integrate anomaly detection with\ntroubleshooting procedures. We conclude by discussing a lesson learned, which\nmay help deploy and extend these analyses to other industrial products.", "AI": {"tldr": "This paper evaluates a failure prediction and troubleshooting system (PREVENT+REACT) on naval systems, highlighting successful integration of detection and troubleshooting, and offering guidance for broader application.", "motivation": "Industrial systems are prone to misbehavior due to issues like wear, misuse, or faults, necessitating effective detection and troubleshooting methods.", "method": "The authors apply PREVENT, a failure prediction method, and extend it with a troubleshooting module called REACT. The approach is tested on naval systems by Fincantieri.", "result": "The integration of anomaly detection with troubleshooting procedures was demonstrated successfully on real-world naval systems.", "conclusion": "The paper summarizes the implementation experience and discusses lessons learned, providing insights helpful for applying similar analyses to other industrial systems."}}

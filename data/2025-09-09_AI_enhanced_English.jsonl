{"id": "2509.05504", "categories": ["cs.PL", "cs.AR"], "pdf": "https://arxiv.org/pdf/2509.05504", "abs": "https://arxiv.org/abs/2509.05504", "authors": ["Karl Aaron Rudkowski", "Sallar Ahmadi-Pour", "Rolf Drechsler"], "title": "Comparing Methods for the Cross-Level Verification of SystemC Peripherals with Symbolic Execution", "comment": null, "summary": "Virtual Prototypes (VPs) are important tools in modern hardware development.\nAt high abstractions, they are often implemented in SystemC and offer early\nanalysis of increasingly complex designs. These complex designs often combine\none or more processors, interconnects, and peripherals to perform tasks in\nhardware or interact with the environment. Verifying these subsystems is a\nwell-suited task for VPs, as they allow reasoning across different abstraction\nlevels. While modern verification techniques like symbolic execution can be\nseamlessly integrated into VP-based workflows, they require modifications in\nthe SystemC kernel. Hence, existing approaches therefore modify and replace the\nSystemC kernel, or ignore the opportunity of cross-level scenarios completely,\nand would not allow focusing on special challenges of particular subsystems\nlike peripherals. We propose CrosSym and SEFOS, two opposing approaches for a\nversatile symbolic execution of peripherals. CrosSym modifies the SystemC\nkernel, while SEFOS instead modifies a modern symbolic execution engine. Our\nextensive evaluation applies our tools to various peripherals on different\nlevels of abstractions. Both tools extensive sets of features are demonstrated\nfor (1) different verification scenarios, and (2) identifying 300+ mutants. In\ncomparison with each other, SEFOS convinces with the unmodified SystemC kernel\nand peripheral, while CrosSym offers slightly better runtime and memory usage.\nIn comparison to the state-of-the-art, that is limited to Transaction Level\nModelling (TLM), our tools offered comparable runtime, while enabling\ncross-level verification with symbolic execution.", "AI": {"tldr": "This work introduces two tools, CrosSym and SEFOS, enabling symbolic execution of hardware peripherals in SystemC VPs across different abstraction levels. SEFOS avoids kernel modification, while CrosSym optimizes performance. Both offer powerful, flexible verification exceeding the limitations of current TLM-based methods.", "motivation": "Virtual Prototypes (VPs) are extensively used in hardware design to verify complex systems, typically involving multiple components. However, enabling powerful verification methods like symbolic execution requires modifying the SystemC kernel, which can limit flexibility, especially for targeted subsystem analysis.", "method": "The paper proposes two different approaches for symbolic execution of hardware peripherals in SystemC-based VPs: CrosSym, which modifies the SystemC kernel, and SEFOS, which modifies the symbolic execution engine instead. Both tools were evaluated with various peripherals at different abstraction levels.", "result": "Both CrosSym and SEFOS offer a wide range of features, demonstrated in multiple verification scenarios and successfully identifying over 300 mutants. SEFOS maintains compatibility with the original SystemC kernel and peripheral, while CrosSym has better runtime and memory efficiency.", "conclusion": "SEFOS stands out for not requiring kernel or peripheral modification, enhancing workflow integration, while CrosSym offers improved performance. Compared to the state-of-the-art, both allow cross-level symbolic execution with verification capabilities comparable in runtime to existing TLM approaches."}}
{"id": "2509.05586", "categories": ["cs.PL", "cs.CC"], "pdf": "https://arxiv.org/pdf/2509.05586", "abs": "https://arxiv.org/abs/2509.05586", "authors": ["Lee Zheng Han", "Umang Mathur"], "title": "Fixed Parameter Tractable Linearizability Monitoring for Stack, Queue and Anagram Agnostic Data Types", "comment": null, "summary": "Verifying linearizability of concurrent data structures is NP-hard, even for\nsimple types. We present fixed-parameter tractable algorithms for monitoring\nstacks, queues, and anagram-agnostic data types (AADTs), parameterized by the\nmaximum concurrency. Our approach leverages frontier graphs and partition\nstates to bound the search space. For AADTs, equivalence of linearizations\nenables monitoring in log-linear time. For stacks, we introduce a grammar-based\nmethod with a sub-cubic reduction to matrix multiplication, and for queues, a\nsplit-sequence transition system supporting efficient dynamic programming.\nThese results unify tractability guarantees for both order-sensitive and\nanagram-agnostic data types under bounded concurrency.", "AI": {"tldr": "The paper introduces efficient, fixed-parameter tractable algorithms for verifying linearizability in concurrent stacks, queues, and anagram-agnostic types, making verification feasible under bounded concurrency via state-space reduction and specialized techniques for each data structure.", "motivation": "Linearizability verification for concurrent data structures is computationally difficult (NP-hard), even for basic structures like stacks and queues. Efficient and practical verification is crucial to ensure correctness of such systems in real-world concurrent computing.", "method": "The authors introduce fixed-parameter tractable algorithms for monitoring linearizability in stacks, queues, and anagram-agnostic data types (AADTs), with the parameter being the maximum concurrency. The approach exploits frontier graphs and partition states to reduce the verification search space. For stacks, a grammar-based method is used with a sub-cubic reduction to matrix multiplication. For queues, a split-sequence transition system enables efficient dynamic programming. For AADTs, the algorithm uses the equivalence of linearizations to achieve log-linear monitoring time.", "result": "The proposed algorithms provide tractable linearizability monitoring for multiple concurrent data structures under bounded concurrency. Specifically, they demonstrate log-linear monitoring for AADTs, improved stack monitoring via grammar and matrix multiplication reduction, and efficient queue monitoring via dynamic programming.", "conclusion": "By parameterizing by maximum concurrency and specializing algorithms to data type characteristics, the authors achieve fixed-parameter tractable verification for a range of concurrent data structures, improving the practicality of correctness verification in concurrent computing."}}
{"id": "2509.06724", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.06724", "abs": "https://arxiv.org/abs/2509.06724", "authors": ["Florian Kohn", "Arthur Correnson", "Jan Baumeister", "Bernd Finkbeiner"], "title": "Pacing Types: Safe Monitoring of Asynchronous Streams", "comment": null, "summary": "Stream-based monitoring is a real-time safety assurance mechanism for complex\ncyber-physical systems such as unmanned aerial vehicles. In this context, a\nmonitor aggregates streams of input data from sensors and other sources to give\nreal-time statistics and assessments of the system's health. Since monitors are\nsafety-critical components, it is crucial to ensure that they are free of\npotential runtime errors. One of the central challenges in designing reliable\nstream-based monitors is to deal with the asynchronous nature of data streams:\nin concrete applications, the different sensors being monitored produce values\nat different speeds, and it is the monitor's responsibility to correctly react\nto the asynchronous arrival of different streams of values. To ease this\nprocess, modern frameworks for stream-based monitoring such as RTLola feature\nan expressive specification language that allows to finely specify data\nsynchronization policies. While this feature dramatically simplifies the design\nof monitors, it can also lead to subtle runtime errors. To mitigate this issue,\nthis paper presents pacing types, a novel type system implemented in RTLola to\nensure that monitors for asynchronous streams are well-behaved at runtime. We\nformalize the essence of pacing types for a core fragment of RTLola, and\npresent a soundness proof of the pacing type system using a new logical\nrelation.", "AI": {"tldr": "This paper introduces 'pacing types,' a new type system for stream-based monitoring in safety-critical systems, ensuring reliable handling of asynchronous data streams in RTLola. The method is formalized and proven sound, addressing the risk of runtime errors from complex synchronization policies.", "motivation": "Stream-based monitoring is crucial for real-time safety in cyber-physical systems, such as UAVs, but is challenged by asynchronous sensor data and potential runtime errors. Current frameworks simplify design via expressive synchronization policies, which can introduce subtle errors.", "method": "The paper presents 'pacing types,' a novel type system for RTLola, and formalizes their essence for a core fragment of RTLola. It establishes a soundness proof through a new logical relation.", "result": "Pacing types were implemented in RTLola, ensuring well-behaved monitors for asynchronous streams at runtime. The soundness of pacing types was formally proven.", "conclusion": "The proposed pacing type system effectively ensures the correctness and reliability of stream-based monitors handling asynchronous data, mitigating the introduction of runtime errors from modern specification languages."}}
{"id": "2509.06752", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2509.06752", "abs": "https://arxiv.org/abs/2509.06752", "authors": ["Amir M. Ben-Amram", "Samir Genaim", "Jo\u00ebl Ouaknine", "James Worrell"], "title": "Termination Analysis of Linear-Constraint Programs", "comment": null, "summary": "This Survey provides an overview of techniques in termination analysis for\nprograms with numerical variables and transitions defined by linear\nconstraints. This subarea of program analysis is challenging due to the\nexistence of undecidable problems, and this Survey systematically explores\napproaches that mitigate this inherent difficulty. These include foundational\ndecidability results, the use of ranking functions, and disjunctive\nwell-founded transition invariants. The Survey also discusses non-termination\nwitnesses, used to prove that a program will not halt. We examine the\nalgorithmic and complexity aspects of these methods, showing how different\napproaches offer a trade-off between expressive power and computational\ncomplexity. The Survey does not discuss how termination analysis is performed\non real-world programming languages, nor does it consider more expressive\nabstract models that include non-linear arithmetic, probabilistic choice, or\nterm rewriting systems.", "AI": {"tldr": "This survey reviews methods for analyzing termination of programs with linear numerics, comparing their strengths, weaknesses, and computational trade-offs, but does not cover practical language implementations or more complex models.", "motivation": "Termination analysis for programs with numerical variables and linear constraints is inherently challenging due to undecidability issues. There is a need to systematically understand and compare the methods that address these challenges.", "method": "The paper surveys various techniques, including foundational decidability results, ranking functions, and disjunctive well-founded transition invariants. It also discusses non-termination witnesses and analyzes the algorithmic and complexity aspects of these approaches.", "result": "The survey presents different methods for termination analysis, highlighting the trade-offs between their expressive power and computational complexity. It thoroughly examines how each method mitigates the difficulties arising from undecidability in this domain.", "conclusion": "The paper concludes that while termination analysis for such constrained programs remains difficult, existing methods offer varying balances between power and complexity. However, the survey specifically does not address implementation in real-world languages or models with advanced features like non-linear arithmetic or probabilistic choice."}}
{"id": "2509.05372", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.05372", "abs": "https://arxiv.org/abs/2509.05372", "authors": ["Piotr Przymus", "Andreas Happe", "J\u00fcrgen Cito"], "title": "Adversarial Bug Reports as a Security Risk in Language Model-Based Automated Program Repair", "comment": null, "summary": "Large Language Model (LLM) - based Automated Program Repair (APR) systems are\nincreasingly integrated into modern software development workflows, offering\nautomated patches in response to natural language bug reports. However, this\nreliance on untrusted user input introduces a novel and underexplored attack\nsurface. In this paper, we investigate the security risks posed by adversarial\nbug reports -- realistic-looking issue submissions crafted to mislead APR\nsystems into producing insecure or harmful code changes. We develop a\ncomprehensive threat model and conduct an empirical study to evaluate the\nvulnerability of state-of-the-art APR systems to such attacks. Our\ndemonstration comprises 51 adversarial bug reports generated across a spectrum\nof strategies, from manual curation to fully automated pipelines. We test these\nagainst leading APR model and assess both pre-repair defenses (e.g., LlamaGuard\nvariants, PromptGuard variants, Granite-Guardian, and custom LLM filters) and\npost-repair detectors (GitHub Copilot, CodeQL). Our findings show that current\ndefenses are insufficient: 90\\% of crafted bug reports triggered\nattacker-aligned patches. The best pre-repair filter blocked only 47\\%, while\npost-repair analysis-often requiring human oversight-was effective in just 58\\%\nof cases. To support scalable security testing, we introduce a prototype\nframework for automating the generation of adversarial bug reports. Our\nanalysis exposes a structural asymmetry: generating adversarial inputs is\ninexpensive, while detecting or mitigating them remains costly and error-prone.\nWe conclude with practical recommendations for improving the robustness of APR\nsystems against adversarial misuse and highlight directions for future work on\ntrustworthy automated repair.", "AI": {"tldr": "LLM-based automated program repair is highly susceptible to adversarial bug reports that can introduce malicious patches. The defenses available today are insufficient, and generating attacks is much easier than defending against them. The paper proposes a framework for attack automation and offers recommendations for improving the security of APR systems.", "motivation": "Automated Program Repair (APR) systems powered by Large Language Models (LLMs) are increasingly being used in software development to automatically fix bugs reported in natural language. However, using these systems introduces a new risk: attackers could submit malicious bug reports to trick the repair system into generating insecure or harmful patches.", "method": "The authors create a threat model and empirically study the vulnerability of modern LLM-based APR systems to adversarial bug reports. They generate 51 adversarial bug reports using both manual and automated methods, then test these reports against leading APR models. They evaluate the effectiveness of various pre-repair (input filtering) and post-repair (output analysis) defenses.", "result": "The study finds that current defenses are inadequate, as 90% of adversarial bug reports successfully caused the generation of attacker-aligned (malicious) patches. The best pre-repair filter blocked only 47% of attacks, and post-repair checks (sometimes requiring human review) were only effective 58% of the time. The authors also introduce a framework for automating the generation of adversarial bug reports, highlighting that it's much cheaper and easier to create attacks than to defend against them.", "conclusion": "Existing LLM-based APR systems are highly vulnerable to adversarial bug reports, and existing defense mechanisms are not sufficient to reliably detect or prevent these attacks. The paper recommends strategies to harden APR systems against such misuse and emphasizes the need for continued research into more trustworthy automated repair solutions."}}
{"id": "2509.06794", "categories": ["cs.PL", "cs.AR", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.06794", "abs": "https://arxiv.org/abs/2509.06794", "authors": ["Shihan Fang", "Hongzheng Chen", "Niansong Zhang", "Jiajie Li", "Han Meng", "Adrian Liu", "Zhiru Zhang"], "title": "Dato: A Task-Based Programming Model for Dataflow Accelerators", "comment": null, "summary": "Recent deep learning workloads increasingly push computational demand beyond\nwhat current memory systems can sustain, with many kernels stalling on data\nmovement rather than computation. While modern dataflow accelerators\nincorporate on-chip streaming to mitigate off-chip bandwidth limitations,\nexisting programming models struggle to harness these capabilities effectively.\nLow-level interfaces provide fine-grained control but impose significant\ndevelopment overhead, whereas high-level tile-based languages abstract away\ncommunication details, restricting optimization and forcing compilers to\nreconstruct the intended dataflow. We present Dato, a Python-embedded,\ntask-based programming model for dataflow accelerators that elevates data\ncommunication and sharding to first-class type constructs. Developers write\nprograms as a graph of tasks connected via explicit stream types, with sharded\ninputs specified using layout types. These tasks are first mapped virtually\nonto the accelerator's spatial fabric, and the compiler then generates a\nphysical mapping that respects hardware constraints. Experimental results on\nboth AMD Ryzen AI NPU and Alveo FPGA devices demonstrate that Dato achieves\nhigh performance while significantly reducing the burden of writing optimized\ncode. On the NPU, Dato attains up to 84% hardware utilization for GEMM and\ndelivers a 2.81x speedup on attention kernels compared to a state-of-the-art\ncommercial framework. On the FPGA, Dato surpasses leading frameworks in\nperformance when generating custom systolic arrays, achieving 98% of the\ntheoretical peak performance.", "AI": {"tldr": "Dato provides a new Python-based programming model for dataflow accelerators, making explicit dataflow and sharding easy for developers. It achieves high performance and efficiency on commercial AI hardware, outpacing existing solutions and reducing development effort.", "motivation": "Current deep learning workloads are bottlenecked by memory and data movement, with hardware solutions underutilized due to programming model limitations. There is a need for an expressive, efficient interface balancing control and abstraction.", "method": "Dato introduces a Python-embedded, task-based programming model where developers explicitly define data communication and sharding via specialized types. The compiler maps these tasks to hardware, generating optimized physical mappings.", "result": "Experiments on AMD Ryzen AI NPU and Alveo FPGA show Dato achieves up to 84% hardware utilization and 2.81x speedup over commercial frameworks for key kernels, and attains 98% peak performance with custom systolic arrays.", "conclusion": "Dato significantly streamlines programming for dataflow accelerators, offering both high performance and a reduced development burden compared to existing frameworks."}}
{"id": "2509.05394", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.05394", "abs": "https://arxiv.org/abs/2509.05394", "authors": ["Zoltan Toth-Czifra"], "title": "Reverse Browser: Vector-Image-to-Code Generator", "comment": "Submitted to AIWare 2025 ArXiv Track", "summary": "Automating the conversion of user interface design into code (image-to-code\nor image-to-UI) is an active area of software engineering research. However,\nthe state-of-the-art solutions do not achieve high fidelity to the original\ndesign, as evidenced by benchmarks. In this work, I approach the problem\ndifferently: I use vector images instead of bitmaps as model input. I create\nseveral large datasets for training machine learning models. I evaluate the\navailable array of Image Quality Assessment (IQA) algorithms and introduce a\nnew, multi-scale metric. I then train a large open-weights model and discuss\nits limitations.", "AI": {"tldr": "The paper introduces vector image-based inputs and a new multi-scale metric for automated UI design-to-code conversion, achieving better fidelity than traditional bitmap approaches but still facing some limitations with current models.", "motivation": "Current image-to-code methods relying on bitmap inputs do not achieve high fidelity in reproducing original UI designs. This motivates the author to explore alternative approaches to improve accuracy and quality.", "method": "The researcher uses vector images as input for machine learning models in converting UI designs to code. They create large datasets, evaluate various Image Quality Assessment algorithms, introduce a new multi-scale metric, and train a large open-weight model.", "result": "By using vector images and introducing a multi-scale metric, the proposed method improves fidelity in image-to-code conversion compared to existing benchmarks, though challenges and limitations persist with the trained models.", "conclusion": "The paper concludes that using vector images as input for image-to-code tasks, along with new datasets and improved metrics, offers better fidelity to original UI designs. However, limitations remain, even with large open-weight models."}}
{"id": "2509.06845", "categories": ["cs.PL", "cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06845", "abs": "https://arxiv.org/abs/2509.06845", "authors": ["Tom Lauwaerts", "Maarten Steevens", "Christophe Scholliers"], "title": "MIO: Multiverse Debugging in the Face of Input/Output -- Extended Version with Additional Appendices", "comment": "This extended version provides auxiliary material to the article of\n  the same title that will appear in the ACM Digital Library as part of the\n  PACMPL issue for OOPSLA 2025", "summary": "Debugging non-deterministic programs on microcontrollers is notoriously\nchallenging, especially when bugs manifest in unpredictable, input-dependent\nexecution paths. A recent approach, called multiverse debugging, makes it\neasier to debug non-deterministic programs by allowing programmers to explore\nall potential execution paths. Current multiverse debuggers enable both forward\nand backward traversal of program paths, and some facilitate jumping to any\npreviously visited states, potentially branching into alternative execution\npaths within the state space.\n  Unfortunately, debugging programs that involve input/output operations using\nexisting multiverse debuggers can reveal inaccessible program states, i.e.\nstates which are not encountered during regular execution. This can\nsignificantly hinder the debugging process, as the programmer may spend\nsubstantial time exploring and examining inaccessible program states, or worse,\nmay mistakenly assume a bug is present in the code, when in fact, the issue is\ncaused by the debugger.\n  This paper presents a novel approach to multiverse debugging, which can\naccommodate a broad spectrum of input/output operations. We provide the\nsemantics of our approach and prove the correctness of our debugger, ensuring\nthat despite having support for a wide range of input/output operations the\ndebugger will only explore those program states which can be reached during\nregular execution.\n  We have developed a prototype, called MIO, leveraging the WARDuino\nWebAssembly virtual machine to demonstrate the feasibility and efficiency of\nour techniques. As a demonstration of the approach we highlight a color dial\nbuilt with a Lego Mindstorms motor, and color sensor, providing a tangible\nexample of how our approach enables multiverse debugging for programs running\non an STM32 microcontroller.", "AI": {"tldr": "A new multiverse debugging method ensures only reachable program states are explored\u2014even with complex I/O\u2014demonstrated on microcontrollers with a prototype and proof of correctness.", "motivation": "Debugging non-deterministic programs on microcontrollers is particularly difficult when bugs relate to unpredictable or input-dependent paths, and current multiverse debuggers further introduce the problem of exposing inaccessible program states during I/O operations.", "method": "The paper proposes a novel approach to multiverse debugging that provides semantics and proof of correctness such that only accessible (reachable) program states are explored, even in the presence of complex I/O operations. The authors developed a prototype called MIO based on the WARDuino WebAssembly virtual machine.", "result": "Their debugger avoids exploring unreachable states, supporting a broad spectrum of I/O, and is demonstrated on a tangible example using a color dial built with Lego Mindstorms hardware and an STM32 microcontroller.", "conclusion": "Their approach provides efficient, correct multiverse debugging on microcontrollers with comprehensive I/O, avoiding pitfalls of existing tools and only exploring states that are possible in real program runs."}}
{"id": "2509.05540", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.05540", "abs": "https://arxiv.org/abs/2509.05540", "authors": ["Thiago Barradas", "Aline Paes", "V\u00e2nia de Oliveira Neves"], "title": "Combining TSL and LLM to Automate REST API Testing: A Comparative Study", "comment": "10 pages, article computer science, software engineering, software\n  testing, ia, llm", "summary": "The effective execution of tests for REST APIs remains a considerable\nchallenge for development teams, driven by the inherent complexity of\ndistributed systems, the multitude of possible scenarios, and the limited time\navailable for test design. Exhaustive testing of all input combinations is\nimpractical, often resulting in undetected failures, high manual effort, and\nlimited test coverage. To address these issues, we introduce RestTSLLM, an\napproach that uses Test Specification Language (TSL) in conjunction with Large\nLanguage Models (LLMs) to automate the generation of test cases for REST APIs.\nThe approach targets two core challenges: the creation of test scenarios and\nthe definition of appropriate input data. The proposed solution integrates\nprompt engineering techniques with an automated pipeline to evaluate various\nLLMs on their ability to generate tests from OpenAPI specifications. The\nevaluation focused on metrics such as success rate, test coverage, and mutation\nscore, enabling a systematic comparison of model performance. The results\nindicate that the best-performing LLMs - Claude 3.5 Sonnet (Anthropic),\nDeepseek R1 (Deepseek), Qwen 2.5 32b (Alibaba), and Sabia 3 (Maritaca) -\nconsistently produced robust and contextually coherent REST API tests. Among\nthem, Claude 3.5 Sonnet outperformed all other models across every metric,\nemerging in this study as the most suitable model for this task. These findings\nhighlight the potential of LLMs to automate the generation of tests based on\nAPI specifications.", "AI": {"tldr": "RestTSLLM leverages TSL and LLMs for automating REST API test generation. In evaluations, Claude 3.5 Sonnet proved to be the best performer in test success rate, coverage, and robustness, demonstrating LLMs' promise for API test automation.", "motivation": "Testing REST APIs is challenging due to distributed system complexity, numerous scenario possibilities, and limited resources. Existing approaches rely on exhaustive manual efforts, which are inefficient and often miss failures.", "method": "RestTSLLM is introduced, combining Test Specification Language (TSL) and Large Language Models (LLMs) to generate automated REST API test cases. Prompt engineering and a fully automated pipeline are employed to assess and compare various LLMs using OpenAPI specifications.", "result": "Among the tested models, Claude 3.5 Sonnet delivered the highest success rate, test coverage, and mutation score, outperforming Deepseek R1, Qwen 2.5 32b, and Sabia 3, showing robust and contextually coherent test generation.", "conclusion": "LLMs, particularly Claude 3.5 Sonnet, are effective at automating REST API test generation, highlighting their potential to improve software quality and test coverage with reduced manual intervention."}}
{"id": "2509.06872", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.06872", "abs": "https://arxiv.org/abs/2509.06872", "authors": ["Zachary Kent", "Ugur Y. Yavuz", "Siddhartha Jayanti", "Stephanie Balzer", "Guy Blelloch"], "title": "Mechanized Metatheory of Forward Reasoning for End-to-End Linearizability Proofs", "comment": null, "summary": "In the past decade, many techniques have been developed to prove\nlinearizability, the gold standard of correctness for concurrent data\nstructures. Intuitively, linearizability requires that every operation on a\nconcurrent data structure appears to take place instantaneously, even when\ninterleaved with other operations. Most recently, Jayanti et al. presented the\nfirst sound and complete \"forward reasoning\" technique for proving\nlinearizability that relates the behavior of a concurrent data structure to a\nreference atomic data structure as time moves forward. This technique can be\nused to produce machine-checked proofs of linearizability in TLA+. However,\nwhile Jayanti et al.'s approach is shown to be sound and complete, a\nmechanization of this important metatheoretic result is still outstanding. As a\nresult, it is not possible to produce verified end-to-end proofs of\nlinearizability. To reduce the size of this trusted computing base, we\nformalize this forward reasoning technique and mechanize proofs of its\nsoundness and completeness in Rocq. As a case study, we use the approach to\nproduce a verified end-to-end proof of linearizability for a simple concurrent\nregister.", "AI": {"tldr": "The paper mechanizes and formally verifies a key forward reasoning technique for proving linearizability of concurrent data structures, demonstrating its effectiveness through a verified proof for a simple concurrent register.", "motivation": "Linearizability is a key correctness property for concurrent data structures, but fully verified, end-to-end proofs remain challenging. Although forward reasoning techniques are promising, mechanized and formally verified metatheoretic results are missing.", "method": "The paper formalizes Jayanti et al.'s forward reasoning technique for proving linearizability and mechanizes its soundness and completeness proofs using Rocq. As a demonstration, a verified proof for a concurrent register is constructed.", "result": "The authors provide formalization and mechanization of the soundness and completeness proofs for forward reasoning in Rocq. They successfully produce a verified, end-to-end proof of linearizability for a concurrent register as a case study.", "conclusion": "This work reduces the trusted computing base for verifying linearizability by mechanizing crucial metatheoretic results, paving the way for fully verified proofs of concurrent data structures."}}
{"id": "2509.05585", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.05585", "abs": "https://arxiv.org/abs/2509.05585", "authors": ["Zhiyuan Zou", "Bangchao Wang", "Peng Liang", "Tingting Bi", "Huan Jin"], "title": "Natural Language-Programming Language Software Traceability Link Recovery Needs More than Textual Similarity", "comment": "45 pages, 5 images, 11 tables, Manuscript submitted to a Journal\n  (2025)", "summary": "In the field of software traceability link recovery (TLR), textual similarity\nhas long been regarded as the core criterion. However, in tasks involving\nnatural language and programming language (NL-PL) artifacts, relying solely on\ntextual similarity is limited by their semantic gap. To this end, we conducted\na large-scale empirical evaluation across various types of TLR tasks, revealing\nthe limitations of textual similarity in NL-PL scenarios. To address these\nlimitations, we propose an approach that incorporates multiple domain-specific\nauxiliary strategies, identified through empirical analysis, into two models:\nthe Heterogeneous Graph Transformer (HGT) via edge types and the prompt-based\nGemini 2.5 Pro via additional input information. We then evaluated our approach\nusing the widely studied requirements-to-code TLR task, a representative case\nof NL-PL TLR. Experimental results show that both the multi-strategy HGT and\nGemini 2.5 Pro models outperformed their original counterparts without strategy\nintegration. Furthermore, compared to the current state-of-the-art method\nHGNNLink, the multi-strategy HGT and Gemini 2.5 Pro models achieved average\nF1-score improvements of 3.68% and 8.84%, respectively, across twelve\nopen-source projects, demonstrating the effectiveness of multi-strategy\nintegration in enhancing overall model performance for the requirements-code\nTLR task.", "AI": {"tldr": "Traditional textual similarity-based TLR struggles with NL-PL tasks due to a semantic gap. This paper introduces multi-strategy models based on empirical analysis and demonstrates that integrating domain-specific auxiliary strategies boosts performance over current methods, showing notable F1-score improvements on open-source projects.", "motivation": "Textual similarity has traditionally been the main technique used for software traceability link recovery (TLR). However, this method struggles with tasks involving both natural language and programming language (NL-PL) artifacts due to a semantic gap between the two. There is a need for improved techniques that can overcome these limitations.", "method": "The authors perform a large-scale empirical evaluation to identify limitations of textual similarity in NL-PL scenarios. They then propose integrating multiple domain-specific auxiliary strategies into two models: the Heterogeneous Graph Transformer (HGT) using edge types, and the prompt-based Gemini 2.5 Pro via enhanced input. The new approaches are evaluated on requirements-to-code TLR tasks.", "result": "Both the multi-strategy HGT and Gemini 2.5 Pro models outperform their baseline versions without auxiliary strategies. Compared to the state-of-the-art HGNNLink method, multi-strategy HGT and Gemini 2.5 Pro achieve average F1-score increases of 3.68% and 8.84%, respectively, on twelve open-source projects.", "conclusion": "Multi-strategy integration significantly improves model performance for requirements-to-code traceability link recovery, especially in NL-PL scenarios. The proposed methods surpass baseline models and state-of-the-art techniques."}}
{"id": "2509.05596", "categories": ["cs.SE", "cs.SC", "68", "D.3.1; D.2.4"], "pdf": "https://arxiv.org/pdf/2509.05596", "abs": "https://arxiv.org/abs/2509.05596", "authors": ["Soumyadip Bandyopadhyay", "Santonu Sarkar"], "title": "Verifying Correctness of PLC Software during System Evolution using Model Containment Approach", "comment": "31 pages with appendix", "summary": "Upgradation of Programmable Logic Controller (PLC) software is quite common\nto accommodate evolving industrial requirements. Verifying the correctness of\nsuch upgrades remains a significant challenge. In this paper, we propose a\nverification-based approach to ensure the correctness of the existing\nfunctionality in the upgraded version of a PLC software. The method converts\nthe older and the newer versions of the sequential function chart (SFC) into\ntwo Petri net models. We then verify whether one model is contained within\nanother, based on a novel containment checking algorithm grounded in symbolic\npath equivalence. For this purpose, we have developed a home-grown Petri\nnet-based containment checker. Experimental evaluation on 80 real-world\nbenchmarks from the OSCAT library highlights the scalability and effectiveness\nof the framework. We have compared our approach with verifAPS, a popular tool\nused for software upgradation, and observed nearly 4x performance improvement.", "AI": {"tldr": "This paper presents a novel method that uses Petri net models and symbolic path equivalence to efficiently verify the correctness of upgraded PLC software, showing significant performance gains over standard tools on real benchmarks.", "motivation": "Upgrading PLC software is necessary for evolving industrial needs, but ensuring the correctness of such upgrades is difficult. Industrial users need reliable methods to verify that updates do not break existing functionality.", "method": "The approach involves converting both the original and upgraded PLC software versions from sequential function charts (SFC) into Petri net models. A novel containment checking algorithm based on symbolic path equivalence is used to verify if the functionality of the older version is contained within the new one. A custom Petri net-based checker is developed for this purpose.", "result": "Experimental evaluation was conducted using 80 real-world benchmarks from the OSCAT library. The framework showed strong scalability and effectiveness. When compared to the verifAPS tool, the proposed method was nearly 4 times faster.", "conclusion": "The proposed verification-based method is effective and scalable for ensuring the correctness of PLC software upgrades, outperforming existing popular tools by a significant margin."}}
{"id": "2509.05749", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.05749", "abs": "https://arxiv.org/abs/2509.05749", "authors": ["AmirHossein Naghshzan"], "title": "Automating API Documentation with LLMs: A BERTopic Approach", "comment": null, "summary": "Developers rely on API documentation, but official sources are often lengthy,\ncomplex, or incomplete. Many turn to community-driven forums like Stack\nOverflow for practical insights. We propose automating the summarization of\ninformal sources, focusing on Android APIs. Using BERTopic, we extracted\nprevalent topics from 3.6 million Stack Overflow posts and applied extractive\nsummarization techniques to generate concise summaries, including code\nsnippets. A user study with 30 Android developers assessed the summaries for\ncoherence, relevance, informativeness, and satisfaction, showing improved\nproductivity. Integrating formal API knowledge with community-generated content\nenhances documentation, making API resources more accessible and actionable\nwork.", "AI": {"tldr": "This paper demonstrates that automated summarization of Stack Overflow content can complement official Android API documentation, making it more useful and accessible for developers.", "motivation": "Official API documentation is often too lengthy, complex, or lacks practical examples, prompting developers to seek help from community sources like Stack Overflow.", "method": "The authors used BERTopic to extract prevalent topics from 3.6 million Stack Overflow posts about Android APIs. They then applied extractive summarization to these posts, creating concise summaries with code snippets. A user study with 30 Android developers evaluated the generated summaries.", "result": "The generated summaries were found to be coherent, relevant, informative, and satisfactory in the user study. Developers reported improved productivity using these summaries.", "conclusion": "Combining formal API documentation with summaries generated from community-driven content makes API resources more accessible and actionable, enhancing developer productivity and satisfaction."}}
{"id": "2509.05769", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.05769", "abs": "https://arxiv.org/abs/2509.05769", "authors": ["Edyta Brzychczy", "Urszula Jessen", "Krzysztof Kluza", "Sridhar Sriram", "Manuel Vargas Nettelnstroth"], "title": "IoT Miner: Intelligent Extraction of Event Logs from Sensor Data for Process Mining", "comment": "17 pages, conference draft", "summary": "This paper presents IoT Miner, a novel framework for automatically creating\nhigh-level event logs from raw industrial sensor data to support process\nmining. In many real-world settings, such as mining or manufacturing, standard\nevent logs are unavailable, and sensor data lacks the structure and semantics\nneeded for analysis. IoT Miner addresses this gap using a four-stage pipeline:\ndata preprocessing, unsupervised clustering, large language model (LLM)-based\nlabeling, and event log construction. A key innovation is the use of LLMs to\ngenerate meaningful activity labels from cluster statistics, guided by\ndomain-specific prompts. We evaluate the approach on sensor data from a\nLoad-Haul-Dump (LHD) mining machine and introduce a new metric,\nSimilarity-Weighted Accuracy, to assess labeling quality. Results show that\nricher prompts lead to more accurate and consistent labels. By combining AI\nwith domain-aware data processing, IoT Miner offers a scalable and\ninterpretable method for generating event logs from IoT data, enabling process\nmining in settings where traditional logs are missing.", "AI": {"tldr": "IoT Miner leverages AI to automatically transform raw industrial sensor data into usable event logs for process mining, using LLM-based labeling and a four-stage pipeline, shown to work well with mining equipment data.", "motivation": "In many industrial environments, event logs crucial for process mining are absent, and raw sensor data lacks structure and semantics, making analysis difficult.", "method": "IoT Miner is introduced as a four-stage framework: (1) data preprocessing, (2) unsupervised clustering of sensor data, (3) activity labeling using large language models (LLMs) with domain-specific prompts, and (4) event log construction.", "result": "Evaluation on mining machine sensor data showed that richer, domain-specific prompts improve label accuracy and consistency. A new metric, Similarity-Weighted Accuracy, is proposed to measure labeling quality.", "conclusion": "IoT Miner successfully generates interpretable, structured event logs from raw sensor data, using AI techniques to fill the absence of standard logs. This enables process mining in previously inaccessible industrial settings."}}
{"id": "2509.05881", "categories": ["cs.SE", "cs.AI", "I.2"], "pdf": "https://arxiv.org/pdf/2509.05881", "abs": "https://arxiv.org/abs/2509.05881", "authors": ["Qianheng Zhang", "Song Gao", "Chen Wei", "Yibo Zhao", "Ying Nie", "Ziru Chen", "Shijie Chen", "Yu Su", "Huan Sun"], "title": "GeoAnalystBench: A GeoAI benchmark for assessing large language models for spatial analysis workflow and code generation", "comment": "34 pages, 8 figures", "summary": "Recent advances in large language models (LLMs) have fueled growing interest\nin automating geospatial analysis and GIS workflows, yet their actual\ncapabilities remain uncertain. In this work, we call for rigorous evaluation of\nLLMs on well-defined geoprocessing tasks before making claims about full GIS\nautomation. To this end, we present GeoAnalystBench, a benchmark of 50\nPython-based tasks derived from real-world geospatial problems and carefully\nvalidated by GIS experts. Each task is paired with a minimum deliverable\nproduct, and evaluation covers workflow validity, structural alignment,\nsemantic similarity, and code quality (CodeBLEU). Using this benchmark, we\nassess both proprietary and open source models. Results reveal a clear gap:\nproprietary models such as ChatGPT-4o-mini achieve high validity 95% and\nstronger code alignment (CodeBLEU 0.39), while smaller open source models like\nDeepSeek-R1-7B often generate incomplete or inconsistent workflows (48.5%\nvalidity, 0.272 CodeBLEU). Tasks requiring deeper spatial reasoning, such as\nspatial relationship detection or optimal site selection, remain the most\nchallenging across all models. These findings demonstrate both the promise and\nlimitations of current LLMs in GIS automation and provide a reproducible\nframework to advance GeoAI research with human-in-the-loop support.", "AI": {"tldr": "GeoAnalystBench, a new benchmark for evaluating LLMs on GIS automation tasks, shows proprietary models outperform open source ones, but spatial reasoning tasks remain hard for all. The study provides a framework for future GeoAI research with human-in-the-loop support.", "motivation": "Recent advances in LLMs suggest great potential for automating geospatial analysis and GIS workflows, but there is uncertainty about their actual abilities. Rigorous evaluation is needed before claims about full GIS automation can be made.", "method": "Researchers developed GeoAnalystBench, a benchmark of 50 Python-based geoprocessing tasks from real-world GIS problems, validated by GIS experts. Each task specifies deliverable products and is evaluated for workflow validity, structural alignment, semantic similarity, and code quality (CodeBLEU). Both proprietary and open source LLMs were assessed using this benchmark.", "result": "Proprietary models like ChatGPT-4o-mini showed high workflow validity (95%) and stronger code quality (CodeBLEU 0.39), while smaller open source models like DeepSeek-R1-7B performed less well (48.5% validity, 0.272 CodeBLEU). Tasks involving deep spatial reasoning remain challenging for all models.", "conclusion": "Current LLMs show potential but also significant limitations in GIS automation. The benchmark created offers a reproducible way to further GeoAI research with human guidance."}}
{"id": "2509.05941", "categories": ["cs.SE", "cs.LG", "cs.MA"], "pdf": "https://arxiv.org/pdf/2509.05941", "abs": "https://arxiv.org/abs/2509.05941", "authors": ["Chaoqian Ouyang", "Ling Yue", "Shimin Di", "Libin Zheng", "Shaowu Pan", "Min-Ling Zhang"], "title": "Code2MCP: A Multi-Agent Framework for Automated Transformation of Code Repositories into Model Context Protocol Services", "comment": null, "summary": "The proliferation of Large Language Models (LLMs) has created a significant\nintegration challenge in the AI agent ecosystem, often called the \"$N \\times M$\nproblem,\" where N models require custom integrations for M tools. This\nfragmentation stifles innovation and creates substantial development overhead.\nWhile the Model Context Protocol (MCP) has emerged as a standard to resolve\nthis, its adoption is hindered by the manual effort required to convert the\nvast universe of existing software into MCP-compliant services. This is\nespecially true for the millions of open-source repositories on GitHub, the\nworld's largest collection of functional code. This paper introduces Code2MCP,\na highly automated, agentic framework designed to transform any GitHub\nrepository into a functional MCP service with minimal human intervention. Our\nsystem employs a multi-stage workflow that automates the entire process, from\ncode analysis and environment configuration to service generation and\ndeployment. A key innovation of our framework is an LLM-driven, closed-loop\n\"Run--Review--Fix\" cycle, which enables the system to autonomously debug and\nrepair the code it generates. Code2MCP produces not only deployable services\nbut also comprehensive technical documentation, acting as a catalyst to\naccelerate the MCP ecosystem by systematically unlocking the world's largest\nopen-source code repository and automating the critical last mile of tool\nintegration. The code is open-sourced at\nhttps://github.com/DEFENSE-SEU/MCP-Github-Agent.", "AI": {"tldr": "Paper presents Code2MCP, an automated framework using LLMs to convert any GitHub repo into an MCP-compliant service, handling everything from code analysis to deployment with minimal human input. The system includes self-debugging and documentation generation, directly tackling the $N\\times M$ integration challenge in AI agent ecosystems and promoting widespread MCP adoption. Code is open-sourced for broader impact.", "motivation": "Large Language Models (LLMs) face a major bottleneck in the AI agent ecosystem due to the integration challenge known as the \"$N \\times M$ problem\": every model needs custom integration for each tool, causing fragmentation, stifling innovation, and requiring significant development resources. While the Model Context Protocol (MCP) could resolve this, its adoption is limited because converting existing software to MCP-compliant services is labor-intensive, especially across millions of GitHub repositories.", "method": "The authors propose Code2MCP, an agentic, highly automated framework that transforms any GitHub repository into an MCP-compliant service with minimal human input. The system uses a multi-stage workflow that automates code analysis, environment setup, service generation, and deployment. It introduces an LLM-driven, closed-loop Run--Review--Fix cycle for autonomous debugging and code repair, and also produces comprehensive documentation.", "result": "Code2MCP successfully enables automated, scalable conversion of GitHub repositories into MCP services, including deployable code and technical documentation. The framework demonstrates significant reduction in manual overhead for integration, accelerating MCP ecosystem growth by unlocking open-source code repositories and automating tool integration. The open-source code is made available for public use and further development.", "conclusion": "The Code2MCP framework substantially reduces the integration barrier for LLMs in the AI agent ecosystem by automating the transition of open-source projects to MCP-compliant services, thereby addressing the $N \\times M$ problem and accelerating standard protocol adoption. The approach's automation and open-sourcing have the potential to revolutionize tool integration and ecosystem growth."}}
{"id": "2509.05980", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.05980", "abs": "https://arxiv.org/abs/2509.05980", "authors": ["Xingliang Wang", "Baoyi Wang", "Chen Zhi", "Junxiao Han", "Xinkui Zhao", "Jianwei Yin", "Shuiguang Deng"], "title": "GRACE: Graph-Guided Repository-Aware Code Completion through Hierarchical Code Fusion", "comment": null, "summary": "LLMs excel in localized code completion but struggle with repository-level\ntasks due to limited context windows and complex semantic and structural\ndependencies across codebases. While Retrieval-Augmented Generation (RAG)\nmitigates context scarcity by retrieving relevant code snippets, current\napproaches face significant limitations. They overly rely on textual similarity\nfor retrieval, neglecting structural relationships such as call chains and\ninheritance hierarchies, and lose critical structural information by naively\nconcatenating retrieved snippets into text sequences for LLM input. To address\nthese shortcomings, GRACE constructs a multi-level, multi-semantic code graph\nthat unifies file structures, abstract syntax trees, function call graphs,\nclass hierarchies, and data flow graphs to capture both static and dynamic code\nsemantics. For retrieval, GRACE employs a Hybrid Graph Retriever that\nintegrates graph neural network-based structural similarity with textual\nretrieval, refined by a graph attention network-based re-ranker to prioritize\ntopologically relevant subgraphs. To enhance context, GRACE introduces a\nstructural fusion mechanism that merges retrieved subgraphs with the local code\ncontext and preserves essential dependencies like function calls and\ninheritance. Extensive experiments on public repository-level benchmarks\ndemonstrate that GRACE significantly outperforms state-of-the-art methods\nacross all metrics. Using DeepSeek-V3 as the backbone LLM, GRACE surpasses the\nstrongest graph-based RAG baselines by 8.19% EM and 7.51% ES points on every\ndataset. The code is available at\nhttps://anonymous.4open.science/r/grace_icse-C3D5.", "AI": {"tldr": "GRACE innovates repository-level code completion for LLMs by combining multi-level code graphs and hybrid graph retrieval, outperforming prior methods and addressing context and structure limitations in previous RAG approaches.", "motivation": "Current LLM-based code completion tools perform poorly at repository level due to limited context and complex codebase dependencies. RAG partially helps, but state-of-the-art methods ignore structural relationships and context fusion.", "method": "GRACE constructs unified code graphs combining file structure, ASTs, call graphs, class hierarchies, and data flow. It uses a Hybrid Graph Retriever (GNN and textual retriever), a graph attention re-ranker, and a structural fusion mechanism to merge retrieved subgraphs with local code, preserving key dependencies.", "result": "GRACE, using DeepSeek-V3, surpasses state-of-the-art graph-RAG baselines by 8.19% EM and 7.51% ES on every public benchmark dataset tested, indicating robust improvement in repository-level code completion and understanding.", "conclusion": "GRACE\u2014by integrating multi-level code graphs and hybrid graph retrieval\u2014overcomes the limitations of textual-similarity-based retrieval and naive snippet concatenation, achieving significant performance gains over existing methods."}}
{"id": "2509.05995", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.05995", "abs": "https://arxiv.org/abs/2509.05995", "authors": ["Sharon Guardado", "Risha Parveen", "Zheying Zhang", "Maruf Rayhan", "Nirnaya Tripathi"], "title": "Students' Perception of LLM Use in Requirements Engineering Education: An Empirical Study Across Two Universities", "comment": "Accepted by the 33rd IEEE International Requirements Engineering 2025\n  (RE'25), Valencia, Spain, September 1-5, 2025", "summary": "The integration of Large Language Models (LLMs) in Requirements Engineering\n(RE) education is reshaping pedagogical approaches, seeking to enhance student\nengagement and motivation while providing practical tools to support their\nprofessional future. This study empirically evaluates the impact of integrating\nLLMs in RE coursework. We examined how the guided use of LLMs influenced\nstudents' learning experiences, and what benefits and challenges they perceived\nin using LLMs in RE practices. The study collected survey data from 179\nstudents across two RE courses in two universities. LLMs were integrated into\ncoursework through different instructional formats, i.e., individual\nassignments versus a team-based Agile project. Our findings indicate that LLMs\nimproved students' comprehension of RE concepts, particularly in tasks like\nrequirements elicitation and documentation. However, students raised concerns\nabout LLMs in education, including academic integrity, overreliance on AI, and\nchallenges in integrating AI-generated content into assignments. Students who\nworked on individual assignments perceived that they benefited more than those\nwho worked on team-based assignments, highlighting the importance of contextual\nAI integration. This study offers recommendations for the effective integration\nof LLMs in RE education. It proposes future research directions for balancing\nAI-assisted learning with critical thinking and collaborative practices in RE\ncourses.", "AI": {"tldr": "Integrating LLMs into RE education boosts student comprehension but raises concerns about academic integrity and overreliance. Context and assignment type matter; more research is needed to balance AI's benefits with critical and collaborative learning.", "motivation": "Educators aim to improve student engagement and the practical value of Requirements Engineering (RE) courses by integrating Large Language Models (LLMs) into the curriculum. As AI tools become prevalent in professional practices, there is a need to assess both benefits and challenges in educational settings, guiding effective adoption of LLMs in RE education.", "method": "The study empirically evaluated the integration of LLMs in RE coursework by collecting survey data from 179 students across two RE courses at different universities. The research compared individual assignments with team-based Agile projects to analyze experiences and perceptions of LLM use.", "result": "LLM integration improved students' understanding of RE concepts, especially in requirements elicitation and documentation. However, concerns emerged about academic integrity, overreliance on AI, and difficulties incorporating AI-generated content. Individual assignments yielded greater perceived benefits than team-based work.", "conclusion": "LLMs can enhance student comprehension in RE education, but careful, context-aware integration is vital. Attention must be paid to academic integrity and fostering critical thinking. Recommendations are offered for future course design, and further research is needed on balancing AI support with collaborative and critical learning practices."}}
{"id": "2509.06012", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06012", "abs": "https://arxiv.org/abs/2509.06012", "authors": ["Jukka Ruohonen"], "title": "A Rapid Review Regarding the Concept of Legal Requirements in Requirements Engineering", "comment": "Submitted to REFSQ 2026", "summary": "Out of a personal puzzlement, recent peer review comments, and demonstrable\nconfusion in the existing literature, the paper presents a rapid review of the\nconcept of legal requirements (LRs) in requirements engineering (RE) research.\nAccording to reviewing results, a normative understanding of LRs has often been\npresent, although proper definitions and conceptual operationalizations are\nlacking. Some papers also see LRs as functional and others as non-functional\nrequirements. Legal requirements are often characterized as being vague and\ncomplex, requiring a lot of effort to elicit, implement, and validate. These\ncharacterizations supposedly correlate with knowledge gaps among requirements\nengineers. LRs are also seen to often change and overlap. They may be also\nprioritized. According to the literature, they seem to be also reluctantly\nimplemented, often providing only a minimal baseline for other requirements.\nWith these and other observations, the review raises critical arguments about\napparent knowledge gaps, including a lack of empirical evidence backing the\nobservations and enduring conceptual confusion.", "AI": {"tldr": "The paper reviews literature on legal requirements in requirements engineering, finding a lack of clear definitions, conceptual confusion, and little empirical evidence, arguing that the field needs better clarity and understanding of LRs.", "motivation": "The motivation for this paper is to address the confusion and conceptual misunderstanding surrounding legal requirements (LRs) in requirements engineering (RE) research, stemming from personal observation, peer review feedback, and literature review.", "method": "The paper conducts a rapid literature review on the treatment and conception of legal requirements in RE research.", "result": "The review finds that normative understandings of LRs predominate but lack proper definitions and clear operationalization. LRs are inconsistently classified as functional or non-functional, often described as vague, complex, and difficult to handle. The literature suggests these problems are linked to knowledge gaps among RE practitioners, and that LRs are frequently reluctantly implemented and poorly prioritized. There is an evident lack of empirical evidence and ongoing conceptual confusion in the field.", "conclusion": "There is significant conceptual confusion and lack of empirical grounding regarding legal requirements in RE research. The understanding and implementation of LRs are inconsistent, and there is a pressing need for clearer definitions, empirical studies, and improved conceptual clarity."}}
{"id": "2509.06052", "categories": ["cs.SE", "cs.AI", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.06052", "abs": "https://arxiv.org/abs/2509.06052", "authors": ["Qingyuan Li", "Binchang Li", "Cuiyun Gao", "Shuzheng Gao", "Zongjie Li"], "title": "Empirical Study of Code Large Language Models for Binary Security Patch Detection", "comment": null, "summary": "Security patch detection (SPD) is crucial for maintaining software security,\nas unpatched vulnerabilities can lead to severe security risks. In recent\nyears, numerous learning-based SPD approaches have demonstrated promising\nresults on source code. However, these approaches typically cannot be applied\nto closed-source applications and proprietary systems that constitute a\nsignificant portion of real-world software, as they release patches only with\nbinary files, and the source code is inaccessible. Given the impressive\nperformance of code large language models (LLMs) in code intelligence and\nbinary analysis tasks such as decompilation and compilation optimization, their\npotential for detecting binary security patches remains unexplored, exposing a\nsignificant research gap between their demonstrated low-level code\nunderstanding capabilities and this critical security task. To address this\ngap, we construct a large-scale binary patch dataset containing \\textbf{19,448}\nsamples, with two levels of representation: assembly code and pseudo-code, and\nsystematically evaluate \\textbf{19} code LLMs of varying scales to investigate\ntheir capability in binary SPD tasks. Our initial exploration demonstrates that\ndirectly prompting vanilla code LLMs struggles to accurately identify security\npatches from binary patches, and even state-of-the-art prompting techniques\nfail to mitigate the lack of domain knowledge in binary SPD within vanilla\nmodels. Drawing on the initial findings, we further investigate the fine-tuning\nstrategy for injecting binary SPD domain knowledge into code LLMs through two\nlevels of representation. Experimental results demonstrate that fine-tuned LLMs\nachieve outstanding performance, with the best results obtained on the\npseudo-code representation.", "AI": {"tldr": "Existing learning-based SPD methods don't work for closed-source, binary-only software. Code LLMs can't detect security patches in binaries without fine-tuning. The authors created a large binary patch dataset and showed that fine-tuned LLMs\u2014especially with pseudo-code\u2014excel at binary SPD, closing a critical security gap.", "motivation": "Many existing learning-based approaches for security patch detection (SPD) work only on source code, limiting their applicability to open-source software. However, much of the real-world software is closed-source and ships only binary patches, leaving vulnerabilities unaddressed in such cases. There is a research gap in using code large language models (LLMs) for detecting security patches in binary files, despite their demonstrated capabilities in related tasks.", "method": "The authors constructed a large-scale binary patch dataset (19,448 samples) with assembly code and pseudo-code representations. They systematically evaluated 19 different code LLMs for binary SPD using both direct prompting and fine-tuning methods. They analyzed model performance with both representations and tested state-of-the-art prompting techniques and fine-tuning strategies to inject SPD-specific domain knowledge into the models.", "result": "Directly prompting vanilla code LLMs\u2014even with advanced prompting techniques\u2014was ineffective for binary SPD due to insufficient domain knowledge. Fine-tuning code LLMs with domain-specific data (on both assembly and pseudo-code) substantially improved their performance, with the best results on pseudo-code representations.", "conclusion": "While code LLMs show promise for binary security patch detection, vanilla models lack the required domain knowledge. Fine-tuning with binary patch data, especially in pseudo-code format, enables code LLMs to achieve excellent performance, bridging a key security gap for closed-source and binary-only software."}}
{"id": "2509.06085", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.06085", "abs": "https://arxiv.org/abs/2509.06085", "authors": ["Jerin Yasmin", "Wenxin Jiang", "James C. Davis", "Yuan Tian"], "title": "Software Dependencies 2.0: An Empirical Study of Reuse and Integration of Pre-Trained Models in Open-Source Projects", "comment": "Submitted to Empirical Software Engineering (EMSE) Journal", "summary": "Pre-trained models (PTMs) are machine learning models that have been trained\nin advance, often on large-scale data, and can be reused for new tasks, thereby\nreducing the need for costly training from scratch. Their widespread adoption\nintroduces a new class of software dependency, which we term Software\nDependencies 2.0, extending beyond conventional libraries to learned behaviors\nembodied in trained models and their associated artifacts. The integration of\nPTMs as software dependencies in real projects remains unclear, potentially\nthreatening maintainability and reliability of modern software systems that\nincreasingly rely on them. Objective: In this study, we investigate Software\nDependencies 2.0 in open-source software (OSS) projects by examining the reuse\nof PTMs, with a focus on how developers manage and integrate these models.\nSpecifically, we seek to understand: (1) how OSS projects structure and\ndocument their PTM dependencies; (2) what stages and organizational patterns\nemerge in the reuse pipelines of PTMs within these projects; and (3) the\ninteractions among PTMs and other learned components across pipeline stages. We\nconduct a mixed-methods analysis of a statistically significant random sample\nof 401 GitHub repositories from the PeaTMOSS dataset (28,575 repositories\nreusing PTMs from Hugging Face and PyTorch Hub). We quantitatively examine PTM\nreuse by identifying patterns and qualitatively investigate how developers\nintegrate and manage these models in practice.", "AI": {"tldr": "This paper studies how open-source projects reuse and manage pre-trained models (PTMs) as a new type of software dependency, analyzing patterns and developer practices using a large GitHub dataset. It finds diverse management strategies and highlights unique challenges posed by PTMs compared to traditional dependencies.", "motivation": "The motivation stems from the increasing adoption of pre-trained models (PTMs) in software projects, creating a new type of software dependency. These dependencies differ from traditional ones, representing learned behaviors and artifacts, raising concerns about software maintainability and reliability.", "method": "The study utilizes a mixed-methods approach, analyzing a random sample of 401 GitHub repositories from the PeaTMOSS dataset. It combines quantitative identification of PTM reuse patterns with qualitative investigation into developers' integration and management of these models.", "result": "The research finds various ways OSS projects structure and document PTM dependencies, revealing distinct stages and organizational patterns in PTM reuse pipelines. It also uncovers complex interactions between PTMs and other learned components across pipeline stages.", "conclusion": "The integration of PTMs as software dependencies introduces new challenges for maintainability and reliability in modern software systems. Understanding how OSS projects manage these dependencies is crucial for supporting sustainable software development."}}
{"id": "2509.06216", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.06216", "abs": "https://arxiv.org/abs/2509.06216", "authors": ["Ahmed E. Hassan", "Hao Li", "Dayi Lin", "Bram Adams", "Tse-Hsun Chen", "Yutaro Kashiwa", "Dong Qiu"], "title": "Agentic Software Engineering: Foundational Pillars and a Research Roadmap", "comment": null, "summary": "Agentic Software Engineering (SE 3.0) represents a new era where intelligent\nagents are tasked not with simple code generation, but with achieving complex,\ngoal-oriented SE objectives. To harness these new capabilities while ensuring\ntrustworthiness, we must recognize a fundamental duality within the SE field in\nthe Agentic SE era, comprising two symbiotic modalities: SE for Humans and SE\nfor Agents. This duality demands a radical reimagining of the foundational\npillars of SE (actors, processes, tools, and artifacts) which manifest\ndifferently across each modality. We propose two purpose-built workbenches to\nsupport this vision. The Agent Command Environment (ACE) serves as a command\ncenter where humans orchestrate and mentor agent teams, handling outputs such\nas Merge-Readiness Packs (MRPs) and Consultation Request Packs (CRPs). The\nAgent Execution Environment (AEE) is a digital workspace where agents perform\ntasks while invoking human expertise when facing ambiguity or complex\ntrade-offs. This bi-directional partnership, which supports agent-initiated\nhuman callbacks and handovers, gives rise to new, structured engineering\nactivities (i.e., processes) that redefine human-AI collaboration, elevating\nthe practice from agentic coding to true agentic software engineering. This\npaper presents the Structured Agentic Software Engineering (SASE) vision,\noutlining several of the foundational pillars for the future of SE. The paper\nculminates in a research roadmap that identifies a few key challenges and\nopportunities while briefly discussing the resulting impact of this future on\nSE education. Our goal is not to offer a definitive solution, but to provide a\nconceptual scaffold with structured vocabulary to catalyze a community-wide\ndialogue, pushing the SE community to think beyond its classic, human-centric\ntenets toward a disciplined, scalable, and trustworthy agentic future.", "AI": {"tldr": "This paper introduces the vision of Agentic Software Engineering (SE 3.0), promoting a dual approach of SE for humans and SE for agents. It proposes new frameworks, tools, and processes for structured human-AI collaboration in software engineering, and outlines a research roadmap to guide the community toward a scalable and trustworthy agentic future.", "motivation": "The motivation of this paper is to address the emerging era of Agentic Software Engineering (SE 3.0), where intelligent agents not only assist with code generation but are also responsible for achieving broader, complex SE objectives. There is a need to rethink the foundational aspects of software engineering to accommodate and leverage these agentic capabilities while ensuring trust and reliability.", "method": "The paper proposes a conceptual framework for Agentic Software Engineering, centered around a dual-modality approach: SE for Humans and SE for Agents. It introduces two tailored workbenches (Agent Command Environment and Agent Execution Environment) to facilitate human-agent collaboration and orchestration. The authors present structured processes and vocabularies, culminating in a roadmap highlighting research challenges and future directions.", "result": "The paper lays out the vision of Structured Agentic Software Engineering (SASE), establishing new foundational pillars and proposing structured processes that redefine the relationship between humans and intelligent agents in software engineering. It identifies key challenges, outlines the dualities and workbenches, and discusses the potential impacts on SE education and community thinking.", "conclusion": "The paper concludes by advocating for a disciplined, scalable, and trustworthy approach to software engineering in the agentic era, encouraging the community to move beyond traditional, human-centric methods. It provides a scaffold for new research and discussion, rather than a prescriptive solution, to catalyze progress toward agentic SE."}}
{"id": "2509.06301", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06301", "abs": "https://arxiv.org/abs/2509.06301", "authors": ["Dharun Anandayuvaraj", "Zain Hammadeh", "Andreas Lund", "Alexandra Holloway", "James C. Davis"], "title": "Learning From Software Failures: A Case Study at a National Space Research Center", "comment": null, "summary": "Software failures can have significant consequences, making learning from\nfailures a critical aspect of software engineering. While software\norganizations are recommended to conduct postmortems, the effectiveness and\nadoption of these practices vary widely. Understanding how engineers gather,\ndocument, share, and apply lessons from failures is essential for improving\nreliability and preventing recurrence. High-reliability organizations (HROs)\noften develop software systems where failures carry catastrophic risks,\nrequiring continuous learning to ensure reliability. These organizations\nprovide a valuable setting to examine practices and challenges for learning\nfrom software failures. Such insight could help develop processes and tools to\nimprove reliability and prevent recurrence. However, we lack in-depth industry\nperspectives on the practices and challenges of learning from failures.\n  To address this gap, we conducted a case study through 10 in-depth interviews\nwith research software engineers at a national space research center. We\nexamine how they learn from failures: how they gather, document, share, and\napply lessons. To assess transferability, we include data from 5 additional\ninterviews at other HROs. Our findings provide insight into how engineers learn\nfrom failures in practice. To summarize: (1) failure learning is informal, ad\nhoc, and inconsistently integrated into SDLC; (2) recurring failures persist\ndue to absence of structured processes; and (3) key challenges, including time\nconstraints, knowledge loss from turnover and fragmented documentation, and\nweak process enforcement, undermine systematic learning. Our findings deepen\nunderstanding of how software engineers learn from failures and offer guidance\nfor improving failure management practices.", "AI": {"tldr": "The paper investigates how engineers in high-reliability organizations learn from software failures. It finds that learning is mostly informal and unstructured, resulting in recurring failures due to lack of systematic processes. Key obstacles include time limits, knowledge loss, and poor process enforcement. The study offers insights and recommendations for better failure management in software engineering.", "motivation": "Software failures can have major consequences, particularly in high-reliability organizations (HROs) where errors can be catastrophic. Although postmortems and learning from failures are recommended, the effectiveness and adoption of these practices are inconsistent across organizations. The study aims to understand how engineers actually gather, document, share, and use lessons from failures, in order to improve software reliability and prevent repeated problems.", "method": "The authors conducted a case study involving 10 in-depth interviews with research software engineers at a national space research center. To assess if the findings are broadly applicable, they also included 5 interviews from other HROs. The aim was to observe and analyze real-world practices in learning from software failures.", "result": "The study found that failure learning in these organizations tends to be informal, ad hoc, and not systematically integrated into the software development life cycle (SDLC). Recurring failures are common because there is a lack of structured processes. Key challenges undermining systematic learning include time constraints, knowledge loss due to staff turnover and fragmented documentation, and weak enforcement of processes.", "conclusion": "The research increases our understanding of how software engineers learn from failures in HROs. It emphasizes that current failure management is inconsistent and informal, leading to persistent recurring failures. The study provides guidance for improving processes and tools that support systematic learning from failures, with the aim of improving reliability and preventing repeated mistakes."}}
{"id": "2509.06324", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06324", "abs": "https://arxiv.org/abs/2509.06324", "authors": ["Zhuohang Shen", "Mohammed Yaseen", "Denini Silva", "Kevin Guan", "Junho Lee", "Marcelo d'Amorim", "Owolabi Legunsen"], "title": "A Generic and Efficient Python Runtime Verification System and its Large-scale Evaluation", "comment": "23 pages, 7 figures", "summary": "Runtime verification (RV) now scales for testing thousands of open-source\nJava projects, helping find hundreds of bugs. The popular Python ecosystem\ncould use such benefits. But, today's Python RV systems are limited to a domain\nor specification logic, or slow. We propose PyMOP, a generic, extensible, and\nefficient RV system for Python. PyMOP supports five logics, implements five\nexisting monitoring algorithms, ships with 73 API specs of Python and\nwidely-used libraries, supports three instrumentation strategies, and users can\neasily add more of these. On 290,133 unit tests in 1,463 GitHub projects, we\nfind mainly that (i) the default monitoring algorithm for Java is often not the\nfastest for Python; (ii) PyMOP is up to 1,168.3x faster than two recent dynamic\nanalysis systems; and (iii) 44 of 121 bugs that PyMOP helped find so far were\nfixed by developers. PyMOP's generality and efficiency position it well as an\nexcellent platform for the next advances on RV for Python.", "AI": {"tldr": "PyMOP introduces a fast, extensible runtime verification solution for Python, outperforming existing tools and helping developers fix numerous bugs across many projects.", "motivation": "Current runtime verification (RV) systems for Python are either limited to specific domains, specification logic, or have performance issues, unlike the scalable and effective RV solutions available for Java.", "method": "The authors propose PyMOP\u2014a generic, extensible, and efficient RV system for Python. PyMOP supports five specification logics, implements five monitoring algorithms, ships with 73 API specifications, supports three instrumentation strategies, and enables easy extensibility.", "result": "On 290,133 unit tests in 1,463 GitHub projects, PyMOP demonstrated its generality and efficiency, finding that the default Java algorithm is not the fastest for Python, PyMOP is up to 1,168.3x faster than recent dynamic analysis systems, and it contributed to 44 of 121 detected bugs being fixed by developers.", "conclusion": "PyMOP is a highly general and efficient platform for runtime verification in Python, making it well-suited for future advances in the field."}}
{"id": "2509.06429", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06429", "abs": "https://arxiv.org/abs/2509.06429", "authors": ["Mehmet Bilal Er", "Nagehan \u0130lhan", "Umut Kuran"], "title": "Analyzing the Instability of Large Language Models in Automated Bug Injection and Correction", "comment": null, "summary": "The use of Large Language Models (LLMs) in software engineering tasks is\ngrowing, especially in the areas of bug fixing and code generation.\nNevertheless, these models often yield unstable results; when executed at\ndifferent times with the same input, they can generate radically different\ncode. The consistency of LLMs in bug-fixing tasks has not yet been thoroughly\nassessed, despite the fact that this instability has typically been discussed\nin the literature in relation to code generation. The purpose of this study is\nto look into how unstable an LLM like ChatGPT is when it comes to fixing code\nbugs. We examine the structural, syntactic, and functional variations among\nseveral fix recommendations made in response to the same prompt using code\nsamples with various error types. Additionally, we assess how instability is\naffected by the temperature settings (0, 0.5, and 1) used for the model's\ndeterministic operation. For a total of 20 problems in the experimental\nanalysis, the model produced three fix suggestions at each temperature value,\ncomparing nine distinct outputs for each problem. The Syntax Similarity and\nOutput Equivalence Rate (OER) metrics were used to assess the outputs'\nstructural and functional consistency. The results demonstrate that the model's\noutputs become much more unstable and variable as the temperature rises, with\nhigh temperatures showing especially high rates of functional failure.\nAccording to syntax similarity analyses, the suggested fixes show notable\nstructural differences at high temperatures but are fairly similar at low\ntemperatures. The purpose of this study is to provide important methodological\ninsights into how LLM-based error correction systems can be applied more\nconsistently in software development processes while also casting doubt on\ntheir dependability.", "AI": {"tldr": "Higher temperature settings in LLMs like ChatGPT lead to more unstable and inconsistent bug fix outputs, raising concerns about their reliability for software engineering. Low temperature settings provide more consistent results, but overall dependability remains an issue for automatic bug fixing tasks.", "motivation": "Large Language Models (LLMs) are increasingly used in software engineering for bug fixing and code generation. However, their outputs can be unstable, generating different results for the same input. While instability has been studied for code generation, its impact on bug-fixing tasks is less explored. The motivation is to assess the consistency and reliability of LLMs in bug-fixing scenarios.", "method": "The study investigates the instability of ChatGPT in bug-fixing by generating multiple fix suggestions for 20 code problems at different temperature settings (0, 0.5, and 1). For each issue, the model outputs three suggestions per temperature, resulting in nine outputs per problem. The structural, syntactic, and functional differences between these outputs are analyzed using the Syntax Similarity and Output Equivalence Rate (OER) metrics.", "result": "At higher temperature settings, the model's outputs become significantly more unstable and more likely to fail functionally. High temperatures yield greater structural differences between suggestions, according to syntax similarity metrics, while low temperatures produce more similar outputs. Functional failures are especially pronounced at high temperatures.", "conclusion": "LLMs like ChatGPT display considerable variability in bug fix recommendations as temperature increases. Their reliability and consistency are questionable at higher temperatures. The findings reveal important insights for developing more dependable LLM-based error correction systems for software engineering."}}
{"id": "2509.06530", "categories": ["cs.SE", "D.2.10"], "pdf": "https://arxiv.org/pdf/2509.06530", "abs": "https://arxiv.org/abs/2509.06530", "authors": ["Sylvain Gu\u00e9rin", "Salvador Martinez", "Ciprian Teodorov"], "title": "Modeling in the Design Multiverse", "comment": null, "summary": "Real-world design processes often involve the evolution and divergence of\ndesign paths (by branching, revising, merging, etc.), especially when multiple\nstakeholders or teams operate concurrently and/or explore different\nalternatives for complex and heterogeneous systems. Unfortunately, this\nvariability in time and space can not be directly managed in current modeling\nspaces but requires resorting to external tools and methodologies.\n  In order to tackle this problem, we introduce the Design Multiverse. The\nDesign Multiverse aims to integrate in the modeling space a selection of\nrevisions and variants, representing snapshots of a design state composed of\nmultiple artifacts. This enables stakeholders to seamlessly trace, analyze, and\nmanage design decisions, system variants, and their interdependencies.\nConcretely, in this paper we present a conceptual definition of the Design\nMultiverse, discuss usage scenarios such as model product lines and\nmodel/metamodel co-evolution, and propose an implementation leveraging the\nmodel federation paradigm.", "AI": {"tldr": "The paper proposes the Design Multiverse, a conceptual framework that natively manages design alternatives and their evolution within modeling environments, improving traceability and collaboration while minimizing reliance on external tools.", "motivation": "Current modeling spaces cannot directly manage the variability and evolution of design paths when multiple stakeholders or teams handle complex systems. This leads to reliance on external tools, which fragment the design process.", "method": "The paper introduces a conceptual framework called the Design Multiverse, which integrates revisions and design variants within the modeling space. Usage scenarios are discussed, and an implementation is proposed using the model federation paradigm.", "result": "The Design Multiverse supports the representation and management of alternative design paths and their interdependencies, allowing stakeholders to seamlessly trace and analyze design decisions. Example scenarios include model product lines and co-evolution of models and metamodels.", "conclusion": "Integrating the Design Multiverse into modeling spaces significantly improves the management of design variability, revisions, and interdependencies, reducing dependence on external methodologies and enhancing collaboration among stakeholders."}}
{"id": "2509.06688", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06688", "abs": "https://arxiv.org/abs/2509.06688", "authors": ["Heerok Banerjee"], "title": "Design and Implementation of a Domain-specific Language for Modelling Evacuation Scenarios Using Eclipse EMG/GMF Tool", "comment": null, "summary": "Domain-specific languages (DSLs) play a crucial role in resolving internal\ndependencies across enterprises and boosts their upfront business management\nprocesses. Yet, a lot of development is needed to build modelling frameworks\nwhich support graphical interfaces (canvas, pallettes etc.), hierarchical\nstructures and easy implementation to shorten the gap for novice users. In this\npaper, a DSL namely, Bmod is introduced, which can be used to model evacuation\nscenarios. The language is built using Eclipse Modelling Framework (EMF) and\nEclipse Graphical Modelling Framework (GMF). Furthermore, a comparison is also\nshown between Eclipse EMF/GMF and other modelling tools such as AToMPM,\nmetaDepth, Sirius etc with respect to expressiveness, learning curve and\nperformance.", "AI": {"tldr": "The paper introduces Bmod, a new domain-specific language for modeling evacuation scenarios, built with Eclipse EMF/GMF, and compares it to alternative tools.", "motivation": "There is a need for modeling frameworks with graphical interfaces and easy implementation to help novice users and address enterprise dependencies. Existing tools lack user-friendliness or sufficient features for business process modeling.", "method": "Development of the Bmod DSL using Eclipse Modeling Framework and Eclipse Graphical Modeling Framework, followed by comparative analysis with other modeling tools (AToMPM, metaDepth, Sirius).", "result": "Bmod demonstrates effectiveness as a modeling tool for evacuation scenarios and offers improvements in usability and performance compared to other available modeling tools.", "conclusion": "Bmod, developed using Eclipse EMF/GMF, provides a graphical and user-friendly framework for modeling evacuation scenarios and shows competitive advantages over other tools in terms of expressiveness, ease of learning, and performance."}}
{"id": "2509.06716", "categories": ["cs.SE", "cs.PF"], "pdf": "https://arxiv.org/pdf/2509.06716", "abs": "https://arxiv.org/abs/2509.06716", "authors": ["Th\u00e9o Matricon", "Mathieu Acher", "Helge Spieker", "Arnaud Gotlieb"], "title": "Efficiently Ranking Software Variants with Minimal Benchmarks", "comment": null, "summary": "Benchmarking is a common practice in software engineering to assess the\nqualities and performance of software variants, coming from multiple competing\nsystems or from configurations of the same system. Benchmarks are used notably\nto compare and understand variant performance, fine-tune software, detect\nregressions, or design new software systems. The execution of benchmarks to get\na complete picture of software variants is highly costly in terms of\ncomputational resources and time. In this paper, we propose a novel approach\nfor reducing benchmarks while maintaining stable rankings, using test suite\noptimization techniques. That is, we remove instances from the benchmarks while\ntrying to keep the same rankings of the variants on all tests. Our method,\nBISection Sampling, BISS, strategically retains the most critical tests and\napplies a novel divide-and-conquer approach to efficiently sample among\nrelevant remaining tests. We experiment with datasets and use cases from LLM\nleaderboards, SAT competitions, and configurable systems for performance\nmodeling. Our results show that our method outperforms baselines even when\noperating on a subset of variants. Using BISS, we reduce the computational cost\nof the benchmarks on average to 44% and on more than half the benchmarks by up\nto 99% without loss in ranking stability.", "AI": {"tldr": "The paper proposes BISection Sampling (BISS), a method to cut down computational cost in benchmarking software variants by optimizing test selections. BISS achieves significant cost reduction (up to 99% in many cases) while keeping the rankings of software variants stable, demonstrating its efficiency on diverse datasets.", "motivation": "Benchmarking is valuable for comparing, optimizing, and maintaining software variants, but running extensive benchmarks consumes significant time and computational resources. There is a need for methods that can reduce the benchmarking effort while preserving reliable comparative results.", "method": "The paper introduces BISection Sampling (BISS), a test suite optimization approach. BISS selectively retains critical benchmark tests using a divide-and-conquer procedure to minimize the total number of tests executed, attempting to keep the ranking of software variants stable.", "result": "Experiments on datasets from LLM leaderboards, SAT competitions, and configurable systems show that BISS can reduce benchmarking computational cost on average to 44%, and in over half of the cases by up to 99%, all without compromising ranking stability.", "conclusion": "BISS provides an effective solution to reduce the cost of benchmarking in software engineering by strategically sampling tests, maintaining accurate variant rankings, and outperforming baseline methods in both efficiency and ranking stability."}}
{"id": "2509.06774", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.06774", "abs": "https://arxiv.org/abs/2509.06774", "authors": ["Hridoy Sankar Dutta", "Sana Ansari", "Swati Kumari", "Shounak Ravi Bhalerao"], "title": "OpenCoderRank: AI-Driven Technical Assessments Made Easy", "comment": null, "summary": "Organizations and educational institutions use time-bound assessment tasks to\nevaluate coding and problem-solving skills. These assessments measure not only\nthe correctness of the solutions, but also their efficiency. Problem setters\n(educator/interviewer) are responsible for crafting these challenges, carefully\nbalancing difficulty and relevance to create meaningful evaluation experiences.\nConversely, problem solvers (student/interviewee) apply coding efficiency and\nlogical thinking to arrive at correct solutions. In the era of Large Language\nModels (LLMs), LLMs assist problem setters in generating diverse and\nchallenging questions, but they can undermine assessment integrity for problem\nsolvers by providing easy access to solutions. This paper introduces\nOpenCoderRank, an easy-to-use platform designed to simulate technical\nassessments. It acts as a bridge between problem setters and problem solvers,\nhelping solvers prepare for time constraints and unfamiliar problems while\nallowing setters to self-host assessments, offering a no-cost and customizable\nsolution for technical assessments in resource-constrained environments.", "AI": {"tldr": "OpenCoderRank is an easy-to-use, free platform for hosting and simulating technical coding assessments, benefiting both educators/interviewers and students/interviewees by providing meaningful, customizable evaluation experiences in resource-constrained settings.", "motivation": "In technical assessments for coding and problem-solving, balancing challenge with relevance is essential for fair evaluation. However, the advent of Large Language Models (LLMs) has challenged the assessment integrity by making solutions easily accessible to problem solvers. There is also a need for low-cost, customizable, and easy-to-use platforms that allow both educators/interviewers and students/interviewees to participate in meaningful technical evaluations.", "method": "The authors introduce OpenCoderRank, a platform that simulates real technical assessments. It enables problem setters to create, host, and manage challenges, ensuring customizable assessments. It also helps problem solvers practice under realistic time constraints and exposure to unfamiliar tasks. The system is designed to be self-hosted and free, supporting resource-limited environments.", "result": "OpenCoderRank provides an accessible, no-cost solution for conducting technical assessments, bridging the gap between problem setters and solvers. It enhances preparation for problem solvers and gives problem setters greater control over assessment integrity and relevance.", "conclusion": "OpenCoderRank is a promising tool for both problem setters and solvers in technical coding assessments. It strengthens the integrity and relevance of assessments, offers cost-effective and customizable hosting, and helps prepare solvers for high-pressure assessment situations."}}
{"id": "2509.06911", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.06911", "abs": "https://arxiv.org/abs/2509.06911", "authors": ["Margarida Ferreira", "Victor Nicolet", "Luan Pham", "Joey Dodds", "Daniel Kroening", "Ines Lynce", "Ruben Martins"], "title": "Hypergraph-Guided Regex Filter Synthesis for Event-Based Anomaly Detection", "comment": null, "summary": "We propose HyGLAD, a novel algorithm that automatically builds a set of\ninterpretable patterns that model event data. These patterns can then be used\nto detect event-based anomalies in a stationary system, where any deviation\nfrom past behavior may indicate malicious activity. The algorithm infers\nequivalence classes of entities with similar behavior observed from the events,\nand then builds regular expressions that capture the values of those entities.\nAs opposed to deep-learning approaches, the regular expressions are directly\ninterpretable, which also translates to interpretable anomalies. We evaluate\nHyGLAD against all 7 unsupervised anomaly detection methods from DeepOD on five\ndatasets from real-world systems. The experimental results show that on average\nHyGLAD outperforms existing deep-learning methods while being an order of\nmagnitude more efficient in training and inference (single CPU vs GPU).\nPrecision improved by 1.2x and recall by 1.3x compared to the second-best\nbaseline.", "AI": {"tldr": "HyGLAD is an interpretable and efficient anomaly detection algorithm for event data that beats deep-learning baselines on accuracy and resource use, thanks to its use of regular expressions to model entity behavior.", "motivation": "There is a growing need for interpretable and efficient anomaly detection methods in event-based systems, where existing deep-learning approaches often lack transparency and require significant computational resources.", "method": "HyGLAD is introduced as an algorithm that learns interpretable patterns through regular expressions, modeling entity behavior in event data. It infers equivalence classes and creates regular expressions that represent behavioral norms, allowing for interpretable anomaly detection.", "result": "HyGLAD was tested against seven unsupervised anomaly detection methods from DeepOD across five real-world datasets. It outperformed deep-learning baselines in both precision (1.2x improvement) and recall (1.3x improvement), while being significantly more efficient in training and inference (using only a single CPU).", "conclusion": "HyGLAD provides superior accuracy and efficiency compared to deep-learning methods for event-based anomaly detection, while also offering interpretability through regular expressions."}}

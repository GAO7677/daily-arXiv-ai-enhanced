{"id": "2509.14265", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14265", "abs": "https://arxiv.org/abs/2509.14265", "authors": ["Siyuan Chen", "Zhichao Lu", "Qingfu Zhang"], "title": "Evolution of Kernels: Automated RISC-V Kernel Optimization with Large Language Models", "comment": "Technical report", "summary": "Automated kernel design is critical for overcoming software ecosystem\nbarriers in emerging hardware platforms like RISC-V. While large language\nmodels (LLMs) have shown promise for automated kernel optimization,\ndemonstrating success in CUDA domains with comprehensive technical documents\nand mature codebases, their effectiveness remains unproven for reference-scarce\ndomains like RISC-V. We present Evolution of Kernels (EoK), a novel LLM-based\nevolutionary program search framework that automates kernel design for domains\nwith limited reference material. EoK mitigates reference scarcity by mining and\nformalizing reusable optimization ideas (general design principles + actionable\nthoughts) from established kernel libraries' development histories; it then\nguides parallel LLM explorations using these ideas, enriched via\nRetrieval-Augmented Generation (RAG) with RISC-V-specific context, prioritizing\nhistorically effective techniques. Empirically, EoK achieves a median 1.27x\nspeedup, surpassing human experts on all 80 evaluated kernel design tasks and\nimproving upon prior LLM-based automated kernel design methods by 20%. These\nresults underscore the viability of incorporating human experience into\nemerging domains and highlight the immense potential of LLM-based automated\nkernel optimization.", "AI": {"tldr": "The paper introduces EoK, an LLM-based framework for automated kernel design in domains with limited references like RISC-V. By leveraging mined human optimization ideas and RAG-enhanced context, EoK achieves notable speedups and outperforms experts and previous methods, demonstrating the value of human-guided LLMs in new hardware platforms.", "motivation": "Existing large language model-driven kernel optimization works well in domains like CUDA due to abundant documentation and mature codebases, but its effectiveness for emerging hardware like RISC-V, which lacks reference materials, is unknown.", "method": "The authors propose EoK (Evolution of Kernels), an LLM-based evolutionary program search framework. EoK mines optimization ideas (design principles and actionable thoughts) from development histories of established kernel libraries, then uses Retrieval-Augmented Generation (RAG) to enrich LLM explorations with RISC-V-specific context, focusing on proven techniques.", "result": "EoK achieves a median 1.27x speedup, outperforms human experts across 80 kernel design tasks, and improves prior LLM-based methods by 20%.", "conclusion": "Incorporating reusable human experience and optimization ideas via LLMs significantly enhances automated kernel design for reference-scarce domains, establishing the potential of LLM-based optimization in emerging hardware."}}
{"id": "2509.14273", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14273", "abs": "https://arxiv.org/abs/2509.14273", "authors": ["Swapnil Sharma Sarker", "Tanzina Taher Ifty"], "title": "Automated and Context-Aware Code Documentation Leveraging Advanced LLMs", "comment": null, "summary": "Code documentation is essential to improve software maintainability and\ncomprehension. The tedious nature of manual code documentation has led to much\nresearch on automated documentation generation. Existing automated approaches\nprimarily focused on code summarization, leaving a gap in template-based\ndocumentation generation (e.g., Javadoc), particularly with publicly available\nLarge Language Models (LLMs). Furthermore, progress in this area has been\nhindered by the lack of a Javadoc-specific dataset that incorporates modern\nlanguage features, provides broad framework/library coverage, and includes\nnecessary contextual information. This study aims to address these gaps by\ndeveloping a tailored dataset and assessing the capabilities of publicly\navailable LLMs for context-aware, template-based Javadoc generation. In this\nwork, we present a novel, context-aware dataset for Javadoc generation that\nincludes critical structural and semantic information from modern Java\ncodebases. We evaluate five open-source LLMs (including LLaMA-3.1, Gemma-2,\nPhi-3, Mistral, Qwen-2.5) using zero-shot, few-shot, and fine-tuned setups and\nprovide a comparative analysis of their performance. Our results demonstrate\nthat LLaMA 3.1 performs consistently well and is a reliable candidate for\npractical, automated Javadoc generation, offering a viable alternative to\nproprietary systems.", "AI": {"tldr": "This paper introduces a new dataset for template-based Javadoc generation and evaluates open-source LLMs for this task, finding LLaMA 3.1 highly effective and practical as an alternative to closed-source systems.", "motivation": "Manual code documentation is tedious but essential for software maintainability. Automated documentation generation, particularly for template-based documentation (like Javadoc), is underexplored, partly due to the absence of specialized datasets.", "method": "Development of a novel, context-aware dataset for Javadoc generation, covering modern language features and frameworks. Evaluation of five open-source LLMs (LLaMA-3.1, Gemma-2, Phi-3, Mistral, Qwen-2.5) in zero-shot, few-shot, and fine-tuned settings, followed by a comparative performance analysis.", "result": "LLaMA 3.1 consistently outperformed other open-source LLMs and proved effective for automated Javadoc generation, providing a strong alternative to proprietary solutions.", "conclusion": "The tailored dataset and LLaMA 3.1 enable practical, context-aware, automated Javadoc generation with publicly accessible models, closing a significant gap in software documentation research."}}
{"id": "2509.14279", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14279", "abs": "https://arxiv.org/abs/2509.14279", "authors": ["Robert Tjarko Lange", "Qi Sun", "Aaditya Prasad", "Maxence Faldor", "Yujin Tang", "David Ha"], "title": "Towards Robust Agentic CUDA Kernel Benchmarking, Verification, and Optimization", "comment": "62 pages, 10 figures", "summary": "Recent advances in large language models (LLMs) demonstrate their\neffectiveness in scaling test-time compute for software engineering tasks.\nHowever, these approaches often focus on high-level solutions, with limited\nattention to optimizing low-level CUDA kernel implementations. Additionally,\nexisting kernel generation benchmarks suffer from exploitable loopholes and\ninsufficient diversity in testing conditions, hindering true generalization\nassessment. To address these limitations, we introduce robust-kbench, a new\nbenchmark for rigorous evaluation of kernel performance and correctness across\nvaried scenarios. Furthermore, we present a comprehensive agentic framework\nthat automates CUDA kernel discovery, verification, and optimization. This\npipeline enables frontier LLMs to translate torch code to CUDA kernels and\niteratively improve their runtime within our robust evaluation setting. Our\nsequential workflow first translates PyTorch code into equivalent CUDA kernels.\nIt then optimizes their runtime using a novel evolutionary meta-generation\nprocedure tailored to the CUDA ecosystem, guided by LLM-based verifiers for\ncorrectness and efficient filtering. Evaluated on robust-kbench, our approach\nproduces CUDA kernels outperforming torch implementations for practical\napplications, including forward and backward passes. It can fuse operations and\ndeploy various runtime optimization strategies. The verifier workflow\naccurately classifies incorrect kernels, enhancing hardware verification\nefficiency.", "AI": {"tldr": "They introduce robust-kbench, a new benchmark for evaluating CUDA kernel performance, and a novel agentic framework that leverages LLMs to automate CUDA kernel discovery, optimization, and verification, beating PyTorch in practical tasks.", "motivation": "Current LLM-based approaches for software engineering often neglect low-level CUDA kernel optimization and rely on benchmarks with insufficient diversity and exploitable loopholes, impeding genuine assessment of kernel generalization and performance.", "method": "The authors build a sequential workflow consisting of translation from PyTorch to CUDA kernels, runtime optimization via an evolutionary meta-generation process, correctness verification using LLM-based verifiers, and rigorous evaluation using their new benchmark, robust-kbench.", "result": "The new approach outperforms PyTorch implementations in practical applications by producing more optimized CUDA kernels, effectively fusing operations, deploying diverse runtime strategies, and accurately classifying incorrect kernels, thereby improving hardware verification efficiency.", "conclusion": "The proposed agentic framework and robust-kbench benchmark enable significant improvements in the generation, correctness, and optimization of CUDA kernels by LLMs over high-level PyTorch implementations."}}
{"id": "2509.14281", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.14281", "abs": "https://arxiv.org/abs/2509.14281", "authors": ["Xifeng Yao", "Dongyu Lang", "Wu Zhang", "Xintong Guo", "Huarui Xie", "Yinhao Ni", "Ping Liu", "Guang Shen", "Yi Bai", "Dandan Tu", "Changzheng Zhang"], "title": "SCoGen: Scenario-Centric Graph-Based Synthesis of Real-World Code Problems", "comment": null, "summary": "Significant advancements have been made in the capabilities of code large\nlanguage models, leading to their rapid adoption and application across a wide\nrange of domains. However, their further advancements are often constrained by\nthe scarcity of real-world coding problems. To bridge this gap, we propose a\nnovel framework for synthesizing code problems that emulate authentic\nreal-world scenarios. This framework systematically integrates domain\nknowledge, domain skills, and coding skills, all of which are meticulously\nextracted from real-world programming-related datasets, including Stack\nOverflow and Kaggle. The extracted elements serve as the foundational building\nblocks for constructing code problems. To align the generated problems with\npractical applications, application scenarios are also mined from the\naforementioned datasets. These scenarios are then utilized to construct a\nscenario-centric graph that interconnects domain knowledge, domain skills, and\ncoding skills. Based on this structured representation, a sampling strategy on\nthe graph is designed, which effectively controls the generation of a code\nproblem with complexity and diversity, reflects real-world challenges.\nExperimental results demonstrate that the proposed method consistently achieves\nsuperior performance over state-of-the-art open-source large language models of\nvarying sizes and functionalities, including both coders and general-purpose\nmodels, across a diverse set of real-world benchmarks.", "AI": {"tldr": "The paper introduces a graph-based framework that synthesizes diverse, realistic code problems from real-world data (Stack Overflow, Kaggle) and improves code language model evaluation, outperforming existing models on empirical benchmarks.", "motivation": "Code large language models have made great progress but are limited by a lack of authentic real-world coding problems, which constrains their further development. This paper addresses the need for a scalable method to generate realistic, diverse code problems.", "method": "The paper proposes a novel problem synthesis framework that extracts domain knowledge, domain skills, and coding skills from real-world datasets like Stack Overflow and Kaggle. It maps these into a scenario-centric graph representing practical application scenarios and designs a graph-based sampling strategy to control the diversity and complexity of generated problems.", "result": "Experimental results show the proposed framework outperforms current state-of-the-art large language models (coders and general-purpose) on several real-world coding benchmarks in terms of performance and problem quality.", "conclusion": "The framework enables scalable creation of authentic code problems, advancing the development and evaluation of code large language models by closing the gap between real-world needs and available benchmarks."}}
{"id": "2509.14496", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.14496", "abs": "https://arxiv.org/abs/2509.14496", "authors": ["Wyatt Petula", "Anushcka Joshi", "Peggy Tu", "Amrutha Somasundar", "Suman Saha"], "title": "DeliverC: Teaching Pointers through GenAI-Powered Game-Based Learning", "comment": "The paper before Camera-ready paper. The paper has been accepted by\n  SIGCSE 2026", "summary": "While game-based learning is widely used in programming education, few tools\noffer adaptive, real-time support for complex topics, such as C pointers. We\npresent DeliverC, a GenAI-enhanced game that integrates GPT-4-mini to provide\npersonalized hints and generate pointer-related challenges on the fly. In a\npilot study involving 25 undergraduate students, we investigated the impact of\nthe system on learning through gameplay data and a 15-item survey that covered\nconstructs such as motivation, self-efficacy, metacognition, and feedback\nquality. Results show that most students felt more confident and reflective\nafter using the tool, and error rates decreased as students progressed through\nscaffolded levels. However, participation decreased with task difficulty, and\nsome students reported receiving unclear or vague feedback. These findings\nsuggest that DeliverC can enhance engagement and understanding in systems\nprogramming, although refinement in AI-generated feedback is still needed. Our\nstudy highlights the potential of combining GenAI with game-based learning to\nsupport personalized and interactive practice in traditionally challenging\nprogramming domains.", "AI": {"tldr": "DeliverC, a GenAI-powered educational game, improved student confidence and reduced errors for C pointers but needs clearer AI feedback and further refinement for harder tasks.", "motivation": "Game-based learning is commonly applied in programming education, but there is a lack of adaptive, real-time tools specifically addressing challenging topics like C pointers. The authors aim to tackle this gap by leveraging GenAI to provide personalized support.", "method": "The authors developed DeliverC, a GenAI-enhanced game that uses GPT-4-mini to generate tailored hints and pointer challenges in real time. They evaluated its effects in a pilot study with 25 undergraduate students, analyzing gameplay data and survey responses on motivation, self-efficacy, metacognition, and feedback quality.", "result": "Students became more confident and reflective after using DeliverC, with reduced error rates as they progressed. However, participation declined with increased difficulty, and some feedback from the AI was considered vague.", "conclusion": "DeliverC can boost engagement and understanding of difficult programming concepts like C pointers in a game-based format. However, improvements to AI feedback quality are necessary for optimal learning experiences."}}
{"id": "2509.14294", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14294", "abs": "https://arxiv.org/abs/2509.14294", "authors": ["Hira Naveed", "Scott Barnett", "Chetan Arora", "John Grundy", "Hourieh Khalajzadeh", "Omar Haggag"], "title": "Monitoring Machine Learning Systems: A Multivocal Literature Review", "comment": null, "summary": "Context: Dynamic production environments make it challenging to maintain\nreliable machine learning (ML) systems. Runtime issues, such as changes in data\npatterns or operating contexts, that degrade model performance are a common\noccurrence in production settings. Monitoring enables early detection and\nmitigation of these runtime issues, helping maintain users' trust and prevent\nunwanted consequences for organizations. Aim: This study aims to provide a\ncomprehensive overview of the ML monitoring literature. Method: We conducted a\nmultivocal literature review (MLR) following the well established guidelines by\nGarousi to investigate various aspects of ML monitoring approaches in 136\npapers. Results: We analyzed selected studies based on four key areas: (1) the\nmotivations, goals, and context; (2) the monitored aspects, specific\ntechniques, metrics, and tools; (3) the contributions and benefits; and (4) the\ncurrent limitations. We also discuss several insights found in the studies,\ntheir implications, and recommendations for future research and practice.\nConclusion: Our MLR identifies and summarizes ML monitoring practices and gaps,\nemphasizing similarities and disconnects between formal and gray literature.\nOur study is valuable for both academics and practitioners, as it helps select\nappropriate solutions, highlights limitations in current approaches, and\nprovides future directions for research and tool development.", "AI": {"tldr": "This paper surveys 136 ML monitoring works, examining motivations, methods, tools, and limitations. It provides insights, highlights gaps, and recommends directions for future research and practice.", "motivation": "The motivation lies in the inherent instability and unpredictability of production ML environments, where runtime issues (data drift, operational changes) frequently affect model performance, making effective monitoring crucial for reliability and trust.", "method": "The authors use a multivocal literature review (MLR) following Garousi's guidelines, analyzing 136 papers and studying ML monitoring from multiple dimensions, including motivations, techniques/tools, benefits, and limitations.", "result": "The review provides a systematic analysis of ML monitoring literature, outlining key motivations, approaches, practical techniques, benefits, and current shortcomings. It highlights both formal and 'gray' literature, presenting insights, implications, and actionable recommendations for future work.", "conclusion": "The study summarizes the state of ML monitoring, identifying practices and gaps, and offering guidance to both academics and practitioners on selecting solutions and prioritizing future research and tool development."}}
{"id": "2509.15005", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.15005", "abs": "https://arxiv.org/abs/2509.15005", "authors": ["Facundo Dom\u00ednguez", "Arnaud Spiwack"], "title": "Refinement-Types Driven Development: A study", "comment": "11 pages, 3 figures, artifacts\n  https://github.com/tweag/ifl2025-liquidhaskell", "summary": "This paper advocates for the broader application of SMT solvers in everyday\nprogramming, challenging the conventional wisdom that these tools are solely\nfor formal methods and verification. We claim that SMT solvers, when seamlessly\nintegrated into a compiler's static checks, significantly enhance the\ncapabilities of ordinary type checkers in program composition. Specifically, we\nargue that refinement types, as embodied by Liquid Haskell, enable the use of\nSMT solvers in mundane programming tasks. Through a case study on handling\nbinder scopes in compilers, we envision a future where ordinary programming is\nmade simpler and more enjoyable with the aid of refinement types and SMT\nsolvers. As a secondary contribution, we present a prototype implementation of\na theory of finite maps for Liquid Haskell's solver, developed to support our\ncase study.", "AI": {"tldr": "The paper proposes that SMT solvers should be used more broadly in normal programming by integrating them into compiler checks through refinement types, demonstrated via case study and prototype with Liquid Haskell.", "motivation": "The paper is motivated by the belief that SMT solvers are underutilized in everyday programming, being traditionally reserved for formal verification tasks. The authors aim to challenge this perception and demonstrate broader benefits.", "method": "The paper argues for integrating SMT solvers into static compiler checks using refinement types, specifically via Liquid Haskell. The approach is demonstrated through a case study on handling binder scopes in compilers, and supported by a prototype theory of finite maps for the SMT solver.", "result": "The authors show that, by incorporating SMT solvers and refinement types into the compilation process, ordinary programming tasks\u2014such as managing binder scopes\u2014can be simplified. They also provide a working prototype that extends Liquid Haskell's capabilities.", "conclusion": "SMT solvers, when combined with refinement types and integrated into compiler static checks, can substantially enhance everyday programming and program composition\u2014not just formal verification. The case study and prototype support the feasibility of this approach."}}
{"id": "2509.14347", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14347", "abs": "https://arxiv.org/abs/2509.14347", "authors": ["Henri A\u00efdasso", "Francis Bordeleau", "Ali Tizghadam"], "title": "On the Illusion of Success: An Empirical Study of Build Reruns and Silent Failures in Industrial CI", "comment": "17 pages, 7 figures", "summary": "Reliability of build outcomes is a cornerstone of effective Continuous\nIntegration (CI). Yet in practice, developers often struggle with\nnon-deterministic issues in the code or CI infrastructure, which undermine\ntrust in build results. When faced with such unexpected outcomes, developers\noften repeatedly rerun jobs hoping for true success, but this practice is known\nto increase CI costs and reduce productivity. While recent studies have focused\non intermittent job failures, no prior work has investigated silent failures,\nwhere build jobs are marked as successful but fail to complete all or part of\ntheir tasks. Such silent failures often go unnoticed, creating an illusion of\nsuccess with detrimental consequences such as bugs escaping into production.\nThis paper presents the first empirical study of silent failures through the\npractice of rerunning successful jobs. An analysis of 142,387 jobs across 81\nindustrial projects shows that 11% of successful jobs are rerun, with 35% of\nthese reruns occurring after more than 24 hours. Using mixed-effects models on\n32 independent variables (AUC of 85%), we identified key factors associated\nwith reruns of successful jobs, notably testing and static analysis tasks,\nscripting languages like Shell, and developers prior rerun tendencies. A\nfurther analysis of 92 public issues revealed 11 categories of silent failures\naligning with these factors, the most frequent being artifact operation errors,\ncaching errors, and ignored exit codes. Overall, our findings provide valuable\ninsights into the circumstances and causes of silent failures to raise\nawareness among teams, and present solutions to improve CI reliability.", "AI": {"tldr": "This paper is the first to empirically study 'silent failures' in CI\u2014cases where build jobs succeed but secretly fail tasks\u2014by analyzing job reruns and public issues. It finds silent failures are common and often unnoticed, caused by factors such as scripting errors, ignored exit codes, and caching problems. Highlighting these helps teams improve CI reliability and reduce bugs slipping into production.", "motivation": "The motivation is to address undetected reliability problems in Continuous Integration (CI) systems, specifically the issue of 'silent failures' where jobs are marked as successful but fail during execution. These failures undermine developer trust and can result in bugs reaching production, yet have not been previously studied in detail.", "method": "The study empirically investigates silent CI failures by analyzing reruns of successful build jobs. It examines 142,387 jobs from 81 industrial projects, applying mixed-effects models to 32 independent variables. Additionally, the study reviews 92 public issues to categorize types of silent failures.", "result": "The results show that 11% of successful CI jobs are rerun, and 35% of reruns occur more than 24 hours after the initial run. The analysis identifies key factors related to silent failures, such as static analysis and testing tasks, scripting languages (Shell), and developer rerun tendencies. 11 distinct categories of silent failures, with common causes including artifact operation errors, caching errors, and ignored exit codes, are documented.", "conclusion": "Silent failures in CI are widespread and usually unnoticed, posing a significant threat to software quality and reliability. Identifying their causes and patterns enables teams to enhance CI practices, reduce unnoticed errors, and improve build outcome trust."}}
{"id": "2509.14404", "categories": ["cs.SE", "cs.AI", "cs.CL", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.14404", "abs": "https://arxiv.org/abs/2509.14404", "authors": ["Haoye Tian", "Chong Wang", "BoYang Yang", "Lyuye Zhang", "Yang Liu"], "title": "A Taxonomy of Prompt Defects in LLM Systems", "comment": null, "summary": "Large Language Models (LLMs) have become key components of modern software,\nwith prompts acting as their de-facto programming interface. However, prompt\ndesign remains largely empirical and small mistakes can cascade into\nunreliable, insecure, or inefficient behavior. This paper presents the first\nsystematic survey and taxonomy of prompt defects, recurring ways that prompts\nfail to elicit their intended behavior from LLMs. We organize defects along six\ndimensions: (1) Specification and Intent, (2) Input and Content, (3) Structure\nand Formatting, (4) Context and Memory, (5) Performance and Efficiency, and (6)\nMaintainability and Engineering. Each dimension is refined into fine-grained\nsubtypes, illustrated with concrete examples and root cause analysis. Grounded\nin software engineering principles, we show how these defects surface in real\ndevelopment workflows and examine their downstream effects. For every subtype,\nwe distill mitigation strategies that span emerging prompt engineering\npatterns, automated guardrails, testing harnesses, and evaluation frameworks.\nWe then summarize these strategies in a master taxonomy that links defect,\nimpact, and remedy. We conclude with open research challenges and a call for\nrigorous engineering-oriented methodologies to ensure that LLM-driven systems\nare dependable by design.", "AI": {"tldr": "This paper systematically classifies prompt defects for LLMs, mapping their causes and effects, and outlines practical engineering solutions, urging the field towards more reliable prompt design methodologies.", "motivation": "Prompt design for LLMs is currently empirical and error-prone, with mistakes often causing unreliable and insecure model behavior. There is a need for an engineering-focused understanding and systematic approach to prompt issues.", "method": "The study conducts a systematic survey of prompt defects in LLMs, organizes them into a taxonomy across six dimensions, analyzes concrete examples and root causes, and distills mitigation strategies informed by software engineering principles.", "result": "The paper delivers the first structured taxonomy of prompt defects, explains their impact on real-world development, and outlines targeted strategies for mitigation. It also identifies open challenges and recommends methodological transitions in prompt engineering.", "conclusion": "The paper concludes that prompt defects are diverse and impactful, proposing a comprehensive taxonomy of these defects, their causes, consequences, and mitigation strategies. It advocates for more rigorous engineering approaches in prompt design to ensure reliable and robust LLM-driven systems."}}
{"id": "2509.14373", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14373", "abs": "https://arxiv.org/abs/2509.14373", "authors": ["Huy Le", "Phong Nguyen", "Hao Do", "Tuan Nguyen", "Thien Pham", "Anh Nguyen-Duc", "Tho Quan"], "title": "CodeLSI: Leveraging Foundation Models for Automated Code Generation with Low-Rank Optimization and Domain-Specific Instruction Tuning", "comment": null, "summary": "Context: Automated code generation using Foundation Models (FMs) offers\npromising solutions for enhancing software development efficiency. However,\nchallenges remain in ensuring domain specificity, cost-effectiveness, and\nsecurity - especially when relying on third-party APIs. This paper introduces\nCodeLSI, a framework that combines low-rank optimization and domain-specific\ninstruction tuning to address these challenges.\n  Objectives: The aim of this study is to develop and evaluate CodeLSI, a novel\napproach for generating high-quality code tailored to specific domains, using\nFMs fine-tuned on company infrastructure without dependence on external APIs.\n  Methods: CodeLSI applies low-rank adaptation techniques to reduce the\ncomputational cost of model pre-training and fine-tuning. Domain-specific\ninstruction tuning is employed to align code generation with organizational\nneeds. We implemented and tested the framework on real-world JavaScript coding\ntasks using datasets drawn from internal software projects.\n  Results: Experimental evaluations show that CodeLSI produces high-quality,\ncontext aware code. It outperforms baseline models in terms of relevance,\naccuracy, and domain fit. The use of low-rank optimization significantly\nreduced resource requirements, enabling scalable training on company-owned\ninfrastructure.\n  Conclusion: CodeLSI demonstrates that combining low-rank optimization with\ndomain specific tuning can enhance the practicality and performance of FMs for\nautomated code generation. This approach provides a secure, cost-efficient\nalternative to commercial API based solutions and supports faster, more\ntargeted innovation in software development.", "AI": {"tldr": "CodeLSI enables secure, scalable, and domain-specific code generation by combining model optimization and custom tuning, outperforming conventional methods and reducing costs.", "motivation": "While foundation models (FMs) can generate code automatically, existing solutions often lack domain specificity, are costly, and may raise security concerns when relying on third-party APIs. The motivation of the paper is to develop a code generation solution tailored for specific domains that is more secure, cost-effective, and independent of commercial APIs.", "method": "The proposed framework, CodeLSI, combines low-rank adaptation techniques (to reduce computational resource costs during model pre-training and fine-tuning) with domain-specific instruction tuning (to better align outputs to organizational coding needs). It is tested using real JavaScript tasks with data from internal company projects.", "result": "CodeLSI produced high-quality, context-aware code that surpassed baseline models in relevance, accuracy, and domain alignment. The method also significantly reduced training resource requirements, allowing scalable training on internal infrastructure.", "conclusion": "The combination of low-rank optimization and domain-specific instruction tuning enhances the performance and practicality of FMs for custom code generation. This solution is secure, cost-efficient, and does not depend on external APIs, supporting faster and more focused software innovation."}}
{"id": "2509.14623", "categories": ["cs.SE", "cs.AI", "cs.PL", "cs.SY", "eess.SY"], "pdf": "https://arxiv.org/pdf/2509.14623", "abs": "https://arxiv.org/abs/2509.14623", "authors": ["Hanlong Wan", "Xing Lu", "Yan Chen", "Karthik Devaprasad", "Laura Hinkle"], "title": "Automating Modelica Module Generation Using Large Language Models: A Case Study on Building Control Description Language", "comment": "This is the pre-peer-review version of a journal paper; the repo is\n  available at: https://github.com/pnnl/prompt2control", "summary": "Dynamic energy systems and controls require advanced modeling frameworks to\ndesign and test supervisory and fault tolerant strategies. Modelica is a widely\nused equation based language, but developing control modules is labor intensive\nand requires specialized expertise. This paper examines the use of large\nlanguage models (LLMs) to automate the generation of Control Description\nLanguage modules in the Building Modelica Library as a case study. We developed\na structured workflow that combines standardized prompt scaffolds, library\naware grounding, automated compilation with OpenModelica, and human in the loop\nevaluation. Experiments were carried out on four basic logic tasks (And, Or,\nNot, and Switch) and five control modules (chiller enable/disable, bypass valve\ncontrol, cooling tower fan speed, plant requests, and relief damper control).\nThe results showed that GPT 4o failed to produce executable Modelica code in\nzero shot mode, while Claude Sonnet 4 achieved up to full success for basic\nlogic blocks with carefully engineered prompts. For control modules, success\nrates reached 83 percent, and failed outputs required medium level human repair\n(estimated one to eight hours). Retrieval augmented generation often produced\nmismatches in module selection (for example, And retrieved as Or), while a\ndeterministic hard rule search strategy avoided these errors. Human evaluation\nalso outperformed AI evaluation, since current LLMs cannot assess simulation\nresults or validate behavioral correctness. Despite these limitations, the LLM\nassisted workflow reduced the average development time from 10 to 20 hours down\nto 4 to 6 hours per module, corresponding to 40 to 60 percent time savings.\nThese results highlight both the potential and current limitations of LLM\nassisted Modelica generation, and point to future research in pre simulation\nvalidation, stronger grounding, and closed loop evaluation.", "AI": {"tldr": "Automating Modelica control module generation with LLMs can save significant development time, but limitations in AI validation mean human intervention is still necessary. Careful workflow design improves success rates, pointing toward future research opportunities in simulation validation and improved grounding.", "motivation": "Designing robust control modules in Modelica for dynamic energy systems is labor-intensive and requires specialized skills, limiting adoption and efficiency in control systems engineering.", "method": "A structured workflow was developed that uses large language models (LLMs) to automate the generation of Control Description Language modules in Modelica. The workflow features prompt scaffolds, library-aware grounding, automated compilation, and human evaluation. Experiments tested both logic and control modules using GPT-4o and Claude Sonnet 4, as well as strategies like retrieval augmented generation and hard rule search.", "result": "GPT-4o did not generate executable code in zero-shot mode, while Claude Sonnet 4 succeeded for logic blocks with careful prompts. For control modules, an 83% success rate was achieved and faulty outputs required moderate human intervention. Hard rule search outperformed retrieval-based approaches. Human evaluation surpassed AI's validation abilities. The LLM-assisted workflow cut module development time by 40\u201360% (from 10\u201320 hours to 4\u20136 hours).", "conclusion": "LLMs can substantially accelerate Modelica module development, but current AI models struggle with simulation-based validation and behavioral correctness, requiring human oversight. Improvements in grounding, validation, and evaluation processes are needed for further automation."}}
{"id": "2509.14646", "categories": ["cs.SE", "cs.PL"], "pdf": "https://arxiv.org/pdf/2509.14646", "abs": "https://arxiv.org/abs/2509.14646", "authors": ["Yongpan Wang", "Xin Xu", "Xiaojie Zhu", "Xiaodong Gu", "Beijun Shen"], "title": "SALT4Decompile: Inferring Source-level Abstract Logic Tree for LLM-Based Binary Decompilation", "comment": "13 pages, 7 figures", "summary": "Decompilation is widely used in reverse engineering to recover high-level\nlanguage code from binary executables. While recent approaches leveraging Large\nLanguage Models (LLMs) have shown promising progress, they typically treat\nassembly code as a linear sequence of instructions, overlooking arbitrary jump\npatterns and isolated data segments inherent to binary files. This limitation\nsignificantly hinders their ability to correctly infer source code semantics\nfrom assembly code. To address this limitation, we propose \\saltm, a novel\nbinary decompilation method that abstracts stable logical features shared\nbetween binary and source code. The core idea of \\saltm is to abstract selected\nbinary-level operations, such as specific jumps, into a high-level logic\nframework that better guides LLMs in semantic recovery. Given a binary\nfunction, \\saltm constructs a Source-level Abstract Logic Tree (\\salt) from\nassembly code to approximate the logic structure of high-level language. It\nthen fine-tunes an LLM using the reconstructed \\salt to generate decompiled\ncode. Finally, the output is refined through error correction and symbol\nrecovery to improve readability and correctness. We compare \\saltm to three\ncategories of baselines (general-purpose LLMs, commercial decompilers, and\ndecompilation methods) using three well-known datasets (Decompile-Eval, MBPP,\nExebench). Our experimental results demonstrate that \\saltm is highly effective\nin recovering the logic of the source code, significantly outperforming\nstate-of-the-art methods (e.g., 70.4\\% TCP rate on Decompile-Eval with a 10.6\\%\nimprovement). The results further validate its robustness against four commonly\nused obfuscation techniques. Additionally, analyses of real-world software and\na user study confirm that our decompiled output offers superior assistance to\nhuman analysts in comprehending binary functions.", "AI": {"tldr": "SALTM leverages logic-tree abstraction to guide LLM-based decompilation, handling binary jumps/data segments missed by previous approaches. It beats existing methods in accuracy and robustness, aiding both automation and human reverse engineering.", "motivation": "Recent LLM-based decompilation methods fail to accurately reconstruct source code semantics because they treat assembly as a linear sequence, ignoring complex jumps and data segments. This limits their recovery of high-level logic from binaries.", "method": "The proposed method, SALTM, introduces a Source-level Abstract Logic Tree (SALT) to abstract logic features (such as jumps and operations) from binary code. SALTM fine-tunes an LLM on reconstructed logic trees to generate code, followed by error correction and symbol recovery to improve readability and correctness.", "result": "SALTM significantly outperforms previous state-of-the-art decompilers across multiple benchmarks (e.g., 70.4% TCP rate on Decompile-Eval with +10.6% improvement). It is robust against common obfuscation techniques and improves human analysts' comprehension in user studies.", "conclusion": "Abstracting binary logic and fine-tuning LLMs using logic trees enables more accurate and robust decompilation, enhancing both automatic semantic recovery and manual analysis."}}
{"id": "2509.14483", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14483", "abs": "https://arxiv.org/abs/2509.14483", "authors": ["Thanh-Long Bui", "Hoa Khanh Dam", "Rashina Hoda"], "title": "An LLM-based multi-agent framework for agile effort estimation", "comment": "Submitted to ASE'25", "summary": "Effort estimation is a crucial activity in agile software development, where\nteams collaboratively review, discuss, and estimate the effort required to\ncomplete user stories in a product backlog. Current practices in agile effort\nestimation heavily rely on subjective assessments, leading to inaccuracies and\ninconsistencies in the estimates. While recent machine learning-based methods\nshow promising accuracy, they cannot explain or justify their estimates and\nlack the capability to interact with human team members. Our paper fills this\nsignificant gap by leveraging the powerful capabilities of Large Language\nModels (LLMs). We propose a novel LLM-based multi-agent framework for agile\nestimation that not only can produce estimates, but also can coordinate,\ncommunicate and discuss with human developers and other agents to reach a\nconsensus. Evaluation results on a real-life dataset show that our approach\noutperforms state-of-the-art techniques across all evaluation metrics in the\nmajority of the cases. Our human study with software development practitioners\nalso demonstrates an overwhelmingly positive experience in collaborating with\nour agents in agile effort estimation.", "AI": {"tldr": "This paper introduces an LLM-powered multi-agent system for agile effort estimation that not only surpasses existing methods in accuracy, but also enables interactive collaboration with human developers, addressing key limitations of current machine learning solutions.", "motivation": "Effort estimation in agile software development is vital but is currently plagued by subjective judgments, resulting in inaccurate and inconsistent estimates. Existing machine learning approaches lack transparency and interactive capabilities.", "method": "The paper proposes a novel multi-agent framework based on Large Language Models (LLMs) for agile effort estimation. This framework can produce estimates, coordinate, communicate, and discuss with human developers and other agents to reach consensus.", "result": "On a real-life dataset, the proposed framework outperforms state-of-the-art techniques across most evaluation metrics. Additionally, a human study demonstrates a highly positive experience for practitioners interacting with the agents.", "conclusion": "The LLM-based multi-agent approach effectively improves estimation accuracy and consistency in agile software development, while enhancing collaborative interactions between humans and AI agents."}}
{"id": "2509.15150", "categories": ["cs.SE", "cs.PL", "D.2.6; D.3.3; D.2.3; D.2.5; D.2.13"], "pdf": "https://arxiv.org/pdf/2509.15150", "abs": "https://arxiv.org/abs/2509.15150", "authors": ["Federico Bruzzone", "Walter Cazzola", "Luca Favalli"], "title": "Code Less to Code More: Streamlining Language Server Protocol and Type System Development for Language Families", "comment": "34 pages, 10 figures, Journal of Systems and Software, June 2025, for\n  the replication package, see https://doi.org/10.5281/zenodo.15276991", "summary": "Developing editing support for $L$ languages in $E$ editors is complex and\ntime-consuming. Some languages do not provide dedicated editors, while others\noffer a single native editor. The $\\textit{language server protocol}$ (LSP)\nreduces the language-editor combinations $L \\times E$ to $L + E$, where a\nsingle language server communicates with editors via LSP plugins. However,\noverlapping implementations of linguistic components remain an issue. Existing\nlanguage workbenches struggle with modularity, reusability, and leveraging type\nsystems for language server generation. In this work, we propose: (i) Typelang,\na family of domain-specific languages for modular, composable, and reusable\ntype system implementation, (ii) a modular language server generation process,\nproducing servers for languages built in a modular workbench, (iii) the\nvariant-oriented programming paradigm and a cross-artifact coordination layer\nto manage interdependent software variants, and (iv) an LSP plugin generator,\nreducing $E$ to $1$ by automating plugin creation for multiple editors. To\nsimplify editing support for language families, each language artifact\nintegrates its own Typelang variant, used to generate language servers. This\nreduces combinations to $T \\times 1$, where $T = L$ represents the number of\ntype systems. Further reuse of language artifacts across languages lowers this\nto $N \\times 1$, where $N << T$, representing unique type systems. We implement\nTypelang in Neverlang, generating language servers for each artifact and LSP\nplugins for three editors. Empirical evaluation shows a 93.48% reduction in\ncharacters needed for type system implementation and 100% automation of LSP\nplugin generation, significantly lowering effort for editing support in\nlanguage families, especially when artifacts are reused.", "AI": {"tldr": "This paper introduces the Typelang family and several modular automation approaches for editing support in language families, demonstrating drastic reductions in code and manual effort via empirical results.", "motivation": "Supporting multiple programming languages in multiple editors is complex and resource-intensive. Existing approaches lack modularity, reusability, and exploitation of type systems, making language server and plugin generation inefficient.", "method": "The authors propose a suite of solutions: Typelang (domain-specific languages for modular/reusable type systems), a modular language server generation process, a variant-oriented programming paradigm, a cross-artifact coordination layer, and an LSP plugin generator. These are implemented in the Neverlang language workbench and empirically evaluated.", "result": "Their approach produces modular language servers and automates LSP plugin generation for three editors. Evaluation shows a 93.48% reduction in code required for type system implementation and full automation of plugin generation, leading to significantly reduced development effort.", "conclusion": "The solutions described greatly reduce the effort required to support editing for language families, especially when language artifacts can be reused. By simplifying and automating server and plugin generation, they facilitate better modularity and reusability in language workbenches."}}
{"id": "2509.14626", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14626", "abs": "https://arxiv.org/abs/2509.14626", "authors": ["Feiran Qin", "M. M. Abid Naziri", "Hengyu Ai", "Saikat Dutta", "Marcelo d'Amorim"], "title": "Evaluating the Effectiveness of Coverage-Guided Fuzzing for Testing Deep Learning Library APIs", "comment": null, "summary": "Deep Learning (DL) libraries such as PyTorch provide the core components to\nbuild major AI-enabled applications. Finding bugs in these libraries is\nimportant and challenging. Prior approaches have tackled this by performing\neither API-level fuzzing or model-level fuzzing, but they do not use coverage\nguidance, which limits their effectiveness and efficiency. This raises an\nintriguing question: can coverage guided fuzzing (CGF), in particular\nframeworks like LibFuzzer, be effectively applied to DL libraries, and does it\noffer meaningful improvements in code coverage, bug detection, and scalability\ncompared to prior methods?\n  We present the first in-depth study to answer this question. A key challenge\nin applying CGF to DL libraries is the need to create a test harness for each\nAPI that can transform byte-level fuzzer inputs into valid API inputs. To\naddress this, we propose FlashFuzz, a technique that leverages Large Language\nModels (LLMs) to automatically synthesize API-level harnesses by combining\ntemplates, helper functions, and API documentation. FlashFuzz uses a feedback\ndriven strategy to iteratively synthesize and repair harnesses. With this\napproach, FlashFuzz synthesizes harnesses for 1,151 PyTorch and 662 TensorFlow\nAPIs. Compared to state-of-the-art fuzzing methods (ACETest, PathFinder, and\nTitanFuzz), FlashFuzz achieves up to 101.13 to 212.88 percent higher coverage\nand 1.0x to 5.4x higher validity rate, while also delivering 1x to 1182x\nspeedups in input generation. FlashFuzz has discovered 42 previously unknown\nbugs in PyTorch and TensorFlow, 8 of which are already fixed. Our study\nconfirms that CGF can be effectively applied to DL libraries and provides a\nstrong baseline for future testing approaches.", "AI": {"tldr": "FlashFuzz uses LLMs to automatically generate harnesses for coverage guided fuzzing of deep learning libraries, achieving much higher coverage, speed, and bug detection than existing fuzzers. It sets a new baseline for testing tools in this domain.", "motivation": "Deep Learning libraries like PyTorch are essential for building AI applications, but finding bugs in these libraries is particularly difficult. Traditional fuzzing techniques for these libraries lack coverage guidance, thus reducing their efficiency and effectiveness. The motivation here is to determine whether coverage guided fuzzing (CGF), particularly tools like LibFuzzer, can be successfully adapted to improve bug detection, code coverage, and scalability in DL libraries.", "method": "The paper presents FlashFuzz, a novel approach that utilizes Large Language Models (LLMs) to automatically generate API-level fuzzing harnesses for DL libraries. This is achieved by synthesizing harnesses using templates, helper functions, and API documentation. FlashFuzz employs a feedback-driven strategy to iteratively create and refine these harnesses, enabling effective application of CGF to libraries like PyTorch and TensorFlow.", "result": "FlashFuzz synthesizes harnesses for over 1,100 PyTorch APIs and 662 TensorFlow APIs. It achieves significantly higher coverage (up to 212.88% more) and higher input validity (up to 5.4 times more) compared to previous fuzzing tools, as well as massive speedups in input generation (up to 1182x). Moreover, FlashFuzz discovers 42 unknown bugs, 8 of which have already been resolved.", "conclusion": "Coverage guided fuzzing, when enhanced with automated harness synthesis using LLMs, can be effectively applied to deep learning libraries. FlashFuzz sets a new benchmark for fuzzing these libraries, demonstrating notable improvements in code coverage, bug detection, and efficiency compared to prior methods."}}
{"id": "2509.14740", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14740", "abs": "https://arxiv.org/abs/2509.14740", "authors": ["Andrei-Raoul Morariu", "Andreas Strandberg", "Bogdan Iancu", "Jerker Bjorkqvist"], "title": "Wireless Communication Performance Testing: From Laboratory Environment to Research Vessel", "comment": "5 pages, 4 figures, 2 tables", "summary": "This study investigates signal transmission within a shared spectrum,\nfocusing on measurements conducted both in laboratory and outdoor environments.\nThe objective was to demonstrate how laboratory objects obstructing the line of\nsight can attenuate the signal between a transmitter (Tx) and a receiver (Rx).\nAdditionally, we examined the impact of distance and placement in various\nlocations aboard an electric research boat on signal transmission efficiency.\nThese findings contribute to understanding whether the environmental factors\ninfluence wireless communication in dynamic and obstructed environments.", "AI": {"tldr": "The paper demonstrates that obstacles and dynamic environments, like those encountered on boats or in labs, degrade wireless signal transmission, emphasizing the need to consider these factors when designing communication systems.", "motivation": "The study aims to determine how real-world environmental factors, such as obstacles and dynamic placement, influence the quality of wireless communication in shared spectrum settings.", "method": "Signal transmission was measured both in laboratory conditions and on an electric research boat, with varying distances and object placements between the transmitter and receiver.", "result": "Laboratory objects attenuated the signal when obstructing the line of sight, and placement and distance on the boat also influenced transmission efficiency, confirming that environmental factors critically affect communication.", "conclusion": "Environmental obstacles and placement aboard vehicles significantly affect wireless signal transmission efficiency, indicating that communication performance can degrade in obstructed or dynamic settings."}}
{"id": "2509.14744", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14744", "abs": "https://arxiv.org/abs/2509.14744", "authors": ["Worawalan Chatlatanagulchai", "Kundjanasith Thonglek", "Brittany Reid", "Yutaro Kashiwa", "Pattara Leelaprute", "Arnon Rungsawang", "Bundit Manaskasemsak", "Hajimu Iida"], "title": "On the Use of Agentic Coding Manifests: An Empirical Study of Claude Code", "comment": null, "summary": "Agentic coding tools receive goals written in natural language as input,\nbreak them down into specific tasks, and write/execute the actual code with\nminimal human intervention. Key to this process are agent manifests,\nconfiguration files (such as Claude.md) that provide agents with essential\nproject context, identity, and operational rules. However, the lack of\ncomprehensive and accessible documentation for creating these manifests\npresents a significant challenge for developers. We analyzed 253 Claude.md\nfiles from 242 repositories to identify structural patterns and common content.\nOur findings show that manifests typically have shallow hierarchies with one\nmain heading and several subsections, with content dominated by operational\ncommands, technical implementation notes, and high-level architecture.", "AI": {"tldr": "The paper analyzed hundreds of agent manifest files, revealing simple structural patterns and content focused on operational use and technical details, emphasizing the documentation gap for developers.", "motivation": "To address the challenge faced by developers due to the insufficient documentation available for creating agent manifests in agentic coding tools.", "method": "Analysis of 253 Claude.md files from 242 repositories to identify recurring structural and content patterns within agent manifests.", "result": "The study demonstrates that Claude.md manifests are generally organized with one main heading and several subsections, containing predominantly operational commands, technical notes, and architectural overviews.", "conclusion": "Agent manifests commonly feature shallow hierarchical structures, focusing on operational commands, implementation notes, and architecture, which reflects current usage patterns but highlights a lack of comprehensive documentation."}}
{"id": "2509.14745", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14745", "abs": "https://arxiv.org/abs/2509.14745", "authors": ["Miku Watanabe", "Hao Li", "Yutaro Kashiwa", "Brittany Reid", "Hajimu Iida", "Ahmed E. Hassan"], "title": "On the Use of Agentic Coding: An Empirical Study of Pull Requests on GitHub", "comment": null, "summary": "Large language models (LLMs) are increasingly being integrated into software\ndevelopment processes. The ability to generate code and submit pull requests\nwith minimal human intervention, through the use of autonomous AI agents, is\npoised to become a standard practice. However, little is known about the\npractical usefulness of these pull requests and the extent to which their\ncontributions are accepted in real-world projects. In this paper, we\nempirically study 567 GitHub pull requests (PRs) generated using Claude Code,\nan agentic coding tool, across 157 diverse open-source projects. Our analysis\nreveals that developers tend to rely on agents for tasks such as refactoring,\ndocumentation, and testing. The results indicate that 83.8% of these\nagent-assisted PRs are eventually accepted and merged by project maintainers,\nwith 54.9% of the merged PRs are integrated without further modification. The\nremaining 45.1% require additional changes benefit from human revisions,\nespecially for bug fixes, documentation, and adherence to project-specific\nstandards. These findings suggest that while agent-assisted PRs are largely\nacceptable, they still benefit from human oversight and refinement.", "AI": {"tldr": "Agent-generated pull requests are widely accepted in open-source projects, but nearly half still require human improvement before full integration.", "motivation": "To assess the practical usefulness and acceptance of autonomous AI agent-generated pull requests in real-world software development environments.", "method": "Empirical analysis of 567 GitHub pull requests generated by Claude Code agent across 157 open-source projects, examining acceptance rates and revisions.", "result": "83.8% of agent-assisted PRs were accepted and merged, with 54.9% merged without further modification. 45.1% needed additional human revisions, mainly for bug fixes, documentation, and compliance with project standards.", "conclusion": "Agent-assisted pull requests are highly accepted in open-source projects, with most being merged, though a significant proportion still require human revision."}}
{"id": "2509.14829", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14829", "abs": "https://arxiv.org/abs/2509.14829", "authors": ["Shuo Jin", "Songqiang Chen", "Xiaoyuan Xie", "Shing-Chi Cheung"], "title": "RulER: Automated Rule-Based Semantic Error Localization and Repair for Code Translation", "comment": "Due to the limitation \"The abstract field cannot be longer than 1,920\n  characters\", the abstract here is shorter than that in the PDF file", "summary": "Automated code translation aims to convert programs between different\nprogramming languages while maintaining their functionality. Due to the\nimperfections of code translation models, the generated translations may\ncontain errors that compromise their reliability. Existing automated debugging\nmethods for code translation rely on code alignments and repair patch templates\nto locate and fix erroneous translations. However, existing methods lack\nreliable references to construct code alignments and design repair patch\ntemplates, which significantly impacts their localization accuracy and repair\neffectiveness. To address these limitations, we reintroduce code translation\nrules and propose a rule-based debugging method for code translation, called\nRulER. RulER automatically derives code translation rules from correct\ntranslations generated by LLMs, enabling the efficient collection of diverse\ntranslation rules. In addition, RulER dynamically combines the existing rules\non expandable nodes like expressions and tokens to further adaptively align\nmore statements. These rules capture clear and detailed structural\ncorrespondences between source and target programming languages. Therefore,\nthey can serve as reliable and reusable references for code alignment and\nrepair template design, enabling RulER to locate and fix translation errors\neffectively. Our evaluation of RulER on Java-to-C++ and Python-to-C++\ntranslations produced by four code translation models demonstrates that RulER\noutperforms state-of-the-art methods, BatFix and TransMap. Our experimental\nresults show that RulER outperformed the best baseline by 20% and 272% in terms\nof error localization rates and repair success rates, respectively. RulER\nexhibits superior repair performance compared to directly prompting LLMs for\npatch generation, demonstrating a promising methodology for extracting and\nleveraging coding knowledge from LLMs.", "AI": {"tldr": "RulER introduces a rule-based debugging method for automated code translation, effectively improving error localization and repair success rates by leveraging reusable and dynamically derived translation rules. It notably outperforms leading models and LLM-prompting approaches.", "motivation": "Existing methods for automated code debugging in translation lack reliable references for code alignment and repair, reducing their effectiveness. The paper aims to overcome this by introducing a systematic and reusable approach based on translation rules.", "method": "RulER is a rule-based debugging approach that derives translation rules from correct LLM-generated translations and dynamically combines these rules to align and repair code statements. RulER enables reliable code alignment and repair template construction for debugging translations.", "result": "RulER outperformed BatFix and TransMap by 20% in error localization and 272% in repair success rates across Java-to-C++ and Python-to-C++ translations from four code translators. It also demonstrated superior repair capabilities compared to prompting LLMs directly.", "conclusion": "RulER significantly improves error localization and repair success rates compared to existing automated debugging methods in code translation, outperforming state-of-the-art models substantially."}}
{"id": "2509.14856", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14856", "abs": "https://arxiv.org/abs/2509.14856", "authors": ["Hanyang Guo", "Xunjin Zheng", "Zihan Liao", "Hang Yu", "Peng DI", "Ziyin Zhang", "Hong-Ning Dai"], "title": "CodeFuse-CR-Bench: A Comprehensiveness-aware Benchmark for End-to-End Code Review Evaluation in Python Projects", "comment": null, "summary": "Automated code review (CR) is a key application for Large Language Models\n(LLMs), but progress is hampered by a \"reality gap\": existing benchmarks\nevaluate models on isolated sub-tasks using simplified, context-poor data. This\nfails to reflect the holistic context-rich nature of real-world CR. To bridge\nthis gap, we introduce CodeFuse-CR-Bench, the first comprehensiveness-aware\nbenchmark for repository-level CR evaluation. CodeFuse-CR-Bench comprises 601\nhigh-quality instances from 70 Python projects covering nine Pull-Request (PR)\nproblem domains, where each instance provides rich, multi-faceted context\nincluding the associated issue, PR details, and repository state, enabling\nend-to-end evaluation. Beyond superficial metrics, we also propose a novel\nevaluation framework that combines rule-based checks for location and syntax\nwith model-based judgments of review quality. We present the first large-scale\nassessment of state-of-the-art LLMs on this comprehensive CR task. Our results\nestablish crucial baselines and reveal that (1) no single LLM dominates all\naspects of CR; (2) Gemini 2.5 Pro achieves the highest comprehensive\nperformance; and (3) different LLMs exhibit varying robustness to redundant\ncontext. These findings highlight the necessity of holistic, multi-dimensional\nevaluation and provide actionable insights for advancing truly intelligent yet\npractical CR assistants.", "AI": {"tldr": "CodeFuse-CR-Bench introduces a comprehensive and context-rich benchmark for repository-level code review, enabling nuanced evaluation of LLMs. Results show varied strengths among models, highlighting the need for multidimensional testing to progress toward truly effective code review assistants.", "motivation": "Current benchmarks for automated code review using LLMs are insufficient because they lack holistic and context-rich evaluation, which limits real-world applicability. Existing methods focus only on isolated tasks with simplified data, not capturing the complexity of genuine repository-level code review.", "method": "The authors introduce CodeFuse-CR-Bench, a new benchmark that features 601 instances spanning 70 Python repositories and nine pull-request domains, each containing multifaceted real-world context. They also develop an evaluation framework combining rule-based syntax/location checks with model-based quality judgments, enabling end-to-end assessments.", "result": "The benchmark reveals that no single LLM excels in all code review aspects. Gemini 2.5 Pro performs best overall but robustness and strengths vary across models, especially when handling redundant or complex context.", "conclusion": "Holistic, multi-dimensional evaluation is essential for advancing practical and intelligent code review tools. This work sets vital baselines and emphasizes the need for comprehensive, context-rich evaluation methods in LLM-driven code review research."}}
{"id": "2509.14899", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2509.14899", "abs": "https://arxiv.org/abs/2509.14899", "authors": ["Amine Barrak", "Yosr Fourati", "Michael Olchawa", "Emna Ksontini", "Khalil Zoghlami"], "title": "CARGO: A Framework for Confidence-Aware Routing of Large Language Models", "comment": null, "summary": "As large language models (LLMs) proliferate in scale, specialization, and\nlatency profiles, the challenge of routing user prompts to the most appropriate\nmodel has become increasingly critical for balancing performance and cost. We\nintroduce CARGO (Category-Aware Routing with Gap-based Optimization), a\nlightweight, confidence-aware framework for dynamic LLM selection. CARGO\nemploys a single embedding-based regressor trained on LLM-judged pairwise\ncomparisons to predict model performance, with an optional binary classifier\ninvoked when predictions are uncertain. This two-stage design enables precise,\ncost-aware routing without the need for human-annotated supervision. To capture\ndomain-specific behavior, CARGO also supports category-specific regressors\ntrained across five task groups: mathematics, coding, reasoning, summarization,\nand creative writing. Evaluated on four competitive LLMs (GPT-4o, Claude 3.5\nSonnet, DeepSeek V3, and Perplexity Sonar), CARGO achieves a top-1 routing\naccuracy of 76.4% and win rates ranging from 72% to 89% against individual\nexperts. These results demonstrate that confidence-guided, lightweight routing\ncan achieve expert-level performance with minimal overhead, offering a\npractical solution for real-world, multi-model LLM deployments.", "AI": {"tldr": "CARGO is a lightweight, confidence-aware framework for choosing the best LLM for a given prompt. It combines embedding-based regressors and a binary classifier to achieve high routing accuracy and expert-level performance across multiple LLMs and task categories, all without requiring human supervision.", "motivation": "With the increasing variety and specialization of large language models (LLMs), it is challenging to dynamically select the best model for each user prompt while balancing performance and cost.", "method": "The authors propose CARGO, a two-stage framework for model selection. CARGO uses embedding-based regressors trained on pairwise LLM comparisons to predict which model would perform best for a given prompt. When predictions are uncertain, an auxiliary binary classifier refines the decision. CARGO also incorporates category-specific regressors for different types of tasks.", "result": "CARGO achieves a top-1 routing accuracy of 76.4% and win rates between 72% and 89% against individual expert models when tested on four leading LLMs across five task categories.", "conclusion": "CARGO delivers expert-level performance for dynamic LLM selection, enabling more effective and cost-efficient multi-model deployments with minimal overhead and no need for human-annotated supervision."}}
{"id": "2509.14931", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.14931", "abs": "https://arxiv.org/abs/2509.14931", "authors": ["Stefano Fossati", "Damian Andrew Tamburri", "Massimiliano Di Penta", "Marco Tonnarelli"], "title": "\"Let it be Chaos in the Plumbing!\" Usage and Efficacy of Chaos Engineering in DevOps Pipelines", "comment": "To be published in the Proceedings of International Conference on\n  Software Maintenance and Evolution 2025", "summary": "Chaos Engineering (CE) has emerged as a proactive method to improve the\nresilience of modern distributed systems, particularly within DevOps\nenvironments. Originally pioneered by Netflix, CE simulates real-world failures\nto expose weaknesses before they impact production. In this paper, we present a\nsystematic gray literature review that investigates how industry practitioners\nhave adopted and adapted CE principles over recent years. Analyzing 50 sources\npublished between 2019 and early 2024, we developed a comprehensive\nclassification framework that extends the foundational CE principles into ten\ndistinct concepts. Our study reveals that while the core tenets of CE remain\ninfluential, practitioners increasingly emphasize controlled experimentation,\nautomation, and risk mitigation strategies to align with the demands of agile\nand continuously evolving DevOps pipelines. Our results enhance the\nunderstanding of how CE is intended and implemented in practice, and offer\nguidance for future research and industrial applications aimed at improving\nsystem robustness in dynamic production environments.", "AI": {"tldr": "This paper systematically reviews industry adoption of Chaos Engineering in DevOps, finding adaptation of its principles to favor control, automation, and risk reduction, and provides a framework and guidance for future improvements in resilient system design.", "motivation": "Chaos Engineering is important for improving resilience in distributed systems, but there is limited systematic study of its real-world adoption and evolution within industry, especially in DevOps settings.", "method": "A systematic gray literature review of 50 industry sources from 2019 to early 2024 was conducted. The authors created a classification framework that extends existing Chaos Engineering principles into ten distinct concepts.", "result": "Practitioners still value the original Chaos Engineering principles, but there is growing emphasis on controlled experimentation, increased automation, and new risk mitigation strategies to suit agile, fast-changing DevOps environments.", "conclusion": "The paper provides a deeper understanding of how Chaos Engineering is applied in practice, highlights evolving priorities, and offers recommendations for research and practice to improve system robustness in modern production environments."}}
{"id": "2509.15195", "categories": ["cs.SE", "cs.AI", "cs.CR", "D.4.6; I.2.2; D.2.5"], "pdf": "https://arxiv.org/pdf/2509.15195", "abs": "https://arxiv.org/abs/2509.15195", "authors": ["Max Bazalii", "Marius Fleischer"], "title": "Orion: Fuzzing Workflow Automation", "comment": "11 pages, 3 figures, 3 tables", "summary": "Fuzz testing is one of the most effective techniques for finding software\nvulnerabilities. While modern fuzzers can generate inputs and monitor\nexecutions automatically, the overall workflow, from analyzing a codebase, to\nconfiguring harnesses, to triaging results, still requires substantial manual\neffort. Prior attempts focused on single stages such as harness synthesis or\ninput minimization, leaving researchers to manually connect the pieces into a\ncomplete fuzzing campaign.\n  We introduce Orion, a framework that automates the the manual bottlenecks of\nfuzzing by integrating LLM reasoning with traditional tools, allowing campaigns\nto scale to settings where human effort alone was impractical. Orion uses LLMs\nfor code reasoning and semantic guidance, while relying on deterministic tools\nfor verification, iterative refinement, and tasks that require precision.\nAcross our benchmark suite, Orion reduces human effort by 46-204x depending on\nthe workflow stage, and we demonstrate its effectiveness through the discovery\nof two previously unknown vulnerabilities in the widely used open-source clib\nlibrary.", "AI": {"tldr": "Orion leverages LLMs and deterministic tools to automate fuzz testing, drastically minimizing human effort and uncovering new vulnerabilities.", "motivation": "Fuzz testing is highly effective for detecting software vulnerabilities, but its full workflow is labor-intensive, requiring manual work in code analysis, harness configuration, and result triage. Previous solutions addressed isolated stages, not the entire campaign.", "method": "Orion is a framework that automates fuzz testing workflows by integrating large language model (LLM) reasoning for code analysis and semantic guidance with traditional deterministic tools for verification and refinement.", "result": "Orion reduces human effort by 46-204x across various workflow stages and discovers two new vulnerabilities in the open-source clib library.", "conclusion": "Orion successfully automates significant portions of the fuzz testing process, making large-scale campaigns feasible and greatly reducing the need for manual intervention."}}

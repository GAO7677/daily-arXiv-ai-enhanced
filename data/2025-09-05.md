<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 12]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Towards the Datasets Used in Requirements Engineering of Mobile Apps: Preliminary Findings from a Systematic Mapping Study](https://arxiv.org/abs/2509.03541)
*Chong Wang,Haoning Wu,Peng Liang,Maya Daneva,Marten van Sinderen*

Main category: cs.SE

TL;DR: Most mobile app RE research relies on Google Play and Apple App Store datasets, mainly focusing on elicitation and analysis activities. Thereâ€™s a growing trend to use more diverse data sources, but further efforts are needed for broader and more generalizable findings.


<details>
  <summary>Details</summary>
Motivation: The motivation for this paper is the lack of understanding about the sources of datasets used in requirements engineering (RE) research for mobile apps, specifically regarding the platforms they originate from and the specific RE activities they support.

Method: The authors conducted a systematic mapping study following the guidelines of Kitchenham et al., analyzing 43 selected research papers to investigate dataset sources and their application to RE activities in mobile app research.

Result: The study found that over 90% of these studies use datasets from Google Play or Apple App Store. It also revealed that requirements elicitation and analysis are the most researched RE activities using these datasets. There is a recent trend of supplementing app review data with other sources.

Conclusion: The conclusions drawn are: (1) increasing use of datasets from 2012 onward; (2) potential bias in RE knowledge for mobile apps due to the heavy reliance on Google Play and Apple App Store datasets; (3) attempts to incorporate additional data sources exist, but more are needed; (4) expanding both data sources and focus on diverse RE activities is necessary for more generalizable research outcomes.

Abstract: [Background] Research on requirements engineering (RE) for mobile apps
employs datasets formed by app users, developers or vendors. However, little is
known about the sources of these datasets in terms of platforms and the RE
activities that were researched with the help of the respective datasets.
[Aims] The goal of this paper is to investigate the state-of-the-art of the
datasets of mobile apps used in existing RE research. [Method] We carried out a
systematic mapping study by following the guidelines of Kitchenham et al.
[Results] Based on 43 selected papers, we found that Google Play and Apple App
Store provide the datasets for more than 90% of published research in RE for
mobile apps. We also found that the most investigated RE activities - based on
datasets, are requirements elicitation and requirements analysis. [Conclusions]
Our most important conclusions are: (1) there is a growth in the use of
datasets for RE research of mobile apps since 2012, (2) the RE knowledge for
mobile apps might be skewed due to the overuse of Google Play and Apple App
Store, (3) there are attempts to supplement reviews of apps from repositories
with other data sources, (4) there is a need to expand the alternative sources
and experiments with complimentary use of multiple sources, if the community
wants more generalizable results. Plus, it is expected to expand the research
on other RE activities, beyond elicitation and analysis.

</details>


### [2] [A Multi-stage Error Diagnosis for APB Transaction](https://arxiv.org/abs/2509.03554)
*Cheng-Yang Tsai,Tzu-Wei Huang,Jen-Wei Shih,I-Hsiang Wang,Yu-Cheng Lin,Rung-Bin Lin*

Main category: cs.SE

TL;DR: This paper presents a hierarchical Random Forest-based approach to automate APB error diagnosis in SoC design, achieving high accuracy and top performance in a major CAD contest, proving ML's potential for EDA hardware debugging tasks.


<details>
  <summary>Details</summary>
Motivation: Manual detection of APB transaction errors in large VCD files during SoC design is inefficient and prone to mistakes. Faster, reliable automated methods are needed for verification and debugging.

Method: A hierarchical Random Forest-based architecture is used, employing four pre-trained binary classifiers in a multi-stage error diagnosis framework. The classifiers sequentially detect Out-of-Range Access, Address Corruption, and Data Corruption errors, focusing first on address errors before data errors for efficiency.

Result: The proposed method achieves 91.36% accuracy, with near-perfect precision and recall for address-related errors and robust data error detection. The team achieved first place in the beta stage of the ICCAD 2025 CAD Contest.

Conclusion: Hierarchical machine learning can provide powerful and automated solutions for hardware error diagnosis in EDA, significantly improving efficiency and reliability over manual methods.

Abstract: Functional verification and debugging are critical bottlenecks in modern
System-on-Chip (SoC) design, with manual detection of Advanced Peripheral Bus
(APB) transaction errors in large Value Change Dump (VCD) files being
inefficient and error-prone. Addressing the 2025 ICCAD Contest Problem D, this
study proposes an automated error diagnosis framework using a hierarchical
Random Forest-based architecture. The multi-stage error diagnosis employs four
pre-trained binary classifiers to sequentially detect Out-of-Range Access,
Address Corruption, and Data Corruption errors, prioritizing high-certainty
address-related faults before tackling complex data errors to enhance
efficiency. Experimental results show an overall accuracy of 91.36%, with
near-perfect precision and recall for address errors and robust performance for
data errors. Although the final results of the ICCAD 2025 CAD Contest are yet
to be announced as of the submission date, our team achieved first place in the
beta stage, highlighting the method's competitive strength. This research
validates the potential of hierarchical machine learning as a powerful
automated tool for hardware debugging in Electronic Design Automation (EDA).

</details>


### [3] [Parse Tree Tracking Through Time for Programming Process Analysis at Scale](https://arxiv.org/abs/2509.03668)
*Matt Rau,Chris Brown,John Edwards*

Main category: cs.SE

TL;DR: This paper introduces algorithms to automatically track parse tree changes in student code over time, enabling large-scale and detailed analysis of student programming behavior, and unlocks new avenues for measuring code development, difficulties, and habits.


<details>
  <summary>Details</summary>
Motivation: Traditional programming process data focuses mainly on keystrokes, deletions, or high-level descriptive statistics. More contextual behavioral analysis, such as time spent on specific syntactic constructs (loops, conditionals), has been difficult due to the challenge of tracking high-level code representations (parse/abstract syntax trees) over time, especially through unparseable code states.

Method: The researchers designed two algorithms: one to track parse tree nodes over time and another to create tree representations even when student code is unparseable. They implemented these algorithms on public keystroke data collected from a 2021 CS1 course and conducted various analyses on the resulting parse trees.

Result: They identified new, previously unobservable statistics, such as similar code deletion rates inside and outside loops/conditionals, about one-third of commented out code is eventually restored, and that frequent code navigation by students may not necessarily indicate struggle.

Conclusion: Automatic tracking of parse trees over time enables scalable and in-depth analyses of student programming processes, paving the way for understanding structural code development, quantifying student struggles with specific constructs, and analyzing code editing behavior and focus shifts.

Abstract: Background and Context: Programming process data can be utilized to
understand the processes students use to write computer programming
assignments. Keystroke- and line-level event logs have been used in the past in
various ways, primarily in high-level descriptive statistics (e.g., timings,
character deletion rate, etc). Analysis of behavior in context (e.g., how much
time students spend working on loops) has been cumbersome because of our
inability to automatically track high-level code representations, such as
abstract syntax trees, through time and unparseable states.
  Objective: Our study has two goals. The first is to design the first
algorithm that tracks parse tree nodes through time. Second, we utilize this
algorithm to perform a partial replication study of prior work that used manual
tracking of code representations, as well as other novel analyses of student
programming behavior that can now be done at scale.
  Method: We use two algorithms presented in this paper to track parse tree
nodes through time and construct tree representations for unparseable code
states. We apply these algorithms to a public keystroke data from student
coursework in a 2021 CS1 course and conduct analysis on the resulting parse
trees.
  Findings: We discover newly observable statistics at scale, including that
code is deleted at similar rates inside and outside of conditionals and loops,
a third of commented out code is eventually restored, and that frequency with
which students jump around in their code may not be indicative of struggle.
  Implications: The ability to track parse trees through time opens the door to
understanding new dimensions of student programming, such as best practices of
structural development of code over time, quantitative measurement of what
syntactic constructs students struggle most with, refactoring behavior, and
attention shifting within the code.

</details>


### [4] [Towards an Understanding of Developer Experience-Driven Transparency in Software Ecosystems](https://arxiv.org/abs/2509.03848)
*Rodrigo Oliveira Zacarias,Rodrigo Pereira dos Santos,Patricia Lago*

Main category: cs.SE

TL;DR: The paper proposes a comprehensive conceptual model (SECO-TransDX) to systematically understand how transparency impacts developer experience in software ecosystems, offering insights for both researchers and practitioners to enhance trust and engagement.


<details>
  <summary>Details</summary>
Motivation: While software ecosystems (SECO) are central to modern software development, the role of transparency in shaping Developer Experience (DX) is not well understood or systematically conceptualized, even though transparency is noted as vital for trust, fairness, and engagement.

Method: The authors proposed SECO-TransDX, a conceptual model built upon prior research and refined via a Delphi study involving experts from both academia and industry. The model identifies and organizes 63 concepts affecting transparency and developer experience in SECO.

Result: SECO-TransDX offers a detailed, structured perspective on the factors influencing transparency from a developer experience standpoint, categorizing conditioning factors, ecosystem procedures, artifacts, and relational dynamics. The framework clarifies how transparency operates at technical, social, and organizational layers within SECO.

Conclusion: The work introduces a robust conceptual model that advances the theoretical foundation of transparency in software ecosystems from a developer-centered view, facilitating future research and practical improvements in platform and tool design, ultimately intended to enhance developer trust and long-term engagement.

Abstract: Software ecosystems (SECO) have become a dominant paradigm in the software
industry, enabling third-party developers to co-create value through
complementary components and services. While Developer Experience (DX) is
increasingly recognized as critical for sustainable SECO, transparency remains
an underexplored factor shaping how developers perceive and interact with
ecosystems. Existing studies acknowledge transparency as essential for trust,
fairness, and engagement, yet its relationship with DX has not been
systematically conceptualized. Hence, this work aims to advance the
understanding of transparency in SECO from a developer-centered perspective. To
this end, we propose SECO-TransDX (Transparency in Software Ecosystems from a
Developer Experience Perspective), a conceptual model that introduces the
notion of DX-driven transparency. The model identifies 63 interrelated
concepts, including conditioning factors, ecosystem procedures, artifacts, and
relational dynamics that influence how transparency is perceived and
constructed during developer interactions. SECO-TransDX was built upon prior
research and refined through a Delphi study with experts from academia and
industry. It offers a structured lens to examine how transparency mediates DX
across technical, social, and organizational layers. For researchers, it lays
the groundwork for future studies and tool development; for practitioners, it
supports the design of trustworthy, developer-centered platforms that improve
transparency and foster long-term engagement in SECO.

</details>


### [5] [VulRTex: A Reasoning-Guided Approach to Identify Vulnerabilities from Rich-Text Issue Report](https://arxiv.org/abs/2509.03875)
*Ziyou Jiang,Mingyang Li,Guowei Yang,Lin Shi,Qing Wang*

Main category: cs.SE

TL;DR: The paper introduces VulRTex, a reasoning-guided method that leverages large language models to identify vulnerability-related issue reports in open-source software by utilizing rich-text information, surpassing prior methods in accuracy and efficiency and proving practical value in real-world OSS projects.


<details>
  <summary>Details</summary>
Motivation: It is time-consuming for security practitioners to manually identify vulnerability-related issue reports (IRs) in open-source software communities, causing potential security risks due to the delay. Existing automatic solutions focus mainly on simple textual descriptions and overlook the comprehensive analysis of IRs that contain rich-text information.

Method: VulRTex first uses a large language model (LLM) to build a Vulnerability Reasoning Database from historical issue reports. It then retrieves relevant cases from this database to produce reasoning guidance for the LLM, which uses this guidance to analyze rich-text information in target IRs and accurately identify vulnerabilities.

Result: VulRTex significantly outperforms the best baseline methods for identifying vulnerability-related IRs, achieving +11.0% higher F1, +20.2% higher AUPRC, and +10.5% higher Macro-F1. It also runs at half the time cost of comparable reasoning approaches and has successfully identified new vulnerabilities in real-world OSS projects, with 11 receiving CVE-IDs.

Conclusion: VulRTex effectively and efficiently identifies vulnerability-related issue reports in vast and imbalanced open-source repositories, outperforming existing methods both in accuracy and processing speed. Its real-world utility in OSS security is demonstrated by its successful identification and assignment of CVE-IDs to newly emerging vulnerabilities.

Abstract: Software vulnerabilities exist in open-source software (OSS), and the
developers who discover these vulnerabilities may submit issue reports (IRs) to
describe their details. Security practitioners need to spend a lot of time
manually identifying vulnerability-related IRs from the community, and the time
gap may be exploited by attackers to harm the system. Previously, researchers
have proposed automatic approaches to facilitate identifying these
vulnerability-related IRs, but these works focus on textual descriptions but
lack the comprehensive analysis of IR's rich-text information. In this paper,
we propose VulRTex, a reasoning-guided approach to identify
vulnerability-related IRs with their rich-text information. In particular,
VulRTex first utilizes the reasoning ability of the Large Language Model (LLM)
to prepare the Vulnerability Reasoning Database with historical IRs. Then, it
retrieves the relevant cases from the prepared reasoning database to generate
reasoning guidance, which guides LLM to identify vulnerabilities by reasoning
analysis on target IRs' rich-text information. To evaluate the performance of
VulRTex, we conduct experiments on 973,572 IRs, and the results show that
VulRTex achieves the highest performance in identifying the
vulnerability-related IRs and predicting CWE-IDs when the dataset is
imbalanced, outperforming the best baseline with +11.0% F1, +20.2% AUPRC, and
+10.5% Macro-F1, and 2x lower time cost than baseline reasoning approaches.
Furthermore, VulRTex has been applied to identify 30 emerging vulnerabilities
across 10 representative OSS projects in 2024's GitHub IRs, and 11 of them are
successfully assigned CVE-IDs, which illustrates VulRTex's practicality.

</details>


### [6] [Vulnerability-Affected Versions Identification: How Far Are We?](https://arxiv.org/abs/2509.03876)
*Xingchu Chen,Chengwei Liu,Jialun Cao,Yang Xiao,Xinyue Cai,Yeting Li,Jingyi Shi,Tianqi Sun,Haiming Chen ang Wei Huo*

Main category: cs.SE

TL;DR: Current tools for identifying affected software versions by vulnerabilities are fundamentally limited, achieving less than 45% accuracy individually and below 60% even with ensemble strategies. A new approach is needed, with the authors providing a comprehensive benchmark and actionable insights for the community.


<details>
  <summary>Details</summary>
Motivation: Identifying which software versions are affected by a vulnerability is crucial for patching and risk mitigation. However, existing tools have unclear real-world effectiveness due to limited evaluation scopes, outdated techniques, and small or coarse-grained datasets.

Method: The authors curate a benchmark of 1,128 real-world C/C++ vulnerabilities and systematically evaluate 12 representative tools from both tracing and matching paradigms. They measure effectiveness at vulnerability and version levels, analyze false positives/negatives, examine patch sensitivity, and explore ensemble strategies.

Result: No tool exceeds 45.0% accuracy, with most challenges arising from reliance on heuristics, limited semantic reasoning, and rigid matching logic. Patch structures such as add-only and cross-file changes further degrade tool performance. Ensemble approaches can increase accuracy by up to 10.1%, but overall accuracy remains below 60%.

Conclusion: The study reveals fundamental limitations in current tools for identifying affected software versions. There is a clear need for new approaches, as even the best existing techniques achieve limited accuracy. The released benchmark and insights can guide future research and tool development.

Abstract: Identifying which software versions are affected by a vulnerability is
critical for patching, risk mitigation.Despite a growing body of tools, their
real-world effectiveness remains unclear due to narrow evaluation scopes often
limited to early SZZ variants, outdated techniques, and small or
coarse-graineddatasets. In this paper, we present the first comprehensive
empirical study of vulnerability affected versions identification. We curate a
high quality benchmark of 1,128 real-world C/C++ vulnerabilities and
systematically evaluate 12 representative tools from both tracing and matching
paradigms across four dimensions: effectiveness at both vulnerability and
version levels, root causes of false positives and negatives, sensitivity to
patch characteristics, and ensemble potential. Our findings reveal fundamental
limitations: no tool exceeds 45.0% accuracy, with key challenges stemming from
heuristic dependence, limited semantic reasoning, and rigid matching logic.
Patch structures such as add-only and cross-file changes further hinder
performance. Although ensemble strategies can improve results by up to 10.1%,
overall accuracy remains below 60.0%, highlighting the need for fundamentally
new approaches. Moreover, our study offers actionable insights to guide tool
development, combination strategies, and future research in this critical area.
Finally, we release the replicated code and benchmark on our website to
encourage future contributions.outdated techniques, and small or coarse grained
datasets.

</details>


### [7] [Analyzing Variations in Dependency Distributions Due to Code Smell Interactions](https://arxiv.org/abs/2509.03896)
*Zushuai Zhang,Elliott Wen,Ewan Tempero*

Main category: cs.SE

TL;DR: The study finds that when code smells interact, they substantially increase dependencies between software modules, making maintenance harder. Developers are advised to prioritize fixing interacting code smells over isolated ones.


<details>
  <summary>Details</summary>
Motivation: To understand how code smell interactions affect dependencies, potentially complicating maintenance, and to confirm prior observations.

Method: Dependency analysis on 116 open-source Java systems, quantifying and comparing dependencies caused by interacting code smells versus individual smells.

Result: Code smell pairs tend to significantly increase dependencies; for instance, Feature Envy methods interacting with Data Classes show seven times more dependencies than non-interacting cases.

Conclusion: Interactions between code smells tend to increase overall module dependencies, making software maintenance more complex.

Abstract: The existence of dependencies between modules, such as classes, can mean that
changing a module triggers ripple effects that make maintenance complex and
costly, so the advice is to minimize dependencies between modules. It is
therefore important to understand the circumstances that can lead to increased
dependencies. Recent studies suggest that code smells, which are
characteristics of code that indicate potential design issues, may interact in
ways that increase dependencies between modules. In this study, we aim to
confirm previous observations and investigate whether and how the distribution
of static dependencies changes in the presence of code smell interactions. We
conducted a dependency analysis on 116 open-source Java systems to quantify the
interactions, comparing interactions among code smells and interactions between
code smells and non-code smells. Our results suggest that while interactions
between code smell pairs are associated with increases in certain dependencies
and decreases in others, overall, they are associated with an increase in total
dependencies. For example, the median number of dependencies between Feature
Envy methods and Data Classes is seven times as many as when the methods are
non-Feature Envy methods, increasing from 1 to 7. This implies that developers
should prioritize addressing code smells that interact with each other, rather
than code smells that exist only in isolation.

</details>


### [8] [The Auth Shim: A Lightweight Architectural Pattern for Integrating Enterprise SSO with Standalone Open-Source Applications](https://arxiv.org/abs/2509.03900)
*Yuvraj Agrawal*

Main category: cs.SE

TL;DR: This paper introduces the Auth Shim, a lightweight external service that enables secure SSO integration for open-source tools lacking built-in SAML/OIDC support. A case study at Adobe shows its practicality, security, and ability to automate user management, providing a blueprint for similar enterprise use cases.


<details>
  <summary>Details</summary>
Motivation: Many open-source software (OSS) tools lack native support for security protocols like SAML or OIDC, making integration with enterprise identity providers challenging and potentially leading to security risks.

Method: The paper proposes and formalizes the 'Auth Shim,' an external proxy service that translates identity provider authentication into the application's native session management, assuming the application has a secure administrative API. The pattern is illustrated by an implementation case at Adobe.

Result: The Auth Shim enabled secure, automated single sign-on integration for a popular OSS BI tool and Okta SAML, including automated RBAC and eliminating manual user provision. It demonstrated practical, secure, and scalable integration in production.

Conclusion: The Auth Shim architectural pattern offers a reusable and secure solution for integrating standalone OSS tools with enterprise SSO systems, addressing key adoption barriers and security integration gaps while enabling greater flexibility and innovation in enterprise environments.

Abstract: Open-source software OSS is widely adopted in enterprise settings, but
standalone tools often lack native support for protocols like SAML or OIDC,
creating a critical security integration gap. This paper introduces and
formalizes the Auth Shim, a lightweight architectural pattern designed to solve
this problem. The Auth Shim is a minimal, external proxy service that acts as a
compatibility layer, translating requests from an enterprise Identity Provider
IdP into the native session management mechanism of a target application. A key
prerequisite for this pattern is that the target application must expose a
programmatic, secure administrative API. We present a case study of the
pattern's implementation at Adobe to integrate a popular OSS BI tool with Okta
SAML, which enabled automated Role-Based Access Control RBAC via IAM group
mapping and eliminated manual user provisioning. By defining its components,
interactions, and production deployment considerations, this paper provides a
reusable, secure, and cost-effective blueprint for integrating any standalone
OSS tool into an enterprise SSO ecosystem, thereby enabling organizations to
embrace open-source innovation without compromising on security governance.

</details>


### [9] [RepoDebug: Repository-Level Multi-Task and Multi-Language Debugging Evaluation of Large Language Models](https://arxiv.org/abs/2509.04078)
*Jingjing Liu,Zeming Liu,Zihao Cheng,Mengliang He,Xiaoming Shi,Yuhang Guo,Xiangrong Zhu,Yuanfang Guo,Yunhong Wang,Haifeng Wang*

Main category: cs.SE

TL;DR: Most code debugging datasets for LLMs only test simple cases. This paper presents RepoDebug, a more complex, real-world dataset, showing that even top LLMs cannot yet effectively debug at the repository level.


<details>
  <summary>Details</summary>
Motivation: Existing code debugging datasets using LLMs are limited because they focus mainly on function-level repairs rather than the more complex repository-level scenarios. This leads to an incomplete understanding of LLMs' real-world debugging capabilities. Repository-level datasets already proposed have limitations in task, language, and error diversity.

Method: The paper introduces RepoDebug, a new dataset for repository-level code debugging. RepoDebug features 22 error subtypes, supports 8 programming languages, and provides 3 distinct debugging tasks. The researchers evaluate 10 large language models using this dataset.

Result: RepoDebug offers a diverse, multi-language, repository-level dataset that allows broader assessment of LLMs in real-world debugging. Experimental results show that even the best-performing LLM (Claude 3.5 Sonnect) struggles with repository-level debugging tasks.

Conclusion: Focusing on repository-level rather than function-level debugging reveals persistent LLM deficiencies in real-world debugging. RepoDebug serves as a more comprehensive benchmark, but even advanced models are not yet proficient in repository-level debugging.

Abstract: Large Language Models (LLMs) have exhibited significant proficiency in code
debugging, especially in automatic program repair, which may substantially
reduce the time consumption of developers and enhance their efficiency.
Significant advancements in debugging datasets have been made to promote the
development of code debugging. However, these datasets primarily focus on
assessing the LLM's function-level code repair capabilities, neglecting the
more complex and realistic repository-level scenarios, which leads to an
incomplete understanding of the LLM's challenges in repository-level debugging.
While several repository-level datasets have been proposed, they often suffer
from limitations such as limited diversity of tasks, languages, and error
types. To mitigate this challenge, this paper introduces RepoDebug, a
multi-task and multi-language repository-level code debugging dataset with 22
subtypes of errors that supports 8 commonly used programming languages and 3
debugging tasks. Furthermore, we conduct evaluation experiments on 10 LLMs,
where Claude 3.5 Sonnect, the best-performing model, still cannot perform well
in repository-level debugging.

</details>


### [10] [An Empirical Study of Vulnerabilities in Python Packages and Their Detection](https://arxiv.org/abs/2509.04260)
*Haowei Quan,Junjie Wang,Xinzhe Li,Terry Yue Zhuo,Xiao Chen,Xiaoning Du*

Main category: cs.SE

TL;DR: This paper introduces PyVul, a large, precise benchmark of 1,157 Python package vulnerabilities, showing that current detection tools struggle with real-world issues. PyVul exposes gaps, especially in multi-language scenarios, and will drive future tool improvements.


<details>
  <summary>Details</summary>
Motivation: The proliferation of Python package vulnerabilities, coupled with the complexity gained from multi-language integrations, calls for better benchmarks and analyses of vulnerability detection within Python's ecosystem. Existing tools may not sufficiently address these needs, and there is a lack of comprehensive datasets.

Method: The paper introduces PyVul, the first comprehensive benchmark suite for Python-package vulnerabilities, containing 1,157 real-world, publicly reported, and developer-verified vulnerabilities at both commit and function levels. The dataset is meticulously annotated, and LLM-assisted data cleansing is used to improve labeling accuracy to 100% at the commit level and 94% at the function level. The benchmark is used to analyze the distribution and types of vulnerabilities and to evaluate state-of-the-art vulnerability detection tools.

Result: PyVul establishes itself as the most accurate and comprehensive large-scale benchmark for Python package vulnerabilities. The data analysis shows that vulnerabilities are prevalent in multi-lingual packages and exhibit diverse types. Benchmarking state-of-the-art tools against PyVul exposes a significant gap between the tools' detection capabilities and real-world needs. An in-depth empirical review of common weakness enumerations (CWEs) in Python packages identifies specific areas where detection tools fall short.

Conclusion: PyVul provides a crucial resource for evaluating and advancing security tools for Python packages, making clear the limitations of current solutions and highlighting the need for new approaches to vulnerability detection, particularly in multi-lingual and complex Python packages.

Abstract: In the rapidly evolving software development landscape, Python stands out for
its simplicity, versatility, and extensive ecosystem. Python packages, as units
of organization, reusability, and distribution, have become a pressing concern,
highlighted by the considerable number of vulnerability reports. As a scripting
language, Python often cooperates with other languages for performance or
interoperability. This adds complexity to the vulnerabilities inherent to
Python packages, and the effectiveness of current vulnerability detection tools
remains underexplored. This paper addresses these gaps by introducing PyVul,
the first comprehensive benchmark suite of Python-package vulnerabilities.
PyVul includes 1,157 publicly reported, developer-verified vulnerabilities,
each linked to its affected packages. To accommodate diverse detection
techniques, it provides annotations at both commit and function levels. An
LLM-assisted data cleansing method is incorporated to improve label accuracy,
achieving 100% commit-level and 94% function-level accuracy, establishing PyVul
as the most precise large-scale Python vulnerability benchmark. We further
carry out a distribution analysis of PyVul, which demonstrates that
vulnerabilities in Python packages involve multiple programming languages and
exhibit a wide variety of types. Moreover, our analysis reveals that
multi-lingual Python packages are potentially more susceptible to
vulnerabilities. Evaluation of state-of-the-art detectors using this benchmark
reveals a significant discrepancy between the capabilities of existing tools
and the demands of effectively identifying real-world security issues in Python
packages. Additionally, we conduct an empirical review of the top-ranked CWEs
observed in Python packages, to diagnose the fine-grained limitations of
current detection tools and highlight the necessity for future advancements in
the field.

</details>


### [11] [FaaSGuard: Secure CI/CD for Serverless Applications -- An OpenFaaS Case Study](https://arxiv.org/abs/2509.04328)
*Amine Barrak,Emna Ksontini,Ridouane Atike,Fehmi Jaafar*

Main category: cs.SE

TL;DR: FaaSGuard is a comprehensive DevSecOps pipeline for open-source serverless platforms like OpenFaaS, automating security checks throughout development. It was empirically tested, showing high precision and recall in detecting and preventing vulnerabilities, with little impact on existing workflows.


<details>
  <summary>Details</summary>
Motivation: Serverless computing, while advantageous, introduces new security risks that are not well covered by current solutions, especially in open-source environments like OpenFaaS. Existing security approaches in DevSecOps are fragmented and insufficiently comprehensive.

Method: The authors propose FaaSGuard, a unified DevSecOps pipeline tailored for open-source serverless platforms. FaaSGuard inserts lightweight, fail-closed security checks at every phase of the software development lifecycle, from planning to monitoring. Empirical validation through a case study on 20 open-source serverless functions was conducted.

Result: FaaSGuard successfully detected and prevented critical vulnerabilities, such as injection attacks, hard-coded secrets, and resource exhaustion. It achieved high precision (95%) and recall (91%) during empirical validation, while not causing major disruptions to the CI/CD workflow.

Conclusion: FaaSGuard offers an effective, comprehensive, and non-disruptive security solution for serverless environments, providing robust protection at all stages of the DevSecOps pipeline in open-source platforms.

Abstract: Serverless computing significantly alters software development by abstracting
infrastructure management and enabling rapid, modular, event-driven
deployments. Despite its benefits, the distinct characteristics of serverless
functions, such as ephemeral execution and fine-grained scalability, pose
unique security challenges, particularly in open-source platforms like
OpenFaaS. Existing approaches typically address isolated phases of the
DevSecOps lifecycle, lacking an integrated and comprehensive security strategy.
To bridge this gap, we propose FaaSGuard, a unified DevSecOps pipeline
explicitly designed for open-source serverless environments. FaaSGuard
systematically embeds lightweight, fail-closed security checks into every stage
of the development lifecycle-planning, coding, building, deployment, and
monitoring-effectively addressing threats such as injection attacks, hard-coded
secrets, and resource exhaustion. We validate our approach empirically through
a case study involving 20 real-world serverless functions from public GitHub
repositories. Results indicate that FaaSGuard effectively detects and prevents
critical vulnerabilities, demonstrating high precision (95%) and recall (91%)
without significant disruption to established CI/CD practices.

</details>


### [12] [Design and Development of a Web Platform for Blood Donation Management](https://arxiv.org/abs/2509.04423)
*Fatima Zulfiqar Ali,Atrooba Ilyas*

Main category: cs.SE

TL;DR: The paper introduces a web platform that connects patients, blood donors, and administrators to streamline blood donor registration and matching in emergencies, using modern web technologies and a structured system design.


<details>
  <summary>Details</summary>
Motivation: Blood donation is vital for healthcare, but finding suitable donors during emergencies is challenging. There is a need for a system that simplifies and streamlines the process of connecting patients and donors.

Method: The authors designed and developed a centralized Blood Donation Web Platform using modern web technologies (PHP Laravel, HTML, CSS, Bootstrap, MySQL) and utilized use case, database, class, and sequence diagrams for system architecture. Implementation was done with XAMPP and Visual Studio Code.

Result: The resulting platform enables easy donor registration, search based on blood group and location, and effective communication between patients, donors, and administrators, reducing delays and complexities.

Conclusion: The web platform improves accessibility and efficiency of blood donation services, particularly in emergencies.

Abstract: Blood donation is a critical component of healthcare, yet locating suitable
donors in emergencies often presents significant challenges. This paper
presents the design and development of a Blood Donation Web Platform, a
web-based system that connects patients, donors, and administrators within a
centralized digital space. The platform allows interested donors to register
their personal information, including blood group, contact details, and
availability. Patients can search for donors based on blood group and location,
and the system provides a list of nearby donors who are ready to donate. The
platform design was guided by use case, database, class, and sequence diagrams
to ensure a well-structured and efficient system architecture. Modern web
technologies, including PHP (Laravel framework), HTML, CSS, Bootstrap, and
MySQL, supported by XAMPP and Visual Studio Code, were employed to implement a
dynamic, interactive, and user-friendly platform. By streamlining donor
refgistration, blood requests, and communication, the proposed system reduces
delays and complexities in emergencies, improving timely accessibility of blood
and enhancing overall efficiency in blood donation services.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [13] [When Lifetimes Liberate: A Type System for Arenas with Higher-Order Reachability Tracking](https://arxiv.org/abs/2509.04253)
*Siyuan He,Songlin Jia,Yuyan Bao,Tiark Rompf*

Main category: cs.PL

TL;DR: The paper introduces a unified static resource management system for higher-order functional languages, drawing on the strengths of regions, ownership, and reachability types. New type extensions allow flexible sharing and lifetime control while preserving type safety and expressiveness.


<details>
  <summary>Details</summary>
Motivation: Effective static resource management in higher-order functional languages is difficult due to the need to balance control, expressiveness, and flexibility. Existing approaches like region-based systems, ownership types (e.g., Rust), and reachability types address parts of the problem, but each has significant limitationsâ€”such as restricted lifetimes, inflexible sharing, or lack of practical lifetime control tools.

Method: The authors unify strengths from region-based systems, ownership types, and reachability types to create a new approach. They introduce a system that allows resources to be grouped into arenas for shared management with lexical lifetimes, or individually managed with non-lexical lifetimes, while preserving type uniformity. The core technical innovations are two extensions to reachability types: (1) A<: with a two-dimensional store for reachability tracking within arenas, and (2) {A}<: that supports lexical lifetime control with static guarantees. Both extensions are formalized and proven type safe in the Rocq language.

Result: The proposed approach successfully combines flexible resource grouping (through arenas) and individual management, supporting both lexical and non-lexical lifetimes. The new reachability type extensions (A<: and {A}<:) enable expressive yet statically safe resource management in higher-order languages. The calculus is formalized and its type safety is proven.

Conclusion: By extending reachability types with support for both arenas and lexical lifetimes, and formalizing these in the Rocq language, the authors provide a unified, type-safe foundation for static resource management with both flexibility and expressiveness in higher-order functional languages.

Abstract: Static resource management in higher-order functional languages remains
elusive due to tensions between control, expressiveness, and flexibility.
Region-based systems [Grossman et al. 2002; Tofte et al. 2001] offer control
over lifetimes and expressive in-region sharing, but restrict resources to
lexical scopes. Rust, an instance of ownership types [Clarke et al. 2013],
offers non-lexical lifetimes and robust safety guarantees, yet its global
invariants make common sharing patterns hard to express. Reachability types
[Wei et al. 2024] enable reasoning about sharing and separation, but lack
practical tools for controlling resource lifetimes.
  In this work, we try to unify their strengths. Our solution enables grouping
resources as arenas for arbitrary sharing and static guarantees of lexically
scoped lifetimes. Crucially, arenas and lexical lifetimes are not the only
choice: users may also manage resources individually, with non-lexical
lifetimes. Regardless of mode, resources share the same type, preserving the
higher-order parametric nature of the language.
  Obtaining static safety guarantee in a higher-order language with flexible
sharing is nontrivial. To this end, we propose two new extensions atop
reachability types [Wei et al. 2024]. First, A<: features a novel
two-dimensional store model to enable coarse-grained reachability tracking for
arbitrarily shared resources within arenas. Building on this, {A}<: establishes
lexical lifetime control with static guarantees. As the first reachability
formalism presented for lifetime control, {A}<: avoids the complication of
flow-sensitive reasoning and retains expressive power and simplicity. Both
calculi are formalized and proven type safe in Rocq.

</details>

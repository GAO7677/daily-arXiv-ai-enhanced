<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 16]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Structural Code Search using Natural Language Queries](https://arxiv.org/abs/2507.02107)
*Ben Limpanukorn,Yanjun Wang,Zach Patterson,Pranav Garg,Murali Krishna Ramanathan,Xiaofei Ma,Anoop Deoras,Miryung Kim*

Main category: cs.SE

TL;DR: This paper proposes using LLMs to translate natural language code search queries into structured queries for tools like Semgrep. Their method makes structural search more accessible, achieves strong precision/recall, and outperforms semantic search and pure LLM retrieval approaches.


<details>
  <summary>Details</summary>
Motivation: Current code search techniques mainly use keywords and regular expressions, which are easy but not powerful for searching based on code structure. Structural code search exists but requires complex, hard-to-learn domain-specific languages (DSLs), limiting accessibility.

Method: The authors propose a new approach that uses large language models (LLMs) to interpret natural language queries and translate them into queries for existing structural code search tools (such as Semgrep and GQL). They develop this methodology, instantiate it for two DSLs, and evaluate it on a newly constructed benchmark of 400 queries over 10 Java projects.

Result: The approach achieves high precision and recall (55%-70%) in retrieving relevant code. It also surpasses other methods (semantic code search and pure LLM retrieval) by up to 57% and 14% on F1 scores.

Conclusion: Translating natural language queries to DSLs via LLMs for structural code search effectively reduces barriers to use and achieves superior performance, making structural search tools more accessible and accurate for developers.

Abstract: Searching code is a common task that developers perform to understand APIs,
learn common code patterns, and navigate code. Currently, developers most
commonly search using keywords and regular expressions that are easy to use and
widely available. Beyond keywords and regular expressions, structural code
search tools allow developers to search for code based on its syntactic
structure. This has numerous applications ranging from bug finding to
systematically refactoring code. However, these structural code search tools
operate on queries expressed in domain-specific languages (DSL) that can be
difficult to learn and write. We propose to allow developers to use natural
language to search for code structurally. Expressing queries in natural
language provides an intuitive way to search for code and lowers the barrier to
entry.
  In this work, we develop a novel general approach that combines the reasoning
capabilities of an LLM to interpret natural language search queries with the
power of structural search tools to efficiently and accurately retrieve
relevant code. We then instantiate this approach for two structural code search
DSLs: Semgrep and GQL. In our evaluation, we construct a new benchmark for
structural code search consisting of 400 queries over 10 Java projects. We show
that our approach for structural code search based on translating NL queries to
DSL queries using an LLM is effective and robust, achieving a high precision
and recall ranging from 55% - 70%. Further, our approach significantly
outperforms baselines based on semantic code search and LLM retrievals by up to
57% and 14% on F1 scores.

</details>


### [2] [How do Software Engineering Candidates Prepare for Technical Interviews?](https://arxiv.org/abs/2507.02068)
*Brian Bell,Teresa Thomas,Sang Won Lee,Chris Brown*

Main category: cs.SE

TL;DR: Software engineering students feel unprepared for technical interviews due to a lack of realistic practice and insufficient support from university courses, leading to stress. The study calls for stakeholders to improve preparation resources.


<details>
  <summary>Details</summary>
Motivation: The motivation is to explore how aspiring software engineers prepare for technical interviews, given that these high-stakes interviews are not well-represented or supported in typical computing curricula.

Method: A survey was conducted among 131 candidates actively preparing for technical interviews.

Result: Candidates rarely practice in realistic interview settings and report that academic courses do not adequately support their preparation. This leads to increased stress and a sense of unpreparedness among candidates.

Conclusion: There is a gap between what is taught in computing curricula and the preparation required for technical interviews, indicating a need for educational and industry stakeholders to better support candidates.

Abstract: To obtain employment, aspiring software engineers must complete technical
interviews -- a hiring process which involves candidates writing code while
communicating to an audience. However, the complexities of tech interviews are
difficult to prepare for and seldom faced in computing curricula. To this end,
we seek to understand how candidates prepare for technical interviews,
investigating the effects of preparation methods and the role of education. We
distributed a survey to candidates (n = 131) actively preparing for technical
interviews. Our results suggest candidates rarely train in authentic settings
and courses fail to support preparation efforts -- leading to stress and
unpreparedness. Based on our findings, we provide implications for stakeholders
to enhance tech interview preparation for candidates pursuing software
engineering roles.

</details>


### [3] [Can Internal Software Metrics Predict App Popularity at Launch? Yeas! and Nays!](https://arxiv.org/abs/2507.02110)
*Md Nahidul Islam Opu,Fatima Islam Mouri,Rick Kazman,Yuanfang Cai,Shaiful Chowdhury*

Main category: cs.SE

TL;DR: Internal code metrics, when applied with robust classification models, can moderately predict pre-release app popularity, especially when cast as a binary problem. This outcome challenges previous skepticism about the value of code metrics for forecasting app success.


<details>
  <summary>Details</summary>
Motivation: Predicting mobile app popularity pre-release is important for developers to gain a competitive edge, but it is a difficult and underexplored problem. Previous studies have often dismissed the usefulness of internal code metrics as predictors of software quality or success.

Method: The study uses a dataset of 446 open-source Android apps from F-Droid. It extracts a range of code metrics (system-, class-, method-level), code smells, and metadata. User reviews, download data, and permissions are also collected. The authors apply regression and classification models to three feature sets: Size-only (baseline), handpicked features, and a Voting set (selected by algorithms). Model performance is evaluated primarily by $R^2$ (regression) and F1-score (classification).

Result: Regression models performed poorly due to data skew, with low $R^2$ scores. When using a binary classification (Popular vs. Unpopular), performance improved significantly. The best model, a Multilayer Perceptron using the algorithm-selected Voting feature set, achieved an F1-score of 0.72.

Conclusion: Internal software metrics, although limited, can be useful for predicting app popularity, contradicting prior studies that dismissed their predictive power for software quality.

Abstract: Predicting mobile app popularity before release can provide developers with a
strategic advantage in a competitive marketplace, yet it remains a challenging
problem. This study explores whether internal software metrics, measurable from
source code before deployment, can predict an app's popularity, defined by user
ratings (calculated from user reviews) and DownloadsPerYear (yearly downloads).
Using a dataset of 446 open-source Android apps from F-Droid, we extract a wide
array of features, including system-, class-, and method-level code metrics,
code smells, and app metadata. Additional information, such as user reviews,
download counts, and uses-permission, was collected from the Google Play Store.
We evaluate regression and classification models across three feature sets: a
minimal Size-only baseline, a domain-informed Handpicked set, and a Voting set
derived via feature selection algorithms. Regression models perform poorly due
to skewed data, with low $R^2$ scores. However, when reframed as binary
classification (Popular vs. Unpopular), results improve significantly. The best
model, a Multilayer Perceptron using the Voting set, achieves F1-scores of
0.72. These results suggest that internal code metrics, although limited in
their explanatory power, can serve as useful indicators of app popularity. This
challenges earlier findings that dismissed internal metrics as predictors of
software quality.

</details>


### [4] [A Multimodal Approach Combining Biometrics and Self-Report Instruments for Monitoring Stress in Programming: Methodological Insights](https://arxiv.org/abs/2507.02118)
*Cristina Martinez Montes,Daniela Grassi,Nicole Novielli,Birgit Penzenstadle*

Main category: cs.SE

TL;DR: This study compared self-reported and biometric stress measures during programming tasks. Self-reports showed no stress, interviews were mixed, and only one biometric marker indicated stress. The method of inducing stress was likely insufficient.


<details>
  <summary>Details</summary>
Motivation: Traditional self-report methods for studying well-being and stress are subject to biases, leading to increased interest in objective physiological measures. This study aims to explore the relationship between subjective and objective stress measures.

Method: Participants completed pre-surveys, performed two programming tasks while wearing biometric sensors, answered post-surveys, and participated in exit interviews. The study compared psychometric and biometric stress indicators, especially under time constraints.

Result: Psychometric measures did not indicate stress. Interviews showed mixed perceptions of stress. Biometric data revealed a significant change only in EDA phasic peaks.

Conclusion: Imposing a stricter time limit as a stressor was insufficient to induce measurable stress. The study suggests methodological recommendations for future research on stress using biometrics and psychometric tools.

Abstract: The study of well-being, stress and other human factors has traditionally
relied on self-report instruments to assess key variables. However, concerns
about potential biases in these instruments, even when thoroughly validated and
standardised, have driven growing interest in alternatives in combining these
measures with more objective methods, such as physiological measures.
  We aimed to (i) compare psychometric stress measures and biometric indicators
and (ii) identify stress-related patterns in biometric data during software
engineering tasks.
  We conducted an experiment where participants completed a pre-survey, then
programmed two tasks wearing biometric sensors, answered brief post-surveys for
each, and finally went through a short exit interview.
  Our results showed diverse outcomes; we found no stress in the psychometric
instruments. Participants in the interviews reported a mix of feeling no stress
and experiencing time pressure. Finally, the biometrics showed a significant
difference only in EDA phasic peaks.
  We conclude that our chosen way of inducing stress by imposing a stricter
time limit was insufficient. We offer methodological insights for future
studies working with stress, biometrics, and psychometric instruments.

</details>


### [5] [Towards Trustworthy Sentiment Analysis in Software Engineering: Dataset Characteristics and Tool Selection](https://arxiv.org/abs/2507.02137)
*Martin Obaidi,Marc Herrmann,Jil Klünder,Kurt Schneider*

Main category: cs.SE

TL;DR: The paper shows that picking the right sentiment analysis tool for developer communications depends heavily on dataset characteristics, proposes a method to recommend suitable tools, and finds that while some transformer-based models are strong performers, effectiveness is context-dependent.


<details>
  <summary>Details</summary>
Motivation: Sentiment analysis is important for understanding team dynamics in software engineering, but current tools often perform inconsistently across datasets from different platforms due to variations in communication styles and content.

Method: The authors analyzed linguistic and statistical features of 10 developer communication datasets from five platforms and evaluated the performance of 14 sentiment analysis tools. They then proposed a mapping approach and a questionnaire to recommend suitable sentiment analysis tools for new datasets based on their features.

Result: Dataset characteristics significantly affect the performance of sentiment analysis tools. Transformer-based models like SetFit and RoBERTa generally perform well, but their effectiveness depends on the context. The proposed mapping approach aids in selecting appropriate tools for specific datasets.

Conclusion: Effective sentiment analysis in software engineering requires accounting for dataset-specific features. The proposed approach helps select trustworthy tools and underscores the need for regular evaluation as communication platforms change.

Abstract: Software development relies heavily on text-based communication, making
sentiment analysis a valuable tool for understanding team dynamics and
supporting trustworthy AI-driven analytics in requirements engineering.
However, existing sentiment analysis tools often perform inconsistently across
datasets from different platforms, due to variations in communication style and
content.
  In this study, we analyze linguistic and statistical features of 10 developer
communication datasets from five platforms and evaluate the performance of 14
sentiment analysis tools. Based on these results, we propose a mapping approach
and questionnaire that recommends suitable sentiment analysis tools for new
datasets, using their characteristic features as input.
  Our results show that dataset characteristics can be leveraged to improve
tool selection, as platforms differ substantially in both linguistic and
statistical properties. While transformer-based models such as SetFit and
RoBERTa consistently achieve strong results, tool effectiveness remains
context-dependent. Our approach supports researchers and practitioners in
selecting trustworthy tools for sentiment analysis in software engineering,
while highlighting the need for ongoing evaluation as communication contexts
evolve.

</details>


### [6] [Enhancing COBOL Code Explanations: A Multi-Agents Approach Using Large Language Models](https://arxiv.org/abs/2507.02182)
*Fangjian Lei,Jiawen Liu,Shayan Noei,Ying Zou,Derek Truong,William Alexander*

Main category: cs.SE

TL;DR: A new multi-agent LLM framework provides superior multi-level explanations for COBOL codebases, outperforming previous methods in detail and clarity. This helps address the legacy maintenance challenge by making COBOL systems easier to understand, especially for newcomers.


<details>
  <summary>Details</summary>
Motivation: Maintaining COBOL codebases is increasingly challenging due to their age, complexity, and the dwindling pool of COBOL developers. The lack of documentation further complicates the onboarding and productivity of new developers. Existing LLM-based code explanation methods are less effective for COBOL, primarily because COBOL's unique structure and code length often exceed the token window limitations of current language models.

Method: The paper proposes a multi-agent system wherein two large language model-based agents collaboratively generate multi-granularity explanations—at function, file, and project levels—for COBOL code. The agents utilize contextual information across the codebase to enhance the quality and relevance of the explanations, particularly addressing challenges with long code exceeding LLMs’ token limits.

Result: The method was evaluated using 14 open-source COBOL projects. At the function level, the approach outperformed the baseline with improvements of 12.67%, 18.59%, and 0.62% in METEOR, chrF, and SentenceBERT scores, respectively. For file-level code (including files surpassing LLMs' token windows), the method delivered 4.21%, 10.72%, and 14.68% better results in purpose, functionality, and clarity. For project-level, the system generated explanations that accurately described functionality and purpose for 82% of the selected projects.

Conclusion: The multi-agent LLM-based approach significantly improves the quality and coverage of COBOL code explanations compared to the baseline, effectively handling the challenges posed by long and complex COBOL files. This method offers a viable solution for easing the maintenance and understanding of legacy COBOL systems, especially in settings with insufficient documentation.

Abstract: Common Business Oriented Language (COBOL) is a programming language used to
develop business applications that are widely adopted by financial, business,
and government agencies. Due to its age, complexity, and declining number of
COBOL developers, maintaining COBOL codebases is becoming increasingly
challenging. In particular, the lack of documentation makes it difficult for
new developers to effectively understand and maintain COBOL systems. Existing
research utilizes large language models (LLMs) to explain the functionality of
code snippets. However, COBOL presents unique challenges due to its
architectural and syntactical differences, which often cause its code to exceed
the token window size of LLMs. In this work, we propose a multi-agent approach
that leverages two LLM-based agents working collaboratively to generate
explanations for functions, files, and the overall project. These agents
incorporate together by utilizing contextual information from the codebase into
the code explanation prompts. We evaluate the effectiveness of our approach
using 14 open-source, real-world COBOL projects. Our results indicate that our
approach performs significantly better than the baseline in function code
explanation, with improvements of 12.67%, 18.59%, and 0.62% in terms of METEOR,
chrF, and SentenceBERT scores, respectively. At the file level, our approach
effectively explains both short and long COBOL files that exceed the token
window size of LLMs and surpass the baseline by 4.21%, 10.72%, and 14.68% in
explaining the purpose, functionality, and clarity of the generated
explanation. At the project level, our approach generates explanations that
convey the functionality and purpose of 82% of the selected projects.

</details>


### [7] [Precisely Detecting Python Type Errors via LLM-based Unit Test Generation](https://arxiv.org/abs/2507.02318)
*Chen Yang,Ziqi Wang,Yanjie Jiang,Lin Yang,Yuteng Zheng,Jianyi Zhou,Junjie Chen*

Main category: cs.SE

TL;DR: RTED is a new Python test generation tool that finds more type errors with fewer false positives than existing methods, also catching unknown bugs in real-world projects.


<details>
  <summary>Details</summary>
Motivation: Type errors in Python cause runtime failures, impacting software reliability and developer productivity. Current static analysis tools have high false positive rates, while existing unit test generation methods struggle to generate bug-revealing tests, lacking guidance for type errors.

Method: RTED combines step-by-step type constraint analysis with reflective validation to guide the generation of unit tests specifically for finding type errors in Python. This approach aims to suppress false positives by integrating both type-awareness and feedback into test creation.

Result: On two benchmarks (BugsInPy and TypeBugs), RTED detected 22-29 more type errors than four state-of-the-art tools and reduced false positives, with a precision improvement of 173.9%-245.9%. Additionally, it found 12 previously unknown type errors in real-world open-source projects.

Conclusion: RTED is an effective, type-aware test generation tool for Python that improves both the detection and precision of finding type errors compared to leading techniques. It also helps discover new, previously undetected type errors in real-world code.

Abstract: Type errors in Python often lead to runtime failures, posing significant
challenges to software reliability and developer productivity. Existing static
analysis tools aim to detect such errors without execution but frequently
suffer from high false positive rates. Recently, unit test generation
techniques offer great promise in achieving high test coverage, but they often
struggle to produce bug-revealing tests without tailored guidance. To address
these limitations, we present RTED, a novel type-aware test generation
technique for automatically detecting Python type errors. Specifically, RTED
combines step-by-step type constraint analysis with reflective validation to
guide the test generation process and effectively suppress false positives. We
evaluated RTED on two widely-used benchmarks, BugsInPy and TypeBugs.
Experimental results show that RTED can detect 22-29 more benchmarked type
errors than four state-of-the-art techniques. RTED is also capable of producing
fewer false positives, achieving an improvement of 173.9%-245.9% in precision.
Furthermore, RTED successfully discovered 12 previously unknown type errors
from six real-world open-source Python projects.

</details>


### [8] [VeFIA: An Efficient Inference Auditing Framework for Vertical Federated Collaborative Software](https://arxiv.org/abs/2507.02376)
*Chung-ju Huang,Ziqi Zhang,Yinggui Wang,Binghui Wang,Tao Wei,Leye Wang*

Main category: cs.SE

TL;DR: VeFIA is the first framework to audibly and reliably verify inference software correctness in Vertical Federated Learning, ensuring privacy and zero additional latency while achieving near-perfect anomaly detection.


<details>
  <summary>Details</summary>
Motivation: Current Vertical Federated Learning (VFL) methods do not provide a way to audit or verify the correctness of inference software execution at the data party, potentially risking trust and correctness in distributed AI collaboration.

Method: The authors introduce VeFIA, a framework that allows the task party to audit inference software correctness at the data party using Trusted Execution Environments (TEE) and a coordinator. The auditing process employs random sampling of inference results for validation, ensuring privacy and zero additional inference latency.

Result: VeFIA can detect execution anomalies in the inference software with a 99.99% probability if abnormal inference exceeds 5.4%. It achieves 100% in positive predictive value, negative predictive value, and true positive rate for abnormal inference detection. No additional latency or data privacy leakage is introduced.

Conclusion: VeFIA is an effective and privacy-preserving framework for auditing the execution correctness of inference software in VFL settings, filling an important gap in existing research and enabling reliable distributed AI without sacrificing performance or privacy.

Abstract: Vertical Federated Learning (VFL) is a distributed AI software deployment
mechanism for cross-silo collaboration without accessing participants' data.
However, existing VFL work lacks a mechanism to audit the execution correctness
of the inference software of the data party. To address this problem, we design
a Vertical Federated Inference Auditing (VeFIA) framework. VeFIA helps the task
party to audit whether the data party's inference software is executed as
expected during large-scale inference without leaking the data privacy of the
data party or introducing additional latency to the inference system. The core
of VeFIA is that the task party can use the inference results from a framework
with Trusted Execution Environments (TEE) and the coordinator to validate the
correctness of the data party's computation results. VeFIA guarantees that, as
long as the abnormal inference exceeds 5.4%, the task party can detect
execution anomalies in the inference software with a probability of 99.99%,
without incurring any additional online inference latency. VeFIA's random
sampling validation achieves 100% positive predictive value, negative
predictive value, and true positive rate in detecting abnormal inference. To
the best of our knowledge, this is the first paper to discuss the correctness
of inference software execution in VFL.

</details>


### [9] [Meta-Fair: AI-Assisted Fairness Testing of Large Language Models](https://arxiv.org/abs/2507.02533)
*Miguel Romero-Arjona,José A. Parejo,Juan C. Alonso,Ana B. Sánchez,Aitor Arrieta,Sergio Segura*

Main category: cs.SE

TL;DR: The paper proposes Meta-Fair, an automated framework using metamorphic testing and LLMs to identify bias in language models. Experiments show high bias-detection precision and promising use of LLMs for both test generation and evaluation, paving the way for more scalable, resource-efficient fairness testing.


<details>
  <summary>Details</summary>
Motivation: Fairness is essential in AI, but current methods for testing fairness in large language models (LLMs) are resource-intensive and hard to scale due to their reliance on manual work, curated data, and fixed templates. There's a need for a more automated, scalable, and less resource-dependent method for fairness testing.

Method: The paper introduces Meta-Fair, an approach that uses metamorphic testing to assess fairness in LLMs. It involves making controlled changes (metamorphic relations, MRs) to input prompts and observing output variations to detect bias. The method also leverages LLMs themselves for generating diverse input prompts and evaluating model outputs. Three open-source tools support automated generation, execution, and evaluation of test cases.

Result: Experiments with 12 pre-trained LLMs, 14 MRs, 5 bias dimensions, and 7,900 auto-generated test cases demonstrated that Meta-Fair can effectively uncover bias, achieving 92% average precision and detecting biased behavior in 29% of executions. LLMs were found to be reliable evaluators, with top models reaching an F1-score of 0.79. Non-determinism in outputs can be managed with careful MR design.

Conclusion: Meta-Fair offers a promising and automated solution for fairness testing in LLMs, reducing reliance on manual effort and domain-specific resources. While challenges exist for broader applicability, the approach shows strong potential for scalable, automated bias detection in large language models.

Abstract: Fairness--the absence of unjustified bias--is a core principle in the
development of Artificial Intelligence (AI) systems, yet it remains difficult
to assess and enforce. Current approaches to fairness testing in large language
models (LLMs) often rely on manual evaluation, fixed templates, deterministic
heuristics, and curated datasets, making them resource-intensive and difficult
to scale. This work aims to lay the groundwork for a novel, automated method
for testing fairness in LLMs, reducing the dependence on domain-specific
resources and broadening the applicability of current approaches. Our approach,
Meta-Fair, is based on two key ideas. First, we adopt metamorphic testing to
uncover bias by examining how model outputs vary in response to controlled
modifications of input prompts, defined by metamorphic relations (MRs). Second,
we propose exploiting the potential of LLMs for both test case generation and
output evaluation, leveraging their capability to generate diverse inputs and
classify outputs effectively. The proposal is complemented by three open-source
tools supporting LLM-driven generation, execution, and evaluation of test
cases. We report the findings of several experiments involving 12 pre-trained
LLMs, 14 MRs, 5 bias dimensions, and 7.9K automatically generated test cases.
The results show that Meta-Fair is effective in uncovering bias in LLMs,
achieving an average precision of 92% and revealing biased behaviour in 29% of
executions. Additionally, LLMs prove to be reliable and consistent evaluators,
with the best-performing models achieving F1-scores of up to 0.79. Although
non-determinism affects consistency, these effects can be mitigated through
careful MR design. While challenges remain to ensure broader applicability, the
results indicate a promising path towards an unprecedented level of automation
in LLM testing.

</details>


### [10] [LLMREI: Automating Requirements Elicitation Interviews with LLMs](https://arxiv.org/abs/2507.02564)
*Alexander Korn,Samuel Gorsch,Andreas Vogelsang*

Main category: cs.SE

TL;DR: This paper introduces and evaluates LLMREI, a chatbot leveraging large language models for semi-automated requirements elicitation interviews. Compared to humans, LLMREI makes a similar number of errors and effectively extracts requirements, offering scalable benefits especially for projects with many stakeholders.


<details>
  <summary>Details</summary>
Motivation: Requirements elicitation interviews are essential for gathering system requirements but are resource-intensive, error-prone, and depend heavily on skilled analysts, leading to inefficiencies and potential biases. The study is motivated by the desire to automate and scale this process using advanced large language models, aiming to reduce human-related errors.

Method: The authors introduced LLMREI, a chatbot based on large language models, to conduct requirements elicitation interviews. They experimented with zero-shot prompting and least-to-most prompting as optimization approaches and evaluated LLMREI in 33 simulated stakeholder interviews. Fine-tuning was considered but abandoned after poor initial results. The chatbot was assessed for its ability to avoid interview errors, extract requirements, and adapt its questioning.

Result: LLMREI performed on par with human interviewers in terms of error rates, was able to extract a significant portion of system requirements, and showed strong adaptability in formulating context-aware questions during interviews.

Conclusion: LLMREI presents a promising step towards automated requirements elicitation, primarily benefiting scenarios requiring interviews with many stakeholders by reducing human workload and scaling the process efficiently. The chatbot matches human interviewers in common error rates, successfully extracts requirements, and adapts questioning strategies contextually.

Abstract: Requirements elicitation interviews are crucial for gathering system
requirements but heavily depend on skilled analysts, making them
resource-intensive, susceptible to human biases, and prone to miscommunication.
Recent advancements in Large Language Models present new opportunities for
automating parts of this process. This study introduces LLMREI, a chat bot
designed to conduct requirements elicitation interviews with minimal human
intervention, aiming to reduce common interviewer errors and improve the
scalability of requirements elicitation. We explored two main approaches,
zero-shot prompting and least-to-most prompting, to optimize LLMREI for
requirements elicitation and evaluated its performance in 33 simulated
stakeholder interviews. A third approach, fine-tuning, was initially considered
but abandoned due to poor performance in preliminary trials. Our study assesses
the chat bot's effectiveness in three key areas: minimizing common interview
errors, extracting relevant requirements, and adapting its questioning based on
interview context and user responses. Our findings indicate that LLMREI makes a
similar number of errors compared to human interviewers, is capable of
extracting a large portion of requirements, and demonstrates a notable ability
to generate highly context-dependent questions. We envision the greatest
benefit of LLMREI in automating interviews with a large number of stakeholders.

</details>


### [11] [Human-Machine Collaboration and Ethical Considerations in Adaptive Cyber-Physical Systems](https://arxiv.org/abs/2507.02578)
*Zoe Pfister*

Main category: cs.SE

TL;DR: This paper proposes new processes and frameworks to effectively integrate human-machine teaming into adaptive cyber-physical systems, addressing feedback loop integration and ethical considerations such as privacy and human values across the system's lifecycle.


<details>
  <summary>Details</summary>
Motivation: Adaptive Cyber-Physical Systems (CPS), which increasingly integrate human-machine collaboration, face challenges in achieving effective Human-Machine Teaming (HMT), particularly in seamlessly integrating humans into adaptive feedback loops while respecting human values and privacy.

Method: The research develops new methods and processes for integrating HMT into adaptive CPS, with a focus on human-machine interaction principles in adaptive feedback loops. It also creates frameworks for verifying and validating ethics and human values throughout the system lifecycle.

Result: The paper results in novel integration methods for HMT into adaptive CPS and introduces frameworks that ensure the incorporation and validation of ethics and human values from requirements engineering onward.

Conclusion: Addressing the integration of HMT in adaptive CPS is complex due to operational differences and privacy needs, but with the developed methods and frameworks, the research advances the ability to create more effective, ethical, and human-aligned adaptive CPS.

Abstract: Adaptive Cyber-Physical Systems (CPS) are systems that integrate both
physical and computational capabilities, which can adjust in response to
changing parameters. Furthermore, they increasingly incorporate human-machine
collaboration, allowing them to benefit from the individual strengths of humans
and machines. Human-Machine Teaming (HMT) represents the most advanced paradigm
of human-machine collaboration, envisioning seamless teamwork between humans
and machines. However, achieving effective and seamless HMT in adaptive CPS is
challenging. While adaptive CPS already benefit from feedback loops such as
MAPE-K, there is still a gap in integrating humans into these feedback loops
due to different operational cadences of humans and machines. Further, HMT
requires constant monitoring of human operators, collecting potentially
sensitive information about their actions and behavior. Respecting the privacy
and human values of the actors of the CPS is crucial for the success of
human-machine teams. This research addresses these challenges by: (1)
developing novel methods and processes for integrating HMT into adaptive CPS,
focusing on human-machine interaction principles and their incorporation into
adaptive feedback loops found in CPS, and (2) creating frameworks for
integrating, verifying, and validating ethics and human values throughout the
system lifecycle, starting from requirements engineering.

</details>


### [12] [Do Research Software Engineers and Software Engineering Researchers Speak the Same Language?](https://arxiv.org/abs/2507.02665)
*Timo Kehrer,Robert Haines,Guido Juckeland,Shurui Zhou,David E. Bernholdt*

Main category: cs.SE

TL;DR: RSEs and SERs use different terminologies that can hinder collaboration; the authors propose a method to map these terms and identify gaps, aiming for better community understanding and future collaboration.


<details>
  <summary>Details</summary>
Motivation: The paper is motivated by the observation that Research Software Engineers (RSEs) and Software Engineering Researchers (SERs) use different terminologies for similar concepts, leading to communication challenges.

Method: The authors systematically investigated how fundamental software engineering concepts from the SER community are understood and interpreted by the RSE community. They also developed a methodology for mapping terminology between the two groups.

Result: The preliminary results identify areas where both communities can learn from each other, as well as areas with overlapping or divergent knowledge. The methodology lays groundwork for future crowd-sourced extensions and validations.

Conclusion: The study demonstrates both opportunities for mutual learning and a systematic approach for bridging the terminology gap between RSEs and SERs, with potential for broader community involvement.

Abstract: Anecdotal evidence suggests that Research Software Engineers (RSEs) and
Software Engineering Researchers (SERs) often use different terminologies for
similar concepts, creating communication challenges. To better understand these
divergences, we have started investigating how SE fundamentals from the SER
community are interpreted within the RSE community, identifying aligned
concepts, knowledge gaps, and areas for potential adaptation. Our preliminary
findings reveal opportunities for mutual learning and collaboration, and our
systematic methodology for terminology mapping provides a foundation for a
crowd-sourced extension and validation in the future.

</details>


### [13] [RLHGNN: Reinforcement Learning-driven Heterogeneous Graph Neural Network for Next Activity Prediction in Business Processes](https://arxiv.org/abs/2507.02690)
*Jiaxing Wang,Yifeng Yu,Jiahan Song,Bin Cao,Jing Fan,Ji Zhang*

Main category: cs.SE

TL;DR: RLHGNN is an adaptive reinforcement learning-based graph neural network that automatically selects optimal process graph structures for business process prediction, significantly outperforming current solutions and enabling real-time application.


<details>
  <summary>Details</summary>
Motivation: Traditional sequence-based approaches for next activity prediction in business process optimization fail to capture non-sequential relationships such as parallel executions and conditional dependencies. Graph-based approaches partially solve this but struggle with homogeneous, static representations that ignore process complexity diversity.

Method: The authors propose RLHGNN, a novel reinforcement learning-based heterogeneous graph neural network. It constructs heterogeneous process graphs from event logs with three relation types, combines them flexibly into four graph structures, and uses reinforcement learning to select the most appropriate structure as a Markov Decision Process for each process instance. Heterogeneous graph convolution with relation-specific aggregation is then applied for prediction.

Result: RLHGNN consistently outperforms state-of-the-art methods in six real-world datasets and achieves about 1 ms latency per prediction, making it suitable for real-time applications.

Conclusion: RLHGNN offers a flexible, adaptive framework capturing both sequential and non-sequential relationships in business process activities, providing accurate and fast next activity prediction for real-time business process optimization.

Abstract: Next activity prediction represents a fundamental challenge for optimizing
business processes in service-oriented architectures such as microservices
environments, distributed enterprise systems, and cloud-native platforms, which
enables proactive resource allocation and dynamic service composition. Despite
the prevalence of sequence-based methods, these approaches fail to capture
non-sequential relationships that arise from parallel executions and
conditional dependencies. Even though graph-based approaches address structural
preservation, they suffer from homogeneous representations and static
structures that apply uniform modeling strategies regardless of individual
process complexity characteristics. To address these limitations, we introduce
RLHGNN, a novel framework that transforms event logs into heterogeneous process
graphs with three distinct edge types grounded in established process mining
theory. Our approach creates four flexible graph structures by selectively
combining these edges to accommodate different process complexities, and
employs reinforcement learning formulated as a Markov Decision Process to
automatically determine the optimal graph structure for each specific process
instance. RLHGNN then applies heterogeneous graph convolution with
relation-specific aggregation strategies to effectively predict the next
activity. This adaptive methodology enables precise modeling of both sequential
and non-sequential relationships in service interactions. Comprehensive
evaluation on six real-world datasets demonstrates that RLHGNN consistently
outperforms state-of-the-art approaches. Furthermore, it maintains an inference
latency of approximately 1 ms per prediction, representing a highly practical
solution suitable for real-time business process monitoring applications. The
source code is available at https://github.com/Joker3993/RLHGNN.

</details>


### [14] [Sustainability Flags for the Identification of Sustainability Posts in Q&A Platforms](https://arxiv.org/abs/2507.02695)
*Sahar Ahmadisakha,Lech Bialek,Mohamed Soliman,Vasilios Andrikopoulos*

Main category: cs.SE

TL;DR: The paper proposes 'sustainability flags' to better identify sustainability in cloud architecture discussions, finds them more effective and usable than traditional definitions, and suggests their adoption can enhance decision-making in software architecture.


<details>
  <summary>Details</summary>
Motivation: With cloud computing's growth and the shift toward cloud-based architectures, it's increasingly important for practitioners to identify and discuss sustainability in software systems. However, it's challenging to recognize sustainability concepts in these discussions due to unclear guidelines.

Method: The authors developed 'sustainability flags' by performing thematic analysis on sustainability best practices from cloud providers. They then evaluated these flags in a controlled experiment involving cloud architecture Q&A posts.

Result: Sustainability flags led to fewer posts being classified as sustainability-related, but with better performance and higher certainty compared to the control group. Users found the flags more useful and understandable than just using sustainability definitions.

Conclusion: Introducing sustainability flags helps practitioners more accurately and confidently identify sustainability-related discussions in cloud architecture contexts. The flags are superior to traditional definitions in both usefulness and clarity.

Abstract: In recent years, sustainability in software systems has gained significant
attention, especially with the rise of cloud computing and the shift towards
cloud-based architectures. This shift has intensified the need to identify
sustainability in architectural discussions to take informed architectural
decisions. One source to see these decisions is in online Q&A forums among
practitioners' discussions. However, recognizing sustainability concepts within
software practitioners' discussions remains challenging due to the lack of
clear and distinct guidelines for this task. To address this issue, we
introduce the notion of sustainability flags as pointers in relevant
discussions, developed through thematic analysis of multiple sustainability
best practices from cloud providers. This study further evaluates the
effectiveness of these flags in identifying sustainability within cloud
architecture posts, using a controlled experiment. Preliminary results suggest
that the use of flags results in classifying fewer posts as
sustainability-related compared to a control group, with moderately higher
certainty and significantly improved performance. Moreover, sustainability
flags are perceived as more useful and understandable than relying solely on
definitions for identifying sustainability.

</details>


### [15] [Legal Requirements Translation from Law](https://arxiv.org/abs/2507.02846)
*Anmol Singhal,Travis Breaux*

Main category: cs.SE

TL;DR: The paper introduces a novel, code-based approach using language models to automate generating structured legal requirements from complex texts, validated on U.S. data breach laws with high accuracy and less reliance on labeled data, addressing key shortcomings of prior automated methods.


<details>
  <summary>Details</summary>
Motivation: Complying with legal regulations is particularly challenging for software systems, especially for small organizations lacking legal expertise. Extracting legal requirements from complex legal texts is resource-intensive and existing automated methods are limited by their lack of generalizability and failure to capture interrelationships among legal metadata.

Method: The authors use a new approach combining textual entailment and in-context learning to generate canonical representations of legal text. These are expressed as Python code, following a manually designed Python class metamodel that captures both structural and semantic metadata and their relationships.

Result: The method was tested on 13 U.S. state data breach notification laws. The generated representations pass approximately 89.4% of test cases and achieve precision and recall of 82.2 and 88.7, respectively.

Conclusion: The proposed approach reduces the need for large labeled datasets, generalizes better to new legislation, and effectively captures the interrelationships among legal metadata, thus making compliance automation more practical, especially for organizations lacking legal expertise.

Abstract: Software systems must comply with legal regulations, which is a
resource-intensive task, particularly for small organizations and startups
lacking dedicated legal expertise. Extracting metadata from regulations to
elicit legal requirements for software is a critical step to ensure compliance.
However, it is a cumbersome task due to the length and complex nature of legal
text. Although prior work has pursued automated methods for extracting
structural and semantic metadata from legal text, key limitations remain: they
do not consider the interplay and interrelationships among attributes
associated with these metadata types, and they rely on manual labeling or
heuristic-driven machine learning, which does not generalize well to new
documents. In this paper, we introduce an approach based on textual entailment
and in-context learning for automatically generating a canonical representation
of legal text, encodable and executable as Python code. Our representation is
instantiated from a manually designed Python class structure that serves as a
domain-specific metamodel, capturing both structural and semantic legal
metadata and their interrelationships. This design choice reduces the need for
large, manually labeled datasets and enhances applicability to unseen
legislation. We evaluate our approach on 13 U.S. state data breach notification
laws, demonstrating that our generated representations pass approximately 89.4%
of test cases and achieve a precision and recall of 82.2 and 88.7,
respectively.

</details>


### [16] [Requirements Elicitation Follow-Up Question Generation](https://arxiv.org/abs/2507.02858)
*Yuchen Shen,Anmol Singhal,Travis Breaux*

Main category: cs.SE

TL;DR: GPT-4o can generate interview questions for requirements elicitation just as well or better than humans, especially when using a framework of common interview mistakes, making LLMs valuable real-time aids for interviewers.


<details>
  <summary>Details</summary>
Motivation: Interviews for requirements elicitation are challenging due to issues like excessive cognitive load and interviewers' lack of domain familiarity. The process demands generating effective questions in real time, which is hard for many interviewers. Leveraging large language models (LLMs) could address these challenges and support interviewers.

Method: The paper integrates GPT-4o, a state-of-the-art LLM, to generate follow-up interview questions based on interviewee speech. It builds on a framework of common interviewer mistake types and tests question quality in two controlled experiments: (1) comparing LLM-generated to human-authored questions with minimal guidance, and (2) evaluating LLM-generated questions guided by mistake types.

Result: LLM-generated questions are at least as clear, relevant, and informative as human-crafted questions. When guided by the mistake framework, LLM-generated questions outperform human-authored ones.

Conclusion: LLMs like GPT-4o can reliably assist interviewers during requirements elicitation by producing high-quality, contextually appropriate follow-up questions, especially when leveraging systematic frameworks of common interviewing mistakes.

Abstract: Interviews are a widely used technique in eliciting requirements to gather
stakeholder needs, preferences, and expectations for a software system.
Effective interviewing requires skilled interviewers to formulate appropriate
interview questions in real time while facing multiple challenges, including
lack of familiarity with the domain, excessive cognitive load, and information
overload that hinders how humans process stakeholders' speech. Recently, large
language models (LLMs) have exhibited state-of-the-art performance in multiple
natural language processing tasks, including text summarization and entailment.
To support interviewers, we investigate the application of GPT-4o to generate
follow-up interview questions during requirements elicitation by building on a
framework of common interviewer mistake types. In addition, we describe methods
to generate questions based on interviewee speech. We report a controlled
experiment to evaluate LLM-generated and human-authored questions with minimal
guidance, and a second controlled experiment to evaluate the LLM-generated
questions when generation is guided by interviewer mistake types. Our findings
demonstrate that, for both experiments, the LLM-generated questions are no
worse than the human-authored questions with respect to clarity, relevancy, and
informativeness. In addition, LLM-generated questions outperform human-authored
questions when guided by common mistakes types. This highlights the potential
of using LLMs to help interviewers improve the quality and ease of requirements
elicitation interviews in real time.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [17] [DecoRTL: A Run-time Decoding Framework for RTL Code Generation with LLMs](https://arxiv.org/abs/2507.02226)
*Mohammad Akyash,Kimia Azar,Hadi Kamali*

Main category: cs.PL

TL;DR: Standard LLM decoding methods struggle with RTL code generation due to differing structural and semantic requirements. This paper proposes DecoRTL, a syntax-aware and contrastive decoding strategy that improves both the correctness and diversity of RTL code outputs, without needing additional model training.


<details>
  <summary>Details</summary>
Motivation: Large language models (LLMs) are being increasingly used for automating register transfer level (RTL) code generation, but existing decoding strategies often produce structurally or semantically incorrect RTL code. The motivation is to understand and address why standard natural language decoding methods are inadequate for RTL code generation.

Method: The paper conducts an empirical analysis of token-level entropy during RTL code generation to uncover the causes of LLM decoding failures. It introduces DecoRTL, a new decoding strategy that is both syntax-aware and contrastive. DecoRTL consists of: (1) self-consistency sampling for generating and re-ranking multiple candidate outputs based on token agreement, and (2) syntax-aware temperature adaptation which assigns different sampling temperatures to tokens based on their syntax and function. This approach is applied entirely at inference time, with no need for model fine-tuning.

Result: The evaluations using the VerilogEval benchmark and several open-source LLMs show that the DecoRTL approach yields significant improvements in the syntactic validity, functional correctness, and diversity of generated RTL code outputs, with negligible performance overhead.

Conclusion: Adapting decoding strategies to the unique requirements of RTL code, as done in DecoRTL, makes LLM-generated RTL code substantially more accurate and robust, thereby overcoming significant limitations of conventional LLM decoding methods for this application.

Abstract: As one of their many applications, large language models (LLMs) have recently
shown promise in automating register transfer level (RTL) code generation.
However, conventional LLM decoding strategies, originally designed for natural
language, often fail to meet the structural and semantic demands of RTL,
leading to hallucinated, repetitive, or invalid code outputs. In this paper, we
first investigate the root causes of these decoding failures through an
empirical analysis of token-level entropy during RTL generation. Our findings
reveal that LLMs exhibit low confidence in regions of structural ambiguity or
semantic complexity, showing that standard decoding strategies fail to
differentiate between regions requiring determinism (syntax-critical regions)
and those that benefit from creative exploratory variability (design-critical
regions). Then, to overcome this, we introduce DecoRTL, a novel run-time
decoding strategy, that is both syntax-aware and contrastive for RTL code
generation. DecoRTL integrates two complementary components: (i)
self-consistency sampling, which generates multiple candidates and re-ranks
them based on token-level agreement to promote correctness while maintaining
diversity; and (ii) syntax-aware temperature adaptation, which classifies
tokens by their syntactical and functional roles and adjusts the sampling
temperature accordingly, enforcing low temperature for syntax-critical tokens
and higher temperature for exploratory ones. Our approach operates entirely at
inference time without requiring any additional model fine-tuning. Through
evaluations on multiple open-source LLMs using the VerilogEval benchmark, we
demonstrate significant improvements in syntactic validity, functional
correctness, and output diversity, while the execution overhead (performance
overhead) is imperceptible.

</details>

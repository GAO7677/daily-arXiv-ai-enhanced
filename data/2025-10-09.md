<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 11]
- [cs.PL](#cs.PL) [Total: 1]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Leveraging Large Language Models for Cybersecurity Risk Assessment -- A Case from Forestry Cyber-Physical Systems](https://arxiv.org/abs/2510.06343)
*Fikret Mert Gültekin,Oscar Lilja,Ranim Khojah,Rebekka Wohlrab,Marvin Damschen,Mazen Mohamad*

Main category: cs.SE

TL;DR: Safety-critical software teams lack enough cybersecurity experts. The study shows that locally hosted LLMs can help with risk assessment tasks when privacy is important, but human oversight remains crucial. Experts see LLMs as assistants, not replacements, for evaluating threats and risks in domains like forestry.


<details>
  <summary>Details</summary>
Motivation: Safety-critical software in domains like forestry require robust cybersecurity activities, specifically risk assessment. There's a lack of cybersecurity experts on software teams, putting high pressure on the few available and forcing non-experts to handle risk assessments. This motivates the development of tools to aid both experts and engineers, particularly in scenarios with data privacy constraints.

Method: The paper uses a design science study involving 12 subject-matter experts. Methods include interviews, interactive sessions, and survey feedback, conducted within a large-scale project. The core technological method is leveraging locally hosted large language models with retrieval-augmented generation.

Result: Locally hosted LLMs can help generate initial risk assessments, identify threats, and provide redundancy checks in safety-critical cybersecurity workflows, specifically in the forestry domain. Human oversight remains essential for ensuring accuracy and compliance, and while trust issues exist, experts are open to using LLMs for assistance but not total automation.

Conclusion: LLMs, particularly when augmented and hosted locally to respect privacy constraints, can significantly support cybersecurity risk assessment but should be deployed as decision-support tools rather than replacements for human experts. The study provides evidence and encouragement for integrating LLMs into the risk assessment of cyber-physical systems in safety-critical environments.

Abstract: In safety-critical software systems, cybersecurity activities become
essential, with risk assessment being one of the most critical. In many
software teams, cybersecurity experts are either entirely absent or represented
by only a small number of specialists. As a result, the workload for these
experts becomes high, and software engineers would need to conduct
cybersecurity activities themselves. This creates a need for a tool to support
cybersecurity experts and engineers in evaluating vulnerabilities and threats
during the risk assessment process. This paper explores the potential of
leveraging locally hosted large language models (LLMs) with retrieval-augmented
generation to support cybersecurity risk assessment in the forestry domain
while complying with data protection and privacy requirements that limit
external data sharing. We performed a design science study involving 12 experts
in interviews, interactive sessions, and a survey within a large-scale project.
The results demonstrate that LLMs can assist cybersecurity experts by
generating initial risk assessments, identifying threats, and providing
redundancy checks. The results also highlight the necessity for human oversight
to ensure accuracy and compliance. Despite trust concerns, experts were willing
to utilize LLMs in specific evaluation and assistance roles, rather than solely
relying on their generative capabilities. This study provides insights that
encourage the use of LLM-based agents to support the risk assessment process of
cyber-physical systems in safety-critical domains.

</details>


### [2] [Improving Assignment Submission in Higher Education through a Git-Enabled System: An Iterative Case Study](https://arxiv.org/abs/2510.06363)
*Ololade Babatunde,Tomisin Ayodabo,Raqibul Raqibul*

Main category: cs.SE

TL;DR: A custom Git-based assignment submission system significantly improved the efficiency, collaboration, and user experience for both students and instructors in a university setting, reducing time and storage requirements while being highly preferred over traditional methods.


<details>
  <summary>Details</summary>
Motivation: Traditional assignment submission methods in higher education have various challenges, such as inefficiency, difficulty in tracking assignments, limited collaboration opportunities, and administrative burden on both students and instructors.

Method: The researchers designed and implemented a customized Git-based assignment submission system using iterative software development and user-centered design. The system was deployed in an actual university setting, and its effectiveness was evaluated through empirical methods, including usability testing and collecting student feedback.

Result: Empirical evaluations showed significant improvements in assignment tracking, collaboration, and efficiency. 85% of instructors found the Git-based system easier to use, and 84% of students preferred it over traditional submission methods. The new system led to a 38% reduction in the time required for submissions and reviews and a 48% decrease in storage requirements. Challenges related to initial adoption and student learning curves were encountered but were successfully mitigated through iterative improvements.

Conclusion: The customized Git-based submission system offers practical advantages for assignment management in educational settings. Its integration into coursework can enhance instructor oversight and student engagement, especially in software engineering and related fields, and serves as a model for using distributed version control in education.

Abstract: This study addresses challenges in traditional assignment submission methods
used in higher education by introducing and evaluating a customized Git-based
submission system. Employing iterative software development and user-centered
design methodologies, the system was integrated within a real-world university
environment. Empirical evaluation, including usability testing and student
feedback, indicated significant improvements in assignment tracking,
collaboration, and submission efficiency. Students reported positive
experiences using distributed version control workflows, highlighting improved
learning outcomes and reduced administrative burden. Challenges related to
initial adoption and student learning curves were identified and mitigated
through iterative improvements. The proposed system contributes practical
insights for integrating distributed version control into educational settings,
enhancing both instructor oversight and student engagement in software
engineering and related disciplines. Based on our results, the research showed
that 85% of instructors found the git based system easier to use, with 84% of
students preferring it over traditional methods, as it provides a 38% reduction
in time taken for submission and review, while also leading to a 48% reduction
in storage requirements.

</details>


### [3] [Addressing Visual Impairments with Model-Driven Engineering: A Systematic Literature Review](https://arxiv.org/abs/2510.06483)
*Judith Michael,Lukas Netz,Bernhard Rumpe,Ingo Müller,John Grundy,Shavindra Wickramathilaka,Hourieh Khalajzadeh*

Main category: cs.SE

TL;DR: A systematic review of model-driven engineering for accessibility in software finds that most current research falls short in supporting vision impairments due to vague techniques, limited empirical validation, and scarce user involvement. A new research agenda is proposed to address these gaps.


<details>
  <summary>Details</summary>
Motivation: Software applications often lack adequate support for users with accessibility needs, such as vision impairments, creating barriers to usability. Model-driven engineering (MDE) could potentially streamline incorporating accessibility into software but it's unclear how effective current MDE approaches are.

Method: The paper presents a systematic literature review, starting with 447 papers and narrowing down to 30 primary studies that focus on how MDE addresses accessibility for vision impairments. The review analyzes references to guidelines (e.g. WCAG), modeling practices, involvement of end-users, details about MDE techniques, and empirical validation.

Result: About two-thirds of the studies reference WCAG, but project-specific adaptations and lack of end-user validation limit broader adoption. Few studies specify concrete MDE techniques or demonstrate fully functional systems. There is insufficient detail on MDE methods, hindering reuse and generalization. Limited involvement of affected users and developer expertise leads to weak empirical evidence.

Conclusion: Current MDE research does not sufficiently support vision-related accessibility. The paper proposes a research agenda to better embed accessibility for vision impairments within MDE processes.

Abstract: Software applications often pose barriers for users with accessibility needs,
e.g., visual impairments. Model-driven engineering (MDE), with its systematic
nature of code derivation, offers systematic methods to integrate accessibility
concerns into software development while reducing manual effort. This paper
presents a systematic literature review on how MDE addresses accessibility for
vision impairments. From 447 initially identified papers, 30 primary studies
met the inclusion criteria. About two-thirds reference the Web Content
Accessibility Guidelines (WCAG), yet their project-specific adaptions and
end-user validations hinder wider adoption in MDE. The analyzed studies model
user interface structures, interaction and navigation, user capabilities,
requirements, and context information. However, only few specify concrete
modeling techniques on how to incorporate accessibility needs or demonstrate
fully functional systems. Insufficient details on MDE methods, i.e.,
transformation rules or code templates, hinder the reuse, generalizability, and
reproducibility. Furthermore, limited involvement of affected users and limited
developer expertise in accessibility contribute to weak empirical validation.
Overall, the findings indicate that current MDE research insufficiently
supports vision-related accessibility. Our paper concludes with a research
agenda outlining how support for vision impairments can be more effectively
embedded in MDE processes.

</details>


### [4] [Beyond More Context: How Granularity and Order Drive Code Completion Quality](https://arxiv.org/abs/2510.06606)
*Uswat Yusuf,Genevieve Caumartin,Diego Elias Costa*

Main category: cs.SE

TL;DR: This paper tackles the challenge of improving LLM code completion quality in large code repositories by comparing various context retrieval strategies. Key findings show that chunk-based retrieval via static analysis outperforms file-level approaches, emphasizing the importance of granular and well-ordered context selection.


<details>
  <summary>Details</summary>
Motivation: The motivation of this paper stems from the need to improve code completion quality by providing LLMs with sufficient, relevant context, while overcoming the constraints of context length and mitigating the impact of noisy or irrelevant information in large code repositories.

Method: The paper develops and evaluates retrieval strategies for composing context, at both the repository file and code chunk levels. They conduct experiments to analyze the effect of context size and file ordering on LLM performance, and introduce chunk-based retrieval utilizing static analysis.

Result: Chunk-based retrieval with static analysis yields a 6% improvement over the best file-level retrieval strategy and a 16% gain over the no-context baseline for Python, highlighting the significance of retrieval granularity and context ordering.

Conclusion: Effective context collection strategies, especially those considering chunk-level granularity and smart ordering, can significantly enhance LLM-assisted code completion in large repositories. Retrieval granularity and hybrid strategies are crucial for real-world code generation tasks.

Abstract: Context plays an important role in the quality of code completion, as Large
Language Models (LLMs) require sufficient and relevant information to assist
developers in code generation tasks. However, composing a relevant context for
code completion poses challenges in large repositories: First, the limited
context length of LLMs makes it impractical to include all repository files.
Second, the quality of generated code is highly sensitive to noisy or
irrelevant context. In this paper, we present our approach for the ASE 2025
Context Collection Challenge. The challenge entails outperforming JetBrains
baselines by designing effective retrieval and context collection strategies.
We develop and evaluate a series of experiments that involve retrieval
strategies at both the file and chunk levels. We focus our initial experiments
on examining the impact of context size and file ordering on LLM performance.
Our results show that the amount and order of context can significantly
influence the performance of the models. We introduce chunk-based retrieval
using static analysis, achieving a 6% improvement over our best file-retrieval
strategy and a 16% improvement over the no-context baseline for Python in the
initial phase of the competition. Our results highlight the importance of
retrieval granularity, ordering and hybrid strategies in developing effective
context collection pipelines for real-world development scenarios.

</details>


### [5] [AISysRev -- LLM-based Tool for Title-abstract Screening](https://arxiv.org/abs/2510.06708)
*Aleksi Huotala,Miikka Kuutila,Olli-Pekka Turtio,Mika Mäntylä*

Main category: cs.SE

TL;DR: AiSysRev leverages LLMs to speed up systematic review screening, works well for clear cases, but still relies on humans for edge cases where AI might err.


<details>
  <summary>Details</summary>
Motivation: Systematic literature reviews are labor-intensive, especially during the screening phase. LLMs can potentially expedite this process but require human oversight to avoid errors.

Method: Developed AiSysRev, an LLM-based screening web tool for systematic reviews. Supports zero-shot/few-shot classification and multi-model screening via OpenRouter. Allows manual review with LLM guidance.

Result: Trial study with 137 papers showed effective categorization into Easy Includes, Easy Excludes, Boundary Includes, and Boundary Excludes. LLMs reduce workload but are error-prone with boundary cases, needing human intervention.

Conclusion: LLMs and tools like AiSysRev can meaningfully reduce the effort needed for systematic review screening, improving efficiency, but cannot fully replace human experts for final decisions.

Abstract: Systematic reviews are a standard practice for summarizing the state of
evidence in software engineering. Conducting systematic reviews is laborious,
especially during the screening or study selection phase, where the number of
papers can be overwhelming. During this phase, papers are assessed against
inclusion and exclusion criteria based on their titles and abstracts. Recent
research has demonstrated that large language models (LLMs) can perform
title-abstract screening at a level comparable to that of a master's student.
While LLMs cannot be fully trusted, they can help, for example, in Rapid
Reviews, which try to expedite the review process. Building on recent research,
we developed AiSysRev, an LLM-based screening tool implemented as a web
application running in a Docker container. The tool accepts a CSV file
containing paper titles and abstracts. Users specify inclusion and exclusion
criteria. One can use multiple LLMs for screening via OpenRouter. AiSysRev
supports both zero-shot and few-shot screening, and also allows for manual
screening through interfaces that display LLM results as guidance for human
reviewers.We conducted a trial study with 137 papers using the tool. Our
findings indicate that papers can be classified into four categories: Easy
Includes, Easy Excludes, Boundary Includes, and Boundary Excludes. The Boundary
cases, where LLMs are prone to errors, highlight the need for human
intervention. While LLMs do not replace human judgment in systematic reviews,
they can significantly reduce the burden of assessing large volumes of
scientific literature. Video: https://www.youtube.com/watch?v=jVbEj4Y4tQI Tool:
https://github.com/EvoTestOps/AISysRev

</details>


### [6] [LLM Company Policies and Policy Implications in Software Organizations](https://arxiv.org/abs/2510.06718)
*Ranim Khojah,Mazen Mohamad,Linda Erlenhov,Francisco Gomes de Oliveira Neto,Philipp Leitner*

Main category: cs.SE

TL;DR: This paper studies how 11 software companies create policies for adopting LLM chatbots, identifying influencing factors and offering insights for managers to safely integrate chatbots into workflows.


<details>
  <summary>Details</summary>
Motivation: There are significant risks when integrating LLM chatbots into software organizations, and these risks necessitate the creation of clear usage policies.

Method: The paper examines the approaches of 11 companies in developing LLM chatbot policies. It investigates the influencing factors behind policy creation.

Result: The study reveals how different companies formulate their chatbot adoption policies, highlighting the key factors that managers must consider for safe integration.

Conclusion: Clear, well-considered policies are essential for the responsible adoption of LLM chatbots in software organizations, and understanding how others approach policy creation benefits safe integration.

Abstract: The risks associated with adopting large language model (LLM) chatbots in
software organizations highlight the need for clear policies. We examine how 11
companies create these policies and the factors that influence them, aiming to
help managers safely integrate chatbots into development workflows.

</details>


### [7] [Oops!... I did it again. Conclusion (In-)Stability in Quantitative Empirical Software Engineering: A Large-Scale Analysis](https://arxiv.org/abs/2510.06844)
*Nicole Hoess,Carlos Paradis,Rick Kazman,Wolfgang Mauerer*

Main category: cs.SE

TL;DR: Mining software repositories with different tools can lead to significant differences in data and conclusions due to technical details. Researchers should reuse tools, document reproducibility, and compare results to ensure valid insights.


<details>
  <summary>Details</summary>
Motivation: Mining software repositories is common for understanding project evolution, health, and best practices. However, the limitations and agreement between different mining tools are not well understood.

Method: The study conducted a lightweight literature review to select three prior studies and formally replicated them using four independent mining tools. Data, results, and conclusions from these tools were quantitatively and qualitatively compared.

Result: Technical differences in tool design and implementation can cause substantial discrepancies in data extraction, analysis results, and study conclusions.

Conclusion: Users must carefully select and evaluate tools for mining software repositories, considering their limitations. Tool reuse and reproducibility are recommended, with reproduction packages and comparative studies helping reduce uncertainties.

Abstract: Context: Mining software repositories is a popular means to gain insights
into a software project's evolution, monitor project health, support decisions
and derive best practices. Tools supporting the mining process are commonly
applied by researchers and practitioners, but their limitations and agreement
are often not well understood.
  Objective: This study investigates some threats to validity in complex tool
pipelines for evolutionary software analyses and evaluates the tools' agreement
in terms of data, study outcomes and conclusions for the same research
questions.
  Method: We conduct a lightweight literature review to select three studies on
collaboration and coordination, software maintenance and software quality from
high-ranked venues, which we formally replicate with four independent,
systematically selected mining tools to quantitatively and qualitatively
compare the extracted data, analysis results and conclusions.
  Results: We find that numerous technical details in tool design and
implementation accumulate along the complex mining pipelines and can cause
substantial differences in the extracted baseline data, its derivatives,
subsequent results of statistical analyses and, under specific circumstances,
conclusions.
  Conclusions: Users must carefully choose tools and evaluate their limitations
to assess the scope of validity in an adequate way. Reusing tools is
recommended. Researchers and tool authors can promote reusability and help
reducing uncertainties by reproduction packages and comparative studies
following our approach.

</details>


### [8] [An empirical study on declined proposals: why are these proposals declined?](https://arxiv.org/abs/2510.06984)
*Masanari Kondo,Mahmoud Alfadel,Shane McIntosh,Yasutaka Kamei,Naoyasu Ubayashi*

Main category: cs.SE

TL;DR: This paper analyzes proposal outcomes in Go development, finds most are declined for identifiable reasons, and shows that AI tools can help predict and prioritize which proposals will be declined early, enabling more effective and efficient management of the process.


<details>
  <summary>Details</summary>
Motivation: The paper is motivated by the resource-intensive nature of design-level proposal processes in open-source software (OSS), particularly the Go language, and the lack of clear understanding behind proposal rejections. This gap limits contributors' ability to improve proposals and streamlines the review process.

Method: A mixed-method empirical study of 1,091 proposals submitted to the Go project. Quantitative analysis tracks outcomes, while qualitative coding builds a taxonomy of decline reasons. Evaluation of large language models (LLMs), specifically GPT-based models, for predicting proposal outcomes early in the discussion.

Result: Proposals in Go are more often declined than accepted, with decision-making taking over a month typically. Only 14.7% of declined proposals are resubmitted. Nine key decline reasons were identified (e.g., duplication, limited use cases), and GPT-based models can effectively predict decline outcomes early (F1 score = 0.71), aiding review prioritization.

Conclusion: Proposal review in OSS, especially Go, is inefficient, with many declined proposals and valuable but underused resubmission opportunities. Structured decline reason taxonomy, combined with predictive tools like LLMs, can improve contributor experience and reviewer workload by enabling earlier, more informed triage and guidance for stronger proposals.

Abstract: Design-level decisions in open-source software (OSS) projects are often made
through structured mechanisms such as proposals, which require substantial
community discussion and review. Despite their importance, the proposal process
is resource-intensive and often leads to contributor frustration, especially
when proposals are declined without clear feedback. Yet, the reasons behind
proposal rejection remain poorly understood, limiting opportunities to
streamline the process or guide contributors effectively. This study
investigates the characteristics and outcomes of proposals in the Go
programming language to understand why proposals are declined and how such
outcomes might be anticipated. We conduct a mixed-method empirical study on
1,091 proposals submitted to the Go project. We quantify proposal outcomes,
build a taxonomy of decline reasons, and evaluate large language models (LLMs)
for predicting these outcomes. We find that proposals are more often declined
than accepted, and resolution typically takes over a month. Only 14.7% of
declined proposals are ever resubmitted. Through qualitative coding, we
identify nine key reasons for proposal decline, such as duplication, limited
use cases, or violations of project principles. This taxonomy can help
contributors address issues in advance, e.g., checking for existing
alternatives can reduce redundancy. We also demonstrate that GPT-based models
can predict decline decisions early in the discussion (F1 score = 0.71 with
partial comments), offering a practical tool for prioritizing review effort.
Our findings reveal inefficiencies in the proposal process and highlight
actionable opportunities for improving both contributor experience and reviewer
workload by enabling early triage and guiding contributors to strengthen their
proposals using a structured understanding of past decline reasons.

</details>


### [9] [Human-aligned AI Model Cards with Weighted Hierarchy Architecture](https://arxiv.org/abs/2510.06989)
*Pengyue Yang,Haolin Jin,Qingwen Zeng,Jiawen Wen,Harry Rao,Huaming Chen*

Main category: cs.SE

TL;DR: The paper presents CRAI-MCF, an improved model documentation framework for LLMs that enables robust, quantitative, value-based comparison and supports ethical, responsible adoption.


<details>
  <summary>Details</summary>
Motivation: The rapid growth of specialized LLMs has made it difficult for users to find, assess, and responsibly adopt models due to inconsistent and incomplete documentation. Existing frameworks do not sufficiently support rigorous comparison.

Method: The authors introduce CRAI-MCF, grounded in Value Sensitive Design and empirical analysis of 240 open-source projects. They distilled 217 parameters into an eight-module architecture with a quantitative sufficiency criterion for evaluation.

Result: CRAI-MCF enables actionable, human-aligned documentation, balancing technical, ethical, and operational aspects. It supports rigorous cross-model comparison under a unified framework and facilitates more confident, responsible adoption of LLMs.

Conclusion: CRAI-MCF addresses critical gaps in model documentation by providing a comprehensive, value-aligned, and quantitative solution that supports responsible and efficient model selection and adoption.

Abstract: The proliferation of Large Language Models (LLMs) has led to a burgeoning
ecosystem of specialized, domain-specific models. While this rapid growth
accelerates innovation, it has simultaneously created significant challenges in
model discovery and adoption. Users struggle to navigate this landscape due to
inconsistent, incomplete, and imbalanced documentation across platforms.
Existing documentation frameworks, such as Model Cards and FactSheets, attempt
to standardize reporting but are often static, predominantly qualitative, and
lack the quantitative mechanisms needed for rigorous cross-model comparison.
This gap exacerbates model underutilization and hinders responsible adoption.
To address these shortcomings, we introduce the Comprehensive Responsible AI
Model Card Framework (CRAI-MCF), a novel approach that transitions from static
disclosures to actionable, human-aligned documentation. Grounded in Value
Sensitive Design (VSD), CRAI-MCF is built upon an empirical analysis of 240
open-source projects, distilling 217 parameters into an eight-module,
value-aligned architecture. Our framework introduces a quantitative sufficiency
criterion to operationalize evaluation and enables rigorous cross-model
comparison under a unified scheme. By balancing technical, ethical, and
operational dimensions, CRAI-MCF empowers practitioners to efficiently assess,
select, and adopt LLMs with greater confidence and operational integrity.

</details>


### [10] [Building an Open AIBOM Standard in the Wild](https://arxiv.org/abs/2510.07070)
*Gopi Krishnan Rajbahadur,Keheliya Gallaba,Elyas Rashno,Arthit Suriyawongkul,Karen Bennet,Kate Stewart,Ahmed E. Hassan*

Main category: cs.SE

TL;DR: This paper reports on how a global team created and validated a new standard, AIBOM, to document AI-specific components in software supply chains using the Action Research method. They detail the challenges, validation steps, and lessons that can help others build standards for emerging fields.


<details>
  <summary>Details</summary>
Motivation: Modern software projects increasingly depend on open, community-driven standards, especially as domains like AI systems evolve rapidly. However, the process and challenges of creating such standards in these fast-moving fields are not well understood.

Method: The authors use Action Research (AR) methodology, involving structured AR cycles and contributions from over 90 global stakeholders. They document the process of developing the AI Bill of Materials (AIBOM) specification through these cycles. The new specification is evaluated via four methods: alignment with existing regulations and ethical standards, mapping to industry use cases, practitioner interviews, and a case study in industry.

Result: The result of the study is the validated AIBOM specification for software bill of materials in AI systems, which extends the existing SPDX standard to include AI-specific elements like datasets and training artifacts. The validation uses regulatory mapping, use cases, interviews, and a practical application. The paper also provides insights and lessons learned from the standardization process.

Conclusion: The paper delivers both a validated standard for documenting AI components in software supply chains and a detailed report on the collaborative, iterative process that created it, offering guidance for future standards development in similar domains.

Abstract: Modern software engineering increasingly relies on open, community-driven
standards, yet how such standards are created in fast-evolving domains like
AI-powered systems remains underexplored. This paper presents a detailed
experience report on the development of the AI Bill of Materials AIBOM
specification, an extension of the ISO/IEC 5962:2021 Software Package Data
Exchange (SPDX) software bill of materials (SBOM) standard, which captures AI
components such as datasets and iterative training artifacts. Framed through
the lens of Action Research (AR), we document a global, multi-stakeholder
effort involving over 90 contributors and structured AR cycles. The resulting
specification was validated through four complementary approaches: alignment
with major regulations and ethical standards (e.g., EU AI Act and IEEE 7000
standards), systematic mapping to six industry use cases, semi-structured
practitioner interviews, and an industrial case study. Beyond delivering a
validated artefact, our paper documents the process of building the AIBOM
specification in the wild, and reflects on how it aligns with the AR cycle, and
distills lessons that can inform future standardization efforts in the software
engineering community.

</details>


### [11] [Prompt, Synthesize, Fine-Tune: A Secure Code Generation Recipe](https://arxiv.org/abs/2510.07189)
*Junjie Li,Fazle Rabbi,Bo Yang,Song Wang,Jinqiu Yang*

Main category: cs.SE

TL;DR: Secure-Instruct automatically synthesizes code examples and instructions to fine-tune LLMs, enhancing both the security and correctness of code generation. It consistently outperforms prior methods like SafeCoder on security-critical benchmarks.


<details>
  <summary>Details</summary>
Motivation: LLMs often generate insecure code, which poses risks to software security. Existing solutions (like SafeCoder) struggle with dataset limitations and imbalanced examples, hindering their ability to generalize and improve secure code generation.

Method: The paper introduces Secure-Instruct, a framework that automatically synthesizes both vulnerable and secure code examples, generates fine-tuning instructions, and then uses these to instruction-tune LLMs, improving both task alignment and secure coding capabilities.

Result: Secure-Instruct leads to significant improvements in secure code generation and functional correctness across multiple benchmarks and models. For example, on the CWEBench benchmark it achieves a 14.3% increase in secure code generation ratio over pretrained models and outperforms SafeCoder by 7.6%. Similar gains are noted on CWEval with CodeLlama-7B and Mistral-7B models.

Conclusion: Secure-Instruct is an effective framework for enhancing LLM-based secure code generation, surpassing current approaches in both security and correctness across various tasks and models.

Abstract: Although Large Language Models (LLMs) show promising solutions to automated
code generation, they often produce insecure code that threatens software
security. Current approaches (e.g., SafeCoder) to improve secure code
generation suffer from limited and imbalanced datasets, reducing their
effectiveness and generalizability. In this work, we present Secure-Instruct, a
novel framework that automatically synthesizes high-quality vulnerable and
secure code examples, generates fine-tuning instructions, and instruction-tunes
LLMs to align task description and secure code generation abilities. We
evaluate Secure-Instruct on four representative LLMs using two benchmarks: our
own CWEBench and the existing CWEval. CWEBench comprises 93 scenarios on 44
CWEs, all without overlap with Secure-Instruct's synthetic instruction-tuning
dataset, while CWEval covers 31 CWEs with 119 manually verified
security-critical tasks. We find that Secure-Instruct improves not only the
security but also the functional correctness of the generated code. On
CWEBench, Secure-Instruct substantially improves secure code generation, giving
a 14.3% average increase in secure ratio over the pretrained models and
outperforms SafeCoder by 7.6%. On CWEval, Secure-Instruct achieves a 14%
increase for CodeLlama-7B and 5.8% for Mistral-7B in Func-Sec@1 over pretrained
models, and surpasses SafeCoder by 15.8% and 6.8% respectively.

</details>


<div id='cs.PL'></div>

# cs.PL [[Back]](#toc)

### [12] [VeriEquivBench: An Equivalence Score for Ground-Truth-Free Evaluation of Formally Verifiable Code](https://arxiv.org/abs/2510.06296)
*Lingfei Zeng,Fengdi Che,Xuhan Huang,Fei Ye,Xu Xu,Binhang Yuan,Jie Fu*

Main category: cs.PL

TL;DR: Manually evaluating formal specifications limits progress in verifying LLM-generated code, so the authors introduce VeriEquivBench—a large benchmark with an automated formal equivalence metric. Results show state-of-the-art LLMs struggle with verifiable code generation, stressing the need for better benchmarks and methods.


<details>
  <summary>Details</summary>
Motivation: Current verification of LLM-generated code depends on manually created ground-truth formal specifications, which is time-consuming, expertise-intensive, and results in small and potentially unreliable datasets.

Method: The authors introduce VeriEquivBench, a new benchmark containing 2,389 complex algorithmic problems. They replace manual ground-truth matching with an automated equivalence score as a formal metric to assess the correctness of generated code and specifications.

Result: Experiments reveal that state-of-the-art LLMs struggle to generate code and formal specifications that can be formally verified, highlighting significant challenges.

Conclusion: Generating formally verifiable code is still very difficult for current LLMs. The new VeriEquivBench benchmark and equivalence score framework provide more scalable and rigorous ways to assess and drive improvement in this area.

Abstract: Formal verification is the next frontier for ensuring the correctness of code
generated by Large Language Models (LLMs). While methods that co-generate code
and formal specifications in formal languages, like Dafny, can, in principle,
prove alignment with user intent, progress is bottlenecked by specification
quality evaluation. Current benchmarks rely on matching against ground-truth
specifications, a manual and expertise-intensive process that has limited
existing datasets to a few hundred simple problems and also suffers from a
reliability issue. To address this, we introduce VeriEquivBench, a new
benchmark with $2,389$ complex algorithmic problems that probe the limitations
of current models in both code generation and formal reasoning. Our evaluation
framework replaces ground-truth matching with a formally grounded metric, the
equivalence score, and rigorously verifies the quality of generated
specifications and code. Our results show that generating formally verifiable
code remains a profound challenge for state-of-the-art LLMs. This underscores
both the difficulty of the task and the need for benchmarks like VeriEquivBench
to drive progress toward scalable and reliable coding agents.

</details>

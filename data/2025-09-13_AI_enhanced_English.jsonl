{"id": "2509.09019", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.09019", "abs": "https://arxiv.org/abs/2509.09019", "authors": ["Mohit Tekriwal", "John Sarracino"], "title": "Towards Verified Compilation of Floating-point Optimization in Scientific Computing Programs", "comment": null, "summary": "Scientific computing programs often undergo aggressive compiler optimization\nto achieve high performance and efficient resource utilization. While\nperformance is critical, we also need to ensure that these optimizations are\ncorrect. In this paper, we focus on a specific class of optimizations,\nfloating-point optimizations, notably due to fast math, at the LLVM IR level.\nWe present a preliminary work, which leverages the Verified LLVM framework in\nthe Rocq theorem prover, to prove the correctness of Fused-Multiply-Add (FMA)\noptimization for a basic block implementing the arithmetic expression $a * b +\nc$ . We then propose ways to extend this preliminary results by adding more\nprogram features and fast math floating-point optimizations.", "AI": {"tldr": "The paper presents a formal proof approach for verifying floating-point compiler optimizations, focusing on FMA in LLVM using Rocq. Initial results validate the method's feasibility and outline directions for analyzing more complex optimizations, improving both safety and performance in scientific computing.", "motivation": "Scientific computing demands aggressive compiler optimizations for better performance and resource usage, but requires these optimizations to be correct, especially for floating-point computations, which are highly sensitive to errors.", "method": "The authors leverage the Verified LLVM framework in the Rocq theorem prover to formally prove the correctness of Fused-Multiply-Add (FMA) optimization at the LLVM IR level for the arithmetic expression a * b + c.", "result": "They successfully demonstrate a preliminary correctness proof for FMA optimization using Rocq and suggest future extensions to cover more program features and further floating-point optimizations.", "conclusion": "Formal verification of floating-point optimizations, such as FMA within LLVM, is feasible using theorem provers. The work lays the groundwork for extending such proofs to broader optimizations, enhancing both correctness and performance assurance."}}
{"id": "2509.09059", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2509.09059", "abs": "https://arxiv.org/abs/2509.09059", "authors": ["Paulette Koronkevich", "William J. Bowman"], "title": "Dependent-Type-Preserving Memory Allocation", "comment": "Submitted and received second place at the Student Research\n  Competition at Principles of Programming Languages 2022", "summary": "Dependently typed programming languages such as Coq, Agda, Idris, and F*,\nallow programmers to write detailed specifications of their programs and prove\ntheir programs meet these specifications. However, these specifications can be\nviolated during compilation since they are erased after type checking. External\nprograms linked with the compiled program can violate the specifications of the\noriginal program and change the behavior of the compiled program -- even when\ncompiled with a verified compiler. For example, since Coq does not allow\nexplicitly allocating memory, a programmer might link their Coq program with a\nC program that can allocate memory. Even if the Coq program is compiled with a\nverified compiler, the external C program can still violate the memory-safe\nspecification of the Coq program by providing an uninitialized pointer to\nmemory. This error could be ruled out by type checking in a language expressive\nenough to indicate whether memory is initialized versus uninitialized. Linking\nwith a program with an uninitialized pointer could be considered ill-typed, and\nour linking process could prevent linking with ill-typed programs. To\nfacilitate type checking during linking, we can use type-preserving\ncompilation, which preserves the types through the compilation process. In this\nongoing work, we develop a typed intermediate language that supports dependent\nmemory allocation, as well as a dependent-type-preserving compiler pass for\nmemory allocation.", "AI": {"tldr": "This work creates a typed intermediate language and compiler techniques to ensure that the safety guarantees from dependently typed languages (like Coq or Agda) are preserved throughout compilation and linking, preventing violations such as unsafe memory access when integrating with external code.", "motivation": "Dependently typed languages allow programmers to specify and verify detailed program properties, but these guarantees can be violated after compilation, particularly when linking with external programs which are not verified. The motivation is to prevent these specification violations even after compilation and linking.", "method": "The paper introduces a typed intermediate language that supports dependent memory allocation, and describes a dependent-type-preserving compiler pass for memory allocation. These methods aim to preserve type information and enforce type safety throughout the compilation and linking process.", "result": "The ongoing work has led to the development of a typed intermediate language and a compiler pass that preserves dependent types for memory allocation, facilitating type checking during linking to prevent errors such as linking with uninitialized memory.", "conclusion": "Type-preserving compilation and careful design of intermediate languages can extend the safety guarantees of dependently typed programming languages beyond type checking and compilation stages, helping ensure program properties remain intact even after linking with external code."}}
{"id": "2509.08843", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.08843", "abs": "https://arxiv.org/abs/2509.08843", "authors": ["Sidney Shapiro"], "title": "Pattern-Based File and Data Access with Python Glob: A Comprehensive Guide for Computational Research", "comment": null, "summary": "Pattern-based file access is a fundamental but often under-documented aspect\nof computational research. The Python glob module provides a simple yet\npowerful way to search, filter, and ingest files using wildcard patterns,\nenabling scalable workflows across disciplines. This paper introduces glob as a\nversatile tool for data science, business analytics, and artificial\nintelligence applications. We demonstrate use cases including large-scale data\ningestion, organizational data analysis, AI dataset construction, and\nreproducible research practices. Through concrete Python examples with widely\nused libraries such as pandas,scikit-learn, and matplotlib, we show how glob\nfacilitates efficient file traversal and integration with analytical pipelines.\nBy situating glob within the broader context of reproducible research and data\nengineering, we highlight its role as a methodological building block. Our goal\nis to provide researchers and practitioners with a concise reference that\nbridges foundational concepts and applied practice, making glob a default\ncitation for file pattern matching in Python-based research workflows.", "AI": {"tldr": "This paper showcases the Python glob module as a crucial, under-recognized tool for scalable, reproducible file access and management in research workflows, offering practical examples with popular analytical libraries and advocating glob as the default reference for pattern-based file matching in Python.", "motivation": "Pattern-based file access is essential yet under-documented in computational research, and there is a lack of concise references for leveraging Python's glob for file pattern matching in data-driven workflows.", "method": "The paper describes use cases and provides concrete Python code examples using glob in combination with libraries such as pandas, scikit-learn, and matplotlib to demonstrate practical application in various analytical domains.", "result": "The paper shows that glob enables efficient, scalable file traversal and integration with data analytics pipelines, supporting large-scale data ingestion, organizational analysis, and AI dataset construction.", "conclusion": "Python's glob module is established as a methodological building block for reproducible research and data engineering. The paper serves as a concise bridge between foundational concepts and applied practices, aiming to make glob the go-to citation for file pattern matching in Python."}}
{"id": "2509.08857", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2509.08857", "abs": "https://arxiv.org/abs/2509.08857", "authors": ["Marcelino Garcia", "Renato Garcia", "Arthur Parizotto", "Andre Mendes", "Pedro Valle", "Ricardo Vilela", "Renato Balancieri", "Williamson Silva"], "title": "A Systematic Mapping Study on Chatbots in Programming Education", "comment": "18 pages, 1 figure, 3 tables", "summary": "Educational chatbots have gained prominence as support tools for teaching\nprogramming, particularly in introductory learning contexts. This paper\npresents a Systematic Mapping Study (SMS) that investigated how such agents\nhave been developed and applied in programming education. From an initial set\nof 3,216 publications, 54 studies were selected and analyzed based on five\nresearch subquestions, addressing chatbot types, programming languages used,\neducational content covered, interaction models, and application contexts. The\nresults reveal a predominance of chatbots designed for Python instruction,\nfocusing on fundamental programming concepts, and employing a wide variety of\npedagogical approaches and technological architectures. In addition to\nidentifying trends and gaps in the literature, this study provides insights to\ninform the development of new educational tools for programming instruction.", "AI": {"tldr": "This paper systematically reviews research on educational chatbots for programming. Python is the main programming language, and most chatbots teach foundational concepts. The study maps current trends, gaps, and offers guidance for new tool development.", "motivation": "Educational chatbots are increasingly used to support teaching programming, especially for beginners. The motivation is to systematically map and review how these agents are developed and used in programming education.", "method": "Systematic Mapping Study (SMS): The study reviewed 3,216 publications and selected 54 relevant papers. These were analyzed according to five subquestions: chatbot types, programming languages, educational content, interaction models, and application contexts.", "result": "The study finds most chatbots are designed for teaching Python, with a focus on basic programming concepts. There is a range of pedagogical strategies and technological architectures employed. The review also points out trends and gaps in current literature.", "conclusion": "The findings highlight the predominance of Python-focused educational chatbots, diverse teaching approaches, and varied technical solutions. The study provides recommendations and insights for future development of programming education tools."}}
{"id": "2509.08863", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.08863", "abs": "https://arxiv.org/abs/2509.08863", "authors": ["Qianqian Luo", "Liuchang Xu", "Qingming Lin", "Sensen Wu", "Ruichen Mao", "Chao Wang", "Hailin Feng", "Bo Huang", "Zhenhong Du"], "title": "GeoJSON Agents:A Multi-Agent LLM Architecture for Geospatial Analysis-Function Calling vs Code Generation", "comment": null, "summary": "LLMs have made substantial progress in task automation and natural language\nunderstanding.However,without expertise in GIS,they continue to encounter\nlimitations.To address these issues, we propose GeoJSON Agents-a multi-agent\nLLM architecture.This framework transforms natural language tasks into\nstructured GeoJSON operation commands and processes spatial data using two\nwidely adopted LLM enhancement techniques:Function Calling and Code\nGeneration.The architecture consists of three components-task parsing,agent\ncollaboration,and result integration-aimed at enhancing both the performance\nand scalability of GIS automation.The Planner agent interprets natural language\ntasks into structured GeoJSON commands.Then,specialized Worker agents\ncollaborate according to assigned roles to perform spatial data processing and\nanalysis,either by invoking predefined function APIs or by dynamically\ngenerating and executing Python-based spatial analysis code.Finally,the system\nintegrates the outputs from multiple execution rounds into\nreusable,standards-compliant GeoJSON files.To systematically evaluate the\nperformance of the two approaches,we constructed a benchmark dataset of 70\ntasks with varying complexity and conducted experiments using OpenAI's GPT-4o\nas the core model.Results indicate that the Function Calling-based GeoJSON\nAgent achieved an accuracy of 85.71%,while the Code Generation-based agent\nreached 97.14%,both significantly outperforming the best-performing\ngeneral-purpose model (48.57%).Further analysis reveals that the Code\nGeneration provides greater flexibility,whereas the Function Calling approach\noffers more stable execution.This study is the first to introduce an LLM\nmulti-agent framework for GeoJSON data and to compare the strengths and\nlimitations of two mainstream LLM enhancement methods,offering new perspectives\nfor improving GeoAI system performance.", "AI": {"tldr": "This paper introduces GeoJSON Agents, a multi-agent LLM framework for automating GIS tasks, leveraging Function Calling and Code Generation methods, and demonstrates substantial performance gains over general-purpose models in processing GeoJSON data.", "motivation": "LLMs lack specialized GIS expertise despite their rapid advancement. The authors aim to address these shortcomings by leveraging LLMs within a dedicated GIS multi-agent framework, ultimately increasing the accuracy and scalability of spatial data analysis.", "method": "The authors designed a multi-agent architecture with three key components: task parsing, agent collaboration, and result integration. They benchmarked two approaches (Function Calling and Code Generation) using 70 diverse GIS tasks and evaluated their performance with GPT-4o as the model backbone.", "result": "Function Calling-based GeoJSON Agents achieved 85.71% accuracy, while Code Generation-based agents reached 97.14%, both far surpassing the accuracy of standard LLMs (48.57%). The Code Generation method offered more flexibility, whereas Function Calling provided greater stability.", "conclusion": "GeoJSON Agents significantly increase the automation and effectiveness of GIS tasks. The Code Generation approach delivers higher accuracy and flexibility, while the Function Calling method ensures more stable execution. Both methods outperform general LLMs, marking an important step towards advanced GeoAI systems."}}
{"id": "2509.08865", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.08865", "abs": "https://arxiv.org/abs/2509.08865", "authors": ["Guangyu Zhang", "Xixuan Wang", "Shiyu Sun", "Peiyan Xiao", "Kun Sun", "Yanhai Xiong"], "title": "TraceRAG: A LLM-Based Framework for Explainable Android Malware Detection and Behavior Analysis", "comment": null, "summary": "Sophisticated evasion tactics in malicious Android applications, combined\nwith their intricate behavioral semantics, enable attackers to conceal\nmalicious logic within legitimate functions, underscoring the critical need for\nrobust and in-depth analysis frameworks. However, traditional analysis\ntechniques often fail to recover deeply hidden behaviors or provide\nhuman-readable justifications for their decisions. Inspired by advances in\nlarge language models (LLMs), we introduce TraceRAG, a retrieval-augmented\ngeneration (RAG) framework that bridges natural language queries and Java code\nto deliver explainable malware detection and analysis. First, TraceRAG\ngenerates summaries of method-level code snippets, which are indexed in a\nvector database. At query time, behavior-focused questions retrieve the most\nsemantically relevant snippets for deeper inspection. Finally, based on the\nmulti-turn analysis results, TraceRAG produces human-readable reports that\npresent the identified malicious behaviors and their corresponding code\nimplementations. Experimental results demonstrate that our method achieves 96\\%\nmalware detection accuracy and 83.81\\% behavior identification accuracy based\non updated VirusTotal (VT) scans and manual verification. Furthermore, expert\nevaluation confirms the practical utility of the reports generated by TraceRAG.", "AI": {"tldr": "TraceRAG uses large language models to summarize Android code, retrieve relevant behavior based on natural language questions, and generate easy-to-understand reports, achieving high accuracy in malware detection and behavior identification.", "motivation": "Malicious Android applications often use advanced evasion techniques, hiding harmful behaviors within legitimate code, making them hard to detect with traditional methods. There is a critical need for robust frameworks that can not only recover these hidden behaviors but also provide explainable results.", "method": "TraceRAG, a retrieval-augmented generation (RAG) framework, is introduced. It generates method-level code summaries, indexes them in a vector database, retrieves relevant snippets using natural language queries, and provides multi-turn, human-readable reports that explain detected malicious behaviors along with associated code.", "result": "The framework achieved a 96% malware detection accuracy and 83.81% behavior identification accuracy, validated with updated VirusTotal scans and manual checks. Expert evaluations indicate that the generated reports are practically useful.", "conclusion": "TraceRAG successfully bridges the gap between code analysis and natural language explanations, making malware detection more transparent and effective for analysts. It significantly outperforms traditional methods in both detection and explainability."}}
{"id": "2509.08867", "categories": ["cs.SE", "cs.AI", "68T01", "I.2.7"], "pdf": "https://arxiv.org/pdf/2509.08867", "abs": "https://arxiv.org/abs/2509.08867", "authors": ["K. Pronk", "Q. Zhao"], "title": "Benchmarking Energy Efficiency of Large Language Models Using vLLM", "comment": "6 pages, 6 figures", "summary": "The prevalence of Large Language Models (LLMs) is having an growing impact on\nthe climate due to the substantial energy required for their deployment and\nuse. To create awareness for developers who are implementing LLMs in their\nproducts, there is a strong need to collect more information about the energy\nefficiency of LLMs. While existing research has evaluated the energy efficiency\nof various models, these benchmarks often fall short of representing realistic\nproduction scenarios. In this paper, we introduce the LLM Efficiency Benchmark,\ndesigned to simulate real-world usage conditions. Our benchmark utilizes vLLM,\na high-throughput, production-ready LLM serving backend that optimizes model\nperformance and efficiency. We examine how factors such as model size,\narchitecture, and concurrent request volume affect inference energy efficiency.\nOur findings demonstrate that it is possible to create energy efficiency\nbenchmarks that better reflect practical deployment conditions, providing\nvaluable insights for developers aiming to build more sustainable AI systems.", "AI": {"tldr": "The paper presents a new benchmark for measuring energy efficiency of LLMs under realistic conditions, highlighting key factors affecting energy use and helping developers make sustainable choices.", "motivation": "The increasing deployment of Large Language Models (LLMs) is leading to significant energy consumption, impacting climate change. Developers need more accurate data on energy efficiency to make sustainable choices, but current benchmarks do not adequately represent real-world LLM usage.", "method": "The paper introduces the LLM Efficiency Benchmark, which simulates realistic production scenarios using vLLM, a high-throughput, production-ready backend. It examines the effects of model size, architecture, and request concurrency on inference energy efficiency.", "result": "The study shows that energy efficiency benchmarks can be designed to better align with practical conditions. Factors such as model size, architecture, and concurrent requests significantly influence energy consumption during inference.", "conclusion": "The LLM Efficiency Benchmark provides more applicable insights into energy use in real-world deployments, assisting developers to build more sustainable AI solutions."}}
{"id": "2509.09072", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.09072", "abs": "https://arxiv.org/abs/2509.09072", "authors": ["Ahmed Adnan", "Mushfiqur Rahman", "Saad Sakib Noor", "Kazi Sakib"], "title": "CLARA: A Developer's Companion for Code Comprehension and Analysis", "comment": "In proceedings at the 40th IEEE/ACM International Conference on\n  Automated Software Engineering, ASE 2025", "summary": "Code comprehension and analysis of open-source project codebases is a task\nfrequently performed by developers and researchers. However, existing tools\nthat practitioners use for assistance with such tasks often require prior\nproject setup, lack context-awareness, and involve significant manual effort.\nTo address this, we present CLARA, a browser extension that utilizes a\nstate-of-the-art inference model to assist developers and researchers in: (i)\ncomprehending code files and code fragments, (ii) code refactoring, and (iii)\ncode quality attribute detection. We qualitatively evaluated CLARA's inference\nmodel using existing datasets and methodology, and performed a comprehensive\nuser study with 10 developers and academic researchers to assess its usability\nand usefulness. The results show that CLARA is useful, accurate, and practical\nin code comprehension and analysis tasks. CLARA is an open-source tool\navailable at https://github.com/SaadNoor555/CLARA_tool_demo. A video showing\nthe full capabilities of CLARA can be found at\nhttps://youtu.be/VDKVXvIH41Q?si=qBFsmS_Y4m_9x3YH.", "AI": {"tldr": "CLARA is a context-aware browser extension that uses advanced inference models to help users comprehend, refactor, and evaluate the quality of code in open-source projects without extensive setup, demonstrating strong usability and accuracy in both evaluations and a user study.", "motivation": "Developers and researchers frequently need to comprehend and analyze open-source project codebases, but current tools require prior setup, lack context-awareness, and demand substantial manual effort.", "method": "CLARA, a browser extension, leverages a state-of-the-art inference model to provide assistance in understanding code files and fragments, code refactoring, and code quality detection. Its effectiveness was assessed via qualitative evaluation using existing datasets and methodologies, as well as a comprehensive user study with 10 developers and researchers.", "result": "The study found that CLARA is useful, accurate, and practical for code comprehension and analysis tasks.", "conclusion": "CLARA significantly improves the practicality and efficiency of code comprehension and analysis for developers and researchers."}}
{"id": "2509.09192", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.09192", "abs": "https://arxiv.org/abs/2509.09192", "authors": ["Doha Nam", "Taehyoun Kim", "Duksan Ryu", "Jongmoon Baik"], "title": "Probing Pre-trained Language Models on Code Changes: Insights from ReDef, a High-Confidence Just-in-Time Defect Prediction Dataset", "comment": "An anonymous link containing the dataset, construction scripts, and\n  experimental code is publicly available for reproducibility:\n  https://figshare.com/s/4f202bc0921e26b41dc2", "summary": "Just-in-Time software defect prediction (JIT-SDP) plays a critical role in\nprioritizing risky code changes during code review and continuous integration.\nHowever, existing datasets often suffer from noisy labels and low precision in\nidentifying bug-inducing commits. To address this, we present ReDef\n(Revert-based Defect dataset), a high-confidence benchmark of function-level\nmodifications curated from 22 large-scale C/C++ projects. Defective cases are\nanchored by revert commits, while clean cases are validated through post-hoc\nhistory checks. Ambiguous instances are conservatively filtered out via a\nGPT-assisted triage process involving multiple votes and audits. This pipeline\nyields 3,164 defective and 10,268 clean modifications, offering substantially\nmore reliable labels than prior existing resources. Beyond dataset\nconstruction, we provide the first systematic evaluation of how pre-trained\nlanguage models (PLMs) reason about code modifications -- specifically, which\ninput encodings most effectively expose change information, and whether models\ngenuinely capture edit semantics. We fine-tune CodeBERT, CodeT5+, and UniXcoder\nunder five encoding strategies, and further probe their sensitivity through\ncounterfactual perturbations that swap added/deleted blocks, invert diff\npolarity, or inject spurious markers. Our results show that compact diff-style\nencodings consistently outperform whole-function formats across all PLMs, with\nstatistical tests confirming large, model-independent effects. However, under\ncounterfactual tests, performance degrades little or not at all -- revealing\nthat what appears to be robustness in fact reflects reliance on superficial\ncues rather than true semantic understanding. These findings indicate that,\nunlike in snapshot-based tasks, current PLMs remain limited in their ability to\ngenuinely comprehend code modifications.", "AI": {"tldr": "A new, reliable benchmark dataset (ReDef) enables better evaluation of code change defect prediction, showing that pre-trained code models mostly depend on shallow input cues rather than truly understanding code modifications.", "motivation": "The motivation comes from the need to improve the reliability and precision of Just-in-Time software defect prediction (JIT-SDP), which suffers from noisy and imprecise datasets for identifying bug-inducing code changes.", "method": "The authors introduce 'ReDef,' a new dataset of function-level code modifications identified as defective or clean in C/C++ projects. Defective cases are based on revert commits, clean ones are history-validated, and ambiguous cases are filtered via a GPT-assisted triage process. They use this dataset to systematically evaluate pre-trained language models (PLMs) on code change reasoning using various encoding strategies and counterfactual perturbations.", "result": "Compact diff-style encoding of code changes leads to consistently better performance across PLMs compared to whole-function encoding. However, the PLMs' seemingly robust performance against counterfactual tests reveals reliance on superficial input cues, not true semantic understanding of code modifications.", "conclusion": "The ReDef dataset provides a higher-quality benchmark for JIT-SDP, and while encoding choice matters for PLM performance on code modification reasoning, current models still lack true comprehension of code edits and depend on shallow cues."}}
{"id": "2509.09194", "categories": ["cs.SE", "cs.AI", "68N19"], "pdf": "https://arxiv.org/pdf/2509.09194", "abs": "https://arxiv.org/abs/2509.09194", "authors": ["Ayelet Berzack", "Guy Katz"], "title": "On Integrating Large Language Models and Scenario-Based Programming for Improving Software Reliability", "comment": null, "summary": "Large Language Models (LLMs) are fast becoming indispensable tools for\nsoftware developers, assisting or even partnering with them in crafting complex\nprograms. The advantages are evident -- LLMs can significantly reduce\ndevelopment time, generate well-organized and comprehensible code, and\noccasionally suggest innovative ideas that developers might not conceive on\ntheir own. However, despite their strengths, LLMs will often introduce\nsignificant errors and present incorrect code with persuasive confidence,\npotentially misleading developers into accepting flawed solutions.\n  In order to bring LLMs into the software development cycle in a more reliable\nmanner, we propose a methodology for combining them with ``traditional''\nsoftware engineering techniques in a structured way, with the goal of\nstreamlining the development process, reducing errors, and enabling users to\nverify crucial program properties with increased confidence. Specifically, we\nfocus on the Scenario-Based Programming (SBP) paradigm -- an event-driven,\nscenario-based approach for software engineering -- to allow human developers\nto pour their expert knowledge into the LLM, as well as to inspect and verify\nits outputs.\n  To evaluate our methodology, we conducted a significant case study, and used\nit to design and implement the Connect4 game. By combining LLMs and SBP we were\nable to create a highly-capable agent, which could defeat various strong\nexisting agents. Further, in some cases, we were able to formally verify the\ncorrectness of our agent. Finally, our experience reveals interesting insights\nregarding the ease-of-use of our proposed approach. The full code of our\ncase-study will be made publicly available with the final version of this\npaper.", "AI": {"tldr": "LLMs are powerful for code generation but can be confidently wrong. By integrating LLMs with scenario-based programming, developers can guide, verify, and correct AI outputs. The proposed structured approach reduced errors and allowed partial formal verification in a Connect4 agent case study, showing its practical value.", "motivation": "LLMs, despite their capabilities, can produce erroneous code with convincing confidence. This poses a risk in software development. The authors are motivated to harness LLM productivity while mitigating error risk, seeking a more reliable integration with established software engineering techniques.", "method": "They propose a structured methodology that combines LLMs with traditional software engineering, particularly focusing on the Scenario-Based Programming (SBP) paradigm\u2014an event-driven approach allowing human expertise to guide, inspect, and verify LLM output.", "result": "Using their methodology, they designed and implemented a Connect4 game agent. This combined approach resulted in a highly competent agent, capable of defeating strong existing agents, and allowed for formal verification of correctness in some cases. They also observed favorable ease-of-use with their method.", "conclusion": "Combining LLMs with SBP leverages human expertise to guide AI-driven code creation, improves reliability, enables formal verification, and offers a practical, user-friendly workflow for software development."}}
{"id": "2509.09294", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.09294", "abs": "https://arxiv.org/abs/2509.09294", "authors": ["Solal Rapaport", "Laurent Pautet", "Samuel Tardieu", "Stefano Zacchiroli"], "title": "Altered Histories in Version Control System Repositories: Evidence from the Trenches", "comment": null, "summary": "Version Control Systems (VCS) like Git allow developers to locally rewrite\nrecorded history, e.g., to reorder and suppress commits or specific data in\nthem. These alterations have legitimate use cases, but become problematic when\nperformed on public branches that have downstream users: they break push/pull\nworkflows, challenge the integrity and reproducibility of repositories, and\ncreate opportunities for supply chain attackers to sneak into them nefarious\nchanges. We conduct the first large-scale investigation of Git history\nalterations in public code repositories. We analyze 111 M (millions)\nrepositories archived by Software Heritage, which preserves VCS histories even\nacross alterations. We find history alterations in 1.22 M repositories, for a\ntotal of 8.7 M rewritten histories. We categorize changes by where they happen\n(which repositories, which branches) and what is changed in them (files or\ncommit metadata). Conducting two targeted case studies we show that altered\nhistories recurrently change licenses retroactively, or are used to remove\n''secrets'' (e.g., private keys) committed by mistake. As these behaviors\ncorrespond to bad practices-in terms of project governance or security\nmanagement, respectively-that software recipients might want to avoid, we\nintroduce GitHistorian, an automated tool, that developers can use to spot and\ndescribe history alterations in public Git repositories.", "AI": {"tldr": "Large-scale study finds that rewriting history in public Git repositories is common, often introducing security and governance risks. The authors present the GitHistorian tool to help spot and describe such alterations, supporting better management of repository integrity.", "motivation": "The study is motivated by the risks introduced when developers rewrite history in public version control system (VCS) branches, which can compromise repository integrity, reproducibility, and security, especially in the context of the software supply chain.", "method": "The authors conducted a large-scale analysis of 111 million repositories archived by Software Heritage, searching for and categorizing Git history alterations. Two case studies were performed to illustrate the real-world impact of such alterations. Additionally, the authors developed GitHistorian, a tool to detect and describe history changes in Git repositories.", "result": "The investigation found history alterations in 1.22 million repositories, amounting to 8.7 million rewritten histories. The study revealed that these alterations often involve retroactively changing licenses or removing secrets such as private keys, both considered bad practices. The GitHistorian tool was introduced to help detect such events.", "conclusion": "History rewriting in public Git repositories is a widespread phenomenon with significant implications for security and project governance. The authors provide empirical insights and a practical tool (GitHistorian) to address these risks and assist developers in identifying problematic history changes."}}
{"id": "2509.09313", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.09313", "abs": "https://arxiv.org/abs/2509.09313", "authors": ["Moritz Mock", "Thomas Forrer", "Barbara Russo"], "title": "Cross-Domain Evaluation of Transformer-Based Vulnerability Detection on Open & Industry Data", "comment": "Accepted to the 26th International Conference on Product-Focused\n  Software Process Improvement (PROFES 2025)", "summary": "Deep learning solutions for vulnerability detection proposed in academic\nresearch are not always accessible to developers, and their applicability in\nindustrial settings is rarely addressed. Transferring such technologies from\nacademia to industry presents challenges related to trustworthiness, legacy\nsystems, limited digital literacy, and the gap between academic and industrial\nexpertise. For deep learning in particular, performance and integration into\nexisting workflows are additional concerns. In this work, we first evaluate the\nperformance of CodeBERT for detecting vulnerable functions in industrial and\nopen-source software. We analyse its cross-domain generalisation when\nfine-tuned on open-source data and tested on industrial data, and vice versa,\nalso exploring strategies for handling class imbalance. Based on these results,\nwe develop AI-DO(Automating vulnerability detection Integration for Developers'\nOperations), a Continuous Integration-Continuous Deployment (CI/CD)-integrated\nrecommender system that uses fine-tuned CodeBERT to detect and localise\nvulnerabilities during code review without disrupting workflows. Finally, we\nassess the tool's perceived usefulness through a survey with the company's IT\nprofessionals. Our results show that models trained on industrial data detect\nvulnerabilities accurately within the same domain but lose performance on\nopen-source code, while a deep learner fine-tuned on open data, with\nappropriate undersampling techniques, improves the detection of\nvulnerabilities.", "AI": {"tldr": "Academic deep learning vulnerability detectors often don't fit industrial needs. The paper evaluates CodeBERT for vulnerability detection across domains, develops an integrated tool (AI-DO), and finds that domain-specific training is strong locally but lacks cross-domain power, while open-source fine-tuning with undersampling helps generalizability.", "motivation": "Many academic deep learning solutions for vulnerability detection are not accessible or easily applicable in industrial settings, presenting issues of trust, compatibility, expertise gaps, and workflow integration.", "method": "The authors evaluate CodeBERT's performance in detecting vulnerable functions across both industrial and open-source software. They analyze cross-domain generalization, class imbalance strategies, and develop AI-DO, a CI/CD-integrated recommender system using fine-tuned CodeBERT. The tool's usefulness is assessed via a professional IT survey.", "result": "CodeBERT models trained on industrial data perform well on data from the same domain but do not generalize to open-source code. Fine-tuning on open-source data with undersampling improves vulnerability detection.", "conclusion": "Industrial data-trained models are effective within their own domain but not across domains. Fine-tuning on diverse data and managing class imbalance are crucial for improved vulnerability detection."}}
{"id": "2509.09322", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.09322", "abs": "https://arxiv.org/abs/2509.09322", "authors": ["Jacopo Bufalino", "Agathe Blaise", "Stefano Secci"], "title": "ORCA: Unveiling Obscure Containers In The Wild", "comment": null, "summary": "Modern software development increasingly depends on open-source libraries and\nthird-party components, which are often encapsulated into containerized\nenvironments. While improving the development and deployment of applications,\nthis approach introduces security risks, particularly when outdated or\nvulnerable components are inadvertently included in production environments.\nSoftware Composition Analysis (SCA) is a critical process that helps identify\nand manage packages and dependencies inside a container. However, unintentional\nmodifications to the container filesystem can lead to incomplete container\nimages, which compromise the reliability of SCA tools. In this paper, we\nexamine the limitations of both cloud-based and open-source SCA tools when\nfaced with such obscure images. An analysis of 600 popular containers revealed\nthat obscure containers exist in well-known registries and trusted images and\nthat many tools fail to analyze such containers. To mitigate these issues, we\npropose an obscuration-resilient methodology for container analysis and\nintroduce ORCA (Obscuration-Resilient Container Analyzer), its open-source\nimplementation. We reported our findings to all vendors using their appropriate\nchannels. Our results demonstrate that ORCA effectively detects the content of\nobscure containers and achieves a median 40% improvement in file coverage\ncompared to Docker Scout and Syft.", "AI": {"tldr": "Outdated or modified containers hinder standard SCA tools, exposing security risks. ORCA, a new tool, better analyzes obscure containers, improving coverage by a median 40% over leading alternatives.", "motivation": "Modern software relies heavily on open-source components in containers, but unintentionally obscure container images undermine the reliability of Software Composition Analysis (SCA), increasing security risks.", "method": "The authors analyzed 600 popular container images from well-known registries, evaluated SCA tools, and developed ORCA\u2014a new tool designed to be resilient to container obscuration.", "result": "ORCA significantly improves the detection of contents in obscure containers, achieving a median 40% better file coverage than popular tools like Docker Scout and Syft.", "conclusion": "Existing SCA tools often fail to analyze obscure containers found in trusted registries. The newly proposed ORCA tool addresses these limitations, offering enhanced analysis and file coverage."}}
{"id": "2509.09614", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2509.09614", "abs": "https://arxiv.org/abs/2509.09614", "authors": ["Jielin Qiu", "Zuxin Liu", "Zhiwei Liu", "Rithesh Murthy", "Jianguo Zhang", "Haolin Chen", "Shiyu Wang", "Ming Zhu", "Liangwei Yang", "Juntao Tan", "Zhepeng Cen", "Cheng Qian", "Shelby Heinecke", "Weiran Yao", "Silvio Savarese", "Caiming Xiong", "Huan Wang"], "title": "LoCoBench: A Benchmark for Long-Context Large Language Models in Complex Software Engineering", "comment": "53 pages", "summary": "The emergence of long-context language models with context windows extending\nto millions of tokens has created new opportunities for sophisticated code\nunderstanding and software development evaluation. We propose LoCoBench, a\ncomprehensive benchmark specifically designed to evaluate long-context LLMs in\nrealistic, complex software development scenarios. Unlike existing code\nevaluation benchmarks that focus on single-function completion or short-context\ntasks, LoCoBench addresses the critical evaluation gap for long-context\ncapabilities that require understanding entire codebases, reasoning across\nmultiple files, and maintaining architectural consistency across large-scale\nsoftware systems. Our benchmark provides 8,000 evaluation scenarios\nsystematically generated across 10 programming languages, with context lengths\nspanning 10K to 1M tokens, a 100x variation that enables precise assessment of\nlong-context performance degradation in realistic software development\nsettings. LoCoBench introduces 8 task categories that capture essential\nlong-context capabilities: architectural understanding, cross-file refactoring,\nmulti-session development, bug investigation, feature implementation, code\ncomprehension, integration testing, and security analysis. Through a 5-phase\npipeline, we create diverse, high-quality scenarios that challenge LLMs to\nreason about complex codebases at unprecedented scale. We introduce a\ncomprehensive evaluation framework with 17 metrics across 4 dimensions,\nincluding 8 new evaluation metrics, combined in a LoCoBench Score (LCBS). Our\nevaluation of state-of-the-art long-context models reveals substantial\nperformance gaps, demonstrating that long-context understanding in complex\nsoftware development represents a significant unsolved challenge that demands\nmore attention. LoCoBench is released at:\nhttps://github.com/SalesforceAIResearch/LoCoBench.", "AI": {"tldr": "LoCoBench is a new benchmark to rigorously test long-context LLMs on realistic, complex software development scenarios across many languages and tasks. Current models fall short on these challenging tasks, showing that long-context code understanding remains an unsolved problem. LoCoBench is available for further research.", "motivation": "Recent advances in language models (LLMs) with extremely long context windows allow for processing millions of tokens, which creates opportunities for improved code understanding and software development tools. However, current benchmarks focus mostly on short-context tasks or single-function completion and do not adequately test these new capabilities. There is a critical need for benchmarks that assess LLMs' performance in realistic, large-scale codebase scenarios.", "method": "The paper introduces LoCoBench, a new benchmark designed to evaluate long-context LLMs on realistic software development tasks. LoCoBench consists of 8,000 scenarios covering 10 programming languages, with varying context lengths from 10K to 1M tokens. It covers 8 categories of tasks crucial for software engineering, such as architectural understanding, bug investigation, and integration testing. The benchmark uses a 5-phase generation pipeline to create diverse scenarios and defines a comprehensive evaluation framework with 17 distinct metrics, including the new LoCoBench Score (LCBS).", "result": "State-of-the-art long-context LLMs were evaluated using LoCoBench, and the results revealed significant performance gaps, especially when reasoning about complex, large-scale codebases across long contexts. The current generation of long-context LLMs struggle to maintain high performance in these scenarios, highlighting areas that demand further research and development.", "conclusion": "Long-context LLMs have considerable potential for software engineering, but their capabilities on large-scale, realistic codebases are still lacking. LoCoBench establishes a challenging and comprehensive standard for evaluating these abilities, exposing gaps in current models and encouraging advancement in long-context code understanding. The benchmark and associated tools are publicly available for the research community."}}
{"id": "2509.09630", "categories": ["cs.SE", "cs.CR"], "pdf": "https://arxiv.org/pdf/2509.09630", "abs": "https://arxiv.org/abs/2509.09630", "authors": ["Zhenguang Liu", "Lixun Ma", "Zhongzheng Mu", "Chengkun Wei", "Xiaojun Xu", "Yingying Jiao", "Kui Ren"], "title": "I Know Who Clones Your Code: Interpretable Smart Contract Similarity Detection", "comment": null, "summary": "Widespread reuse of open-source code in smart contract development boosts\nprogramming efficiency but significantly amplifies bug propagation across\ncontracts, while dedicated methods for detecting similar smart contract\nfunctions remain very limited. Conventional abstract-syntax-tree (AST) based\nmethods for smart contract similarity detection face challenges in handling\nintricate tree structures, which impedes detailed semantic comparison of code.\nRecent deep-learning based approaches tend to overlook code syntax and\ndetection interpretability, resulting in suboptimal performance.\n  To fill this research gap, we introduce SmartDetector, a novel approach for\ncomputing similarity between smart contract functions, explainable at the\nfine-grained statement level. Technically, SmartDetector decomposes the AST of\na smart contract function into a series of smaller statement trees, each\nreflecting a structural element of the source code. Then, SmartDetector uses a\nclassifier to compute the similarity score of two functions by comparing each\npair of their statement trees. To address the infinite hyperparameter space of\nthe classifier, we mathematically derive a cosine-wise diffusion process to\nefficiently search optimal hyperparameters. Extensive experiments conducted on\nthree large real-world datasets demonstrate that SmartDetector outperforms\ncurrent state-of-the-art methods by an average improvement of 14.01% in\nF1-score, achieving an overall average F1-score of 95.88%.", "AI": {"tldr": "SmartDetector is a novel, interpretable smart contract similarity detection tool that breaks down code for fine-grained comparison using AST decomposition and classifier optimization, outperforming prior methods with a 95.88% F1-score.", "motivation": "The reuse of open-source code in smart contracts increases programming efficiency but also spreads bugs widely. Existing methods for detecting code similarity in smart contracts are limited, facing challenges with detailed semantic comparison and interpretability.", "method": "The paper introduces SmartDetector, which breaks down the abstract syntax tree (AST) of smart contract functions into smaller statement trees for fine-grained semantic comparison. A classifier compares corresponding statement trees between functions to compute similarity. Hyperparameter optimization is addressed using a mathematically derived cosine-wise diffusion process.", "result": "SmartDetector was evaluated on three large real-world datasets and was shown to outperform existing state-of-the-art methods, with an average improvement of 14.01% in F1-score. The overall average F1-score achieved was 95.88%.", "conclusion": "SmartDetector provides an explainable and effective method for detecting similarity between smart contract functions at a fine-grained level, overcoming limitations of previous approaches and enhancing bug detection capabilities in smart contract code."}}

{"id": "2509.18583", "categories": ["cs.PL", "quant-ph"], "pdf": "https://arxiv.org/pdf/2509.18583", "abs": "https://arxiv.org/abs/2509.18583", "authors": ["Liyi Li", "Fenfen An", "Federico Zahariev", "Zhi Xiang Chong", "Amr Sabry", "Mark Gordon"], "title": "A Verified Compiler for Quantum Simulation", "comment": "Paper accepted to the Quantum Programming Languages (QPL) 2025\n  conference; available from: https://qpl2025.github.io/accepted/", "summary": "Hamiltonian simulation is a central application of quantum computing, with\nsignificant potential in modeling physical systems and solving complex\noptimization problems. Existing compilers for such simulations typically focus\non low-level representations based on Pauli operators, limiting programmability\nand offering no formal guarantees of correctness across the compilation\npipeline. We introduce QBlue, a high-level, formally verified framework for\ncompiling Hamiltonian simulations. QBlue is based on the formalism of second\nquantization, which provides a natural and expressive way to describe quantum\nparticle systems using creation and annihilation operators. To ensure safety\nand correctness, QBlue includes a type system that tracks particle types and\nenforces Hermitian structure. The framework supports compilation to both\ndigital and analog quantum circuits and captures multiple layers of semantics,\nfrom static constraints to dynamic evolution. All components of QBlue,\nincluding its language design, type system, and compilation correctness, are\nfully mechanized in the Rocq proof framework, making it the first end-to-end\nverified compiler for second-quantized Hamiltonian simulation.", "AI": {"tldr": "QBlue is a high-level, fully verified compiler framework for Hamiltonian simulations using second quantization. It ensures safety, expressiveness, and correctness in quantum programming\u2014surpassing the limitations of Pauli-based compilers\u2014and is the first to achieve end-to-end formal verification for these simulations.", "motivation": "Current Hamiltonian simulation compilers are based on low-level Pauli operator representations, which restrict programmability and lack formal correctness guarantees. There is a need for higher-level, more expressive, and formally verified compilation frameworks.", "method": "The authors introduce QBlue, a high-level framework for compiling Hamiltonian simulations. It leverages the second quantization formalism for describing quantum systems, employs a type system for safety and correctness, supports compilation to both digital and analog quantum circuits, and is fully mechanized and verified within the Rocq proof framework.", "result": "QBlue provides formal guarantees of correctness across the compilation pipeline, supports expressive modeling using second quantization, enforces structural and type constraints, and is the first end-to-end verified compiler for Hamiltonian simulation using this formalism.", "conclusion": "QBlue advances the field of quantum simulation compilation by offering a high-level, formally verified, and expressive approach that bridges programmability with correctness, filling a major gap in current quantum compiler technology."}}
{"id": "2509.18337", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18337", "abs": "https://arxiv.org/abs/2509.18337", "authors": ["Bo Xiong", "Linghao Zhang", "Chong Wang", "Peng Liang"], "title": "CoRaCMG: Contextual Retrieval-Augmented Framework for Commit Message Generation", "comment": "15 pages, 4 images, 6 tables, Manuscript submitted to a Journal\n  (2025)", "summary": "Commit messages play a key role in documenting the intent behind code\nchanges. However, they are often low-quality, vague, or incomplete, limiting\ntheir usefulness. Commit Message Generation (CMG) aims to automatically\ngenerate descriptive commit messages from code diffs to reduce developers'\neffort and improve message quality. Although recent advances in LLMs have shown\npromise in automating CMG, their performance remains limited. This paper aims\nto enhance CMG performance by retrieving similar diff-message pairs to guide\nLLMs to generate commit messages that are more precise and informative. We\nproposed CoRaCMG, a Contextual Retrieval-augmented framework for Commit Message\nGeneration, structured in three phases: (1) Retrieve: retrieving the similar\ndiff-message pairs; (2) Augment: combining them with the query diff into a\nstructured prompt; and (3) Generate: generating commit messages corresponding\nto the query diff via LLMs. CoRaCMG enables LLMs to learn project-specific\nterminologies and writing styles from the retrieved diff-message pairs, thereby\nproducing high-quality commit messages. We evaluated our method on various\nLLMs, including closed-source GPT models and open-source DeepSeek models.\nExperimental results show that CoRaCMG significantly boosts LLM performance\nacross four metrics (BLEU, Rouge-L, METEOR, and CIDEr). Specifically,\nDeepSeek-R1 achieves relative improvements of 76% in BLEU and 71% in CIDEr when\naugmented with a single retrieved example pair. After incorporating the single\nexample pair, GPT-4o achieves the highest improvement rate, with BLEU\nincreasing by 89%. Moreover, performance gains plateau after more than three\nexamples are used, indicating diminishing returns. Further analysis shows that\nthe improvements are attributed to the model's ability to capture the\nterminologies and writing styles of human-written commit messages from the\nretrieved example pairs.", "AI": {"tldr": "CoRaCMG boosts LLM-generated commit messages by retrieving and incorporating similar example pairs, leading to substantial quality improvements across several metrics, with diminishing returns after three examples.", "motivation": "Commit messages are essential for documenting code changes but often lack quality, making them less useful. Improving automated commit message generation can reduce developer effort and enhance clarity.", "method": "The paper proposes CoRaCMG, a framework that augments LLMs with context by retrieving similar diff-message pairs and feeding them as structured prompts to the model. The process involves retrieval of examples, prompt augmentation, and message generation using LLMs.", "result": "CoRaCMG significantly improves LLM performance on CMG across four benchmark metrics (BLEU, Rouge-L, METEOR, CIDEr), with relative improvements up to 89%. Gains plateau after three retrieved examples, suggesting diminishing returns. Improvements are traced to the model's better use of project-specific terminology and writing style.", "conclusion": "Incorporating retrieved diff-message pairs into LLM prompts consistently enhances the generation of precise and informative commit messages, helping models better learn from human-written examples."}}
{"id": "2509.18361", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2509.18361", "abs": "https://arxiv.org/abs/2509.18361", "authors": ["Daye Nam", "Malgorzata Salawa", "Satish Chandra"], "title": "Reading Between the Lines: Scalable User Feedback via Implicit Sentiment in Developer Prompts", "comment": null, "summary": "Evaluating developer satisfaction with conversational AI assistants at scale\nis critical but challenging. User studies provide rich insights, but are\nunscalable, while large-scale quantitative signals from logs or in-product\nratings are often too shallow or sparse to be reliable. To address this gap, we\npropose and evaluate a new approach: using sentiment analysis of developer\nprompts to identify implicit signals of user satisfaction. With an analysis of\nindustrial usage logs of 372 professional developers, we show that this\napproach can identify a signal in ~8% of all interactions, a rate more than 13\ntimes higher than explicit user feedback, with reasonable accuracy even with an\noff-the-shelf sentiment analysis approach. This new practical approach to\ncomplement existing feedback channels would open up new directions for building\na more comprehensive understanding of the developer experience at scale.", "AI": {"tldr": "The paper shows that analyzing the sentiment in developer prompts using automated sentiment analysis can capture significantly more implicit feedback about satisfaction with conversational AI assistants than explicit methods, offering a scalable approach to improve understanding of developer experience.", "motivation": "User studies give deep insights into developer satisfaction but are not scalable, while large-scale quantitative measures (like logs or product ratings) are often shallow or unreliable. There is a need for scalable, reliable signals of developer satisfaction with conversational AI assistants.", "method": "The authors propose leveraging sentiment analysis on developer prompts as an implicit measure of user satisfaction. They applied sentiment analysis to industrial usage logs from 372 professional developers and assessed the utility and accuracy of this signal relative to explicit feedback.", "result": "Sentiment analysis detected satisfaction signals in about 8% of all interactions\u2014over 13 times more than explicit user feedback\u2014with reasonable accuracy, even when using an off-the-shelf sentiment analysis method.", "conclusion": "Sentiment analysis of developer prompts can serve as a scalable, practical complement to explicit feedback mechanisms, enabling more comprehensive and reliable insights into developer satisfaction with conversational AI assistants."}}
{"id": "2509.18454", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18454", "abs": "https://arxiv.org/abs/2509.18454", "authors": ["Andrzej Bia\u0142ecki", "Piotr Bia\u0142ecki", "Piotr Sowi\u0144ski", "Mateusz Budziak", "Jan Gajewski"], "title": "SC2Tools: StarCraft II Toolset and Dataset API", "comment": null, "summary": "Computer games, as fully controlled simulated environments, have been\nutilized in significant scientific studies demonstrating the application of\nReinforcement Learning (RL). Gaming and esports are key areas influenced by the\napplication of Artificial Intelligence (AI) and Machine Learning (ML) solutions\nat scale. Tooling simplifies scientific workloads and is essential for\ndeveloping the gaming and esports research area.\n  In this work, we present ``SC2Tools'', a toolset containing multiple\nsubmodules responsible for working with, and producing larger datasets. We\nprovide a modular structure of the implemented tooling, leaving room for future\nextensions where needed. Additionally, some of the tools are not StarCraft~2\nexclusive and can be used with other types of data for dataset creation.\n  The tools we present were leveraged in creating one of the largest\nStarCraft~2 tournament datasets to date with a separate PyTorch and PyTorch\nLightning application programming interface (API) for easy access to the data.\n  We conclude that alleviating the burden of data collection, preprocessing,\nand custom code development is essential for less technically proficient\nresearchers to engage in the growing gaming and esports research area. Finally,\nour solution provides some foundational work toward normalizing experiment\nworkflow in StarCraft~2", "AI": {"tldr": "SC2Tools is a modular toolkit that eases the creation and handling of large esports datasets, specifically in StarCraft 2, and provides user-friendly APIs to support gaming research, making it more accessible and standardized for the scientific community.", "motivation": "Gaming and esports research increasingly relies on RL, AI, and ML, but faces challenges in data collection, preprocessing, and technical implementation. There is a need for streamlined tooling to support researchers and enable the creation of large datasets.", "method": "The authors introduce SC2Tools, a modular toolset with submodules designed for dataset creation and management. The toolkit supports both StarCraft 2 and other data types, and offers APIs in PyTorch and PyTorch Lightning for easy data access.", "result": "SC2Tools was instrumental in producing one of the largest StarCraft 2 tournament datasets. The modular structure allows future extension, and the provided APIs simplify data utilization for research.", "conclusion": "SC2Tools reduces the technical and developmental burden on researchers, making esports and gaming studies more accessible. It helps standardize experiment workflows in StarCraft 2 and potentially other domains."}}
{"id": "2509.18548", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18548", "abs": "https://arxiv.org/abs/2509.18548", "authors": ["Steven R Brandt", "Max Morris", "Patrick Diehl", "Christopher Bowen", "Jacob Tucker", "Lauren Bristol", "Golden G. Richard III"], "title": "Locking Down Science Gateways", "comment": null, "summary": "The most recent Linux kernels have a new feature for securing applications:\nLandlock. Like Seccomp before it, Landlock makes it possible for a running\nprocess to give up access to resources. For applications running as Science\nGateways, network access is required while starting up MPI, but for the sake of\nsecurity, it should be taken away prior to the reading of user-supplied\nparameter files. We explore the usefulness of Landlock by modifying and locking\ndown three mature scientific codes: The Einstein Toolkit (a code that studies\nthe dynamics of relativistic astrophysics, e.g. neutron star collisions),\nOcto-Tiger (a code for studying the dynamics of non-relativistic astrophysics,\ne.g. white dwarfs), and FUKA (an initial data solver for relativistic codes).\nFinally, we implement a fully-functioning FUKA science gateway that relies on\nLandlock (instead of user authentication) for security.", "AI": {"tldr": "Landlock in modern Linux kernels enables applications to shed resource access during execution. The authors adapted several scientific codes to use Landlock, successfully building a more secure science gateway that relies on Landlock for protection, instead of traditional authentication.", "motivation": "Science Gateway applications require network access during startup but need to minimize security risks by dropping unnecessary privileges before processing user input. Existing security mechanisms like Seccomp inspired new features like Landlock.", "method": "The authors evaluated the practicality of Landlock by integrating it into three scientific codes\u2014The Einstein Toolkit, Octo-Tiger, and FUKA\u2014then developed a science gateway for FUKA that uses Landlock for security instead of traditional user authentication.", "result": "Landlock could effectively restrict resource access after startup, thereby enhancing security for scientific applications running as Science Gateways. A functional FUKA science gateway was implemented utilizing Landlock.", "conclusion": "Landlock is a useful new Linux kernel feature for restricting application privileges at runtime, providing an alternative or complement to existing application security models in scientific gateways."}}
{"id": "2509.18808", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2509.18808", "abs": "https://arxiv.org/abs/2509.18808", "authors": ["Zexun Zhan", "Shuzheng Gao", "Ruida Hu", "Cuiyun Gao"], "title": "SR-Eval: Evaluating LLMs on Code Generation under Stepwise Requirement Refinement", "comment": null, "summary": "Large language models (LLMs) have achieved remarkable progress in code\ngeneration. However, existing benchmarks mainly formalize the task as a static,\nsingle-turn problem, overlooking the stepwise requirement changes and iterative\nworkflows in real-world software development. This mismatch limits the\nunderstanding of how well LLMs can support real-world development workflows.\nConstructing such iterative benchmarks is challenging due to the lack of public\ninteraction traces and the difficulty of creating discriminative, turn-specific\ntest cases.\n  To bridge this gap, we present SR-Eval, a benchmark specifically designed to\nassess LLMs on iterative code generation under Stepwise requirements\nRefinement. SR-Eval spans both function-level and repository-level tasks in\nPython and Java, enabling fine-grained and progressive evaluation across\nevolving requirements. The construction of SR-Eval follows a carefully designed\npipeline that first leverages a multi-agent-based requirement generation method\nto simulate the development process and recover the multi-round interaction\nprocess from final requirements, then employs a semantic-aware discriminative\ntest case generation component to ensure discriminative and consistent\nevaluation at each turn. SR-Eval comprises 443 multi-turn tasks and 1,857\nquestions at both function and repository levels. Using SR-Eval, we evaluate 11\nrepresentative LLMs with three prompting strategies that simulate different\nusage patterns. Results show that iterative code generation under stepwise\nrequirement refinement remains highly challenging: the best-performing model\nachieves only 22.67% completion rate on function-level tasks and 20.00% on\nrepository-level tasks. We further observe that prompting strategies\nsubstantially influence performance, highlighting the need for the development\nof advanced methods.", "AI": {"tldr": "SR-Eval is a new benchmark that tests LLMs on multi-turn, evolving code generation tasks, closely mirroring real-world software development. State-of-the-art LLMs perform poorly on these tasks, revealing a gap between current benchmarks and practical requirements, and indicating that both model development and prompting require significant improvement.", "motivation": "Existing code generation benchmarks focus on single-turn, static tasks, not reflecting the iterative and evolving nature of real-world software development. This limits our understanding of how well large language models (LLMs) can support actual development workflows with changing requirements.", "method": "The authors introduce SR-Eval, a new benchmark for evaluating LLMs in iterative code generation scenarios with stepwise requirements refinement. SR-Eval includes both function-level and repository-level tasks in Python and Java and utilizes a multi-agent-based approach to simulate requirement evolution, along with a semantic-aware, discriminative test case generator for consistent evaluation at each step.", "result": "SR-Eval contains 443 multi-turn tasks and 1,857 questions. When tested on 11 LLMs using three different prompting strategies, the best model achieved only 22.67% success on function-level and 20.00% on repository-level tasks, demonstrating that iterative code generation with evolving requirements is still a significant challenge for current LLMs. Prompting strategy also had a noticeable impact on performance.", "conclusion": "The study shows that current LLMs struggle with iterative code generation tasks reflecting real development processes. SR-Eval offers a comprehensive and challenging benchmark for this scenario, and highlights the urgent need for improved LLM methods and better prompting strategies to support real-world, multi-turn software development workflows."}}
{"id": "2509.19136", "categories": ["cs.SE", "cs.AI", "D.2.4; D.2.5; F.3.1"], "pdf": "https://arxiv.org/pdf/2509.19136", "abs": "https://arxiv.org/abs/2509.19136", "authors": ["S\u00e9bastien Salva", "Redha Taguelmimt"], "title": "On the Soundness and Consistency of LLM Agents for Executing Test Cases Written in Natural Language", "comment": null, "summary": "The use of natural language (NL) test cases for validating graphical user\ninterface (GUI) applications is emerging as a promising direction to manually\nwritten executable test scripts, which are costly to develop and difficult to\nmaintain. Recent advances in large language models (LLMs) have opened the\npossibility of the direct execution of NL test cases by LLM agents. This paper\ninvestigates this direction, focusing on the impact on NL test case unsoundness\nand on test case execution consistency. NL test cases are inherently unsound,\nas they may yield false failures due to ambiguous instructions or unpredictable\nagent behaviour. Furthermore, repeated executions of the same NL test case may\nlead to inconsistent outcomes, undermining test reliability. To address these\nchallenges, we propose an algorithm for executing NL test cases with guardrail\nmechanisms and specialised agents that dynamically verify the correct execution\nof each test step. We introduce measures to evaluate the capabilities of LLMs\nin test execution and one measure to quantify execution consistency. We propose\na definition of weak unsoundness to characterise contexts in which NL test case\nexecution remains acceptable, with respect to the industrial quality levels Six\nSigma. Our experimental evaluation with eight publicly available LLMs, ranging\nfrom 3B to 70B parameters, demonstrates both the potential and current\nlimitations of current LLM agents for GUI testing. Our experiments show that\nMeta Llama 3.1 70B demonstrates acceptable capabilities in NL test case\nexecution with high execution consistency (above the level 3-sigma). We provide\nprototype tools, test suites, and results.", "AI": {"tldr": "This paper shows that while using LLMs to execute natural language GUI test cases is promising, ambiguity and inconsistency still pose challenges. With guardrails and specialized agents, top-performing LLMs (like Meta Llama 3.1 70B) can reliably run such tests, but general adoption requires refinement. Tools and experimental data are released.", "motivation": "Manually written executable test scripts for GUI applications are costly and hard to maintain. Using natural language (NL) test cases, executed directly by large language model (LLM) agents, could reduce these burdens, but NL test cases can be ambiguous and unreliable. Therefore, it is crucial to investigate their soundness and consistency.", "method": "The authors propose an algorithm with guardrail mechanisms and specialized agents for verifying each step of NL test case execution. They introduce specific measures to assess LLMs' execution capabilities and consistency, and define 'weak unsoundness' in the context of industrial quality standards (Six Sigma). Experimental evaluation is performed using eight LLMs (3B to 70B parameters) on publicly available test suites.", "result": "The experiments reveal that current LLM agents have both promise and limitations for executing NL test cases in GUI testing. Notably, Meta Llama 3.1 70B achieves high consistency in test execution (above 3-sigma level), suggesting it is suitable for practical use. Prototype tools and result datasets are provided.", "conclusion": "Direct execution of NL test cases with LLM agents is feasible, provided soundness and consistency are adequately addressed. The proposed approach with guardrails and step-by-step validation improves reliability, and some modern LLMs surpass necessary industrial consistency benchmarks. However, further improvements are needed for broader applicability."}}
{"id": "2509.19185", "categories": ["cs.SE", "cs.ET"], "pdf": "https://arxiv.org/pdf/2509.19185", "abs": "https://arxiv.org/abs/2509.19185", "authors": ["Mohammed Mehedi Hasan", "Hao Li", "Emad Fallahzadeh", "Gopi Krishnan Rajbahadur", "Bram Adams", "Ahmed E. Hassan"], "title": "An Empirical Study of Testing Practices in Open Source AI Agent Frameworks and Agentic Applications", "comment": null, "summary": "Foundation model (FM)-based AI agents are rapidly gaining adoption across\ndiverse domains, but their inherent non-determinism and non-reproducibility\npose testing and quality assurance challenges. While recent benchmarks provide\ntask-level evaluations, there is limited understanding of how developers verify\nthe internal correctness of these agents during development.\n  To address this gap, we conduct the first large-scale empirical study of\ntesting practices in the AI agent ecosystem, analyzing 39 open-source agent\nframeworks and 439 agentic applications. We identify ten distinct testing\npatterns and find that novel, agent-specific methods like DeepEval are seldom\nused (around 1%), while traditional patterns like negative and membership\ntesting are widely adapted to manage FM uncertainty. By mapping these patterns\nto canonical architectural components of agent frameworks and agentic\napplications, we uncover a fundamental inversion of testing effort:\ndeterministic components like Resource Artifacts (tools) and Coordination\nArtifacts (workflows) consume over 70% of testing effort, while the FM-based\nPlan Body receives less than 5%. Crucially, this reveals a critical blind spot,\nas the Trigger component (prompts) remains neglected, appearing in around 1% of\nall tests.\n  Our findings offer the first empirical testing baseline in FM-based agent\nframeworks and agentic applications, revealing a rational but incomplete\nadaptation to non-determinism. To address it, framework developers should\nimprove support for novel testing methods, application developers must adopt\nprompt regression testing, and researchers should explore barriers to adoption.\nStrengthening these practices is vital for building more robust and dependable\nAI agents.", "AI": {"tldr": "Empirical study of AI agent testing reveals developers favor traditional methods and neglect FM-specific/prompt testing. Most testing targets deterministic parts, leaving prompts as a blind spot. The paper urges better adoption of modern testing techniques to improve agent reliability.", "motivation": "The paper addresses the rapid adoption of foundation model (FM)-based AI agents and highlights the challenge that their non-determinism and non-reproducibility present for testing and quality assurance. There is a lack of understanding about how developers ensure the internal correctness of these agents during development.", "method": "The authors conducted a large-scale empirical study, analyzing 39 open-source agent frameworks and 439 agentic applications. They identified and classified different testing patterns, mapped these to the architectural components of agent frameworks/applications, and analyzed the distribution of testing efforts.", "result": "The study identified ten testing patterns, found that agent-specific methods like DeepEval are rarely used (~1%), whereas traditional testing patterns are widely adapted. It was discovered that deterministic components consume over 70% of testing effort, while FM-based components receive much less attention. Most notably, prompts (Trigger component) are tested in only ~1% of cases, indicating a critical testing blind spot.", "conclusion": "Current testing practices in FM-based agent frameworks are rational but incomplete, with significant neglect of FM-specific and prompt-testing methods. The authors recommend that framework and application developers, as well as researchers, should enhance support for novel testing methods and prompt regression testing to improve robustness of AI agents."}}

{"id": "2507.21271", "categories": ["cs.SE", "K.6.3"], "pdf": "https://arxiv.org/pdf/2507.21271", "abs": "https://arxiv.org/abs/2507.21271", "authors": ["Zhaorui Yang", "Yuxin Qiu", "Haichao Zhu", "Qian Zhang"], "title": "Generating Highly Structured Test Inputs Leveraging Constraint-Guided Graph Refinement", "comment": "ICSME 2025 Registered Reports", "summary": "[Context] Modern AI applications increasingly process highly structured data,\nsuch as 3D meshes and point clouds, where test input generation must preserve\nboth structural and semantic validity. However, existing fuzzing tools and\ninput generators are typically handcrafted for specific input types and often\ngenerate invalid inputs that are subsequently discarded, leading to\ninefficiency and poor generalizability. [Objective] This study investigates\nwhether test inputs for structured domains can be unified through a graph-based\nrepresentation, enabling general, reusable mutation strategies while enforcing\nstructural constraints. We will evaluate the effectiveness of this approach in\nenhancing input validity and semantic preservation across eight AI systems.\n[Method] We develop and evaluate GRAphRef, a graph-based test input generation\nframework that supports constraint-based mutation and refinement. GRAphRef maps\nstructured inputs to graphs, applies neighbor-similarity-guided mutations, and\nuses a constraint-refinement phase to repair invalid inputs. We will conduct a\nconfirmatory study across eight real-world mesh-processing AI systems,\ncomparing GRAphRef with AFL, MeshAttack, Saffron, and two ablated variants.\nEvaluation metrics include structural validity, semantic preservation (via\nprediction consistency), and performance overhead. Experimental data is derived\nfrom ShapeNetCore mesh seeds and model outputs from systems like MeshCNN and\nHodgeNet. Statistical analysis and component latency breakdowns will be used to\nassess each hypothesis.", "AI": {"tldr": "GRAphRef is a graph-based framework for generating structurally-valid test inputs for AI systems, outperforming traditional methods by being more general and effective.", "motivation": "Modern AI frequently handles highly structured data like 3D meshes, but existing fuzzing/input generation tools are ad-hoc, type-specific, and often inefficient, producing a lot of invalid test cases. There is a need for a more generalized, efficient, and structurally-aware input generation approach.", "method": "The authors develop GRAphRef, a framework mapping structured data to graphs for test input generation. GRAphRef uses neighbor-similarity-guided mutations and a constraint-refinement mechanism to ensure generated inputs preserve structural and semantic validity. It is evaluated on eight real-world mesh-processing AI systems, against AFL, MeshAttack, Saffron, and ablated variants, with metrics including validity, semantic preservation, and overhead.", "result": "GRAphRef increases the structural validity and semantic preservation of generated test inputs compared to alternative methods. The evaluation, using mesh data and outputs from several AI models, shows GRAphRef to be more generalizable and efficient. Statistical and performance breakdowns substantiate these findings.", "conclusion": "A graph-based approach, as realized by GRAphRef, provides a practical, generalized solution for structurally-valid test input generation in AI systems handling complex data types, outperforming specialized and less structurally-aware tools."}}
{"id": "2507.21280", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.21280", "abs": "https://arxiv.org/abs/2507.21280", "authors": ["Courtney Miller", "Rudrajit Choudhuri", "Mara Ulloa", "Sankeerti Haniyur", "Robert DeLine", "Margaret-Anne Storey", "Emerson Murphy-Hill", "Christian Bird", "Jenna L. Butler"], "title": "\"Maybe We Need Some More Examples:\" Individual and Team Drivers of Developer GenAI Tool Use", "comment": null, "summary": "Despite the widespread availability of generative AI tools in software\nengineering, developer adoption remains uneven. This unevenness is problematic\nbecause it hampers productivity efforts, frustrates management's expectations,\nand creates uncertainty around the future roles of developers. Through paired\ninterviews with 54 developers across 27 teams -- one frequent and one\ninfrequent user per team -- we demonstrate that differences in usage result\nprimarily from how developers perceive the tool (as a collaborator vs.\nfeature), their engagement approach (experimental vs. conservative), and how\nthey respond when encountering challenges (with adaptive persistence vs. quick\nabandonment). Our findings imply that widespread organizational expectations\nfor rapid productivity gains without sufficient investment in learning support\ncreates a \"Productivity Pressure Paradox,\" undermining the very productivity\nbenefits that motivate adoption.", "AI": {"tldr": "Developer adoption of generative AI tools varies mainly due to differences in perception, engagement style, and response to difficulties. Pushing for quick productivity improvements without proper learning support can backfire, ultimately decreasing the expected benefits.", "motivation": "Generative AI tools are widely accessible in software engineering, but their adoption by developers is inconsistent. This inconsistency causes issues with productivity, managerial expectations, and uncertainty about developers' roles.", "method": "The study conducted paired interviews with 54 developers (one frequent user and one infrequent user from each of 27 teams) to understand the reasons behind differences in tool usage.", "result": "The study found that adoption differences are driven by how developers perceive the AI tool (collaborator vs. feature), their engagement styles (experimental vs. conservative), and their responses to challenges (persistent vs. quick to give up).", "conclusion": "Expecting rapid productivity gains from generative AI tools without enough investment in learning support leads to the 'Productivity Pressure Paradox,' which reduces the productivity improvements these tools are meant to provide."}}
{"id": "2507.21318", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.21318", "abs": "https://arxiv.org/abs/2507.21318", "authors": ["Yeshayahu Weiss", "Gal Amram", "Achiya Elyasaf", "Eitan Farchi", "Oded Margalit", "Gera Weiss"], "title": "Black-Box Bug-Amplification for Multithreaded Software", "comment": "35 pages, 5 figurs, 4 listing and 3 tables", "summary": "Bugs, especially those in concurrent systems, are often hard to reproduce\nbecause they manifest only under rare conditions. Testers frequently encounter\nfailures that occur only under specific inputs, even when occurring with low\nprobability. We propose an approach to systematically amplify the occurrence of\nsuch elusive bugs. We treat the system under test as a black-box and use\nrepeated trial executions to train a predictive model that estimates the\nprobability of a given input configuration triggering a bug. We evaluate this\napproach on a dataset of 17 representative concurrency bugs spanning diverse\ncategories. Several model-based search techniques are compared against a\nbrute-force random sampling baseline. Our results show that an ensemble of\nregression models can significantly increase bug occurrence rates across nearly\nall scenarios, often achieving an order-of-magnitude improvement over random\nsampling. The contributions of this work include: (i) a novel formulation of\nbug-amplification as a rare-event regression problem; (ii) an empirical\nevaluation of multiple techniques for amplifying bug occurrence, demonstrating\nthe effectiveness of model-guided search; and (iii) a practical, non-invasive\ntesting framework that helps practitioners expose hidden concurrency faults\nwithout altering the internal system architecture.", "AI": {"tldr": "This paper introduces a novel, model-based testing approach to increase the likelihood of reproducing rare concurrency bugs, showing that regression models dramatically outperform random sampling in exposing hidden faults without changing the system's internal architecture.", "motivation": "Bugs in concurrent systems are hard to reproduce because they appear only under rare conditions, posing challenges for testers to consistently expose and diagnose such rare failures.", "method": "The authors treat the system as a black-box, using repeated executions under varied input configurations. They then train a predictive model to estimate the probability of an input configuration triggering a bug. Different model-based search strategies are compared to brute-force random sampling for bug amplification.", "result": "The study demonstrates that ensemble regression models can markedly improve the rate of discovering elusive bugs, outperforming random sampling techniques by orders of magnitude across most evaluated scenarios.", "conclusion": "Model-guided, black-box testing significantly amplifies the manifestation of concurrent bugs and provides practical means for testers to uncover hidden faults, without requiring invasive modifications of the system."}}
{"id": "2507.21317", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.21317", "abs": "https://arxiv.org/abs/2507.21317", "authors": ["Paulette Koronkevich", "William J. Bowman"], "title": "One Weird Trick to Untie Landin's Knot", "comment": null, "summary": "In this work, we explore Landin's Knot, which is understood as a pattern for\nencoding general recursion, including non-termination, that is possible after\nadding higher-order references to an otherwise terminating language. We observe\nthat this isn't always true -- higher-order references, by themselves, don't\nlead to non-termination. The key insight is that Landin's Knot relies not\nprimarily on references storing functions, but on unrestricted quantification\nover a function's environment. We show this through a closure converted\nlanguage, in which the function's environment is made explicit and hides the\ntype of the environment through impredicative quantification. Once references\nare added, this impredicative quantification can be exploited to encode\nrecursion. We conjecture that by restricting the quantification over the\nenvironment, higher-order references can be safely added to terminating\nlanguages, without resorting to more complex type systems such as linearity,\nand without restricting references from storing functions.", "AI": {"tldr": "Adding higher-order references to terminating languages does not, by itself, enable recursion and non-termination. The real culprit is unrestricted quantification over function environments, which, together with references, enables recursion. Restricting this quantification may allow safe use of higher-order references without complex type systems.", "motivation": "The motivation is to understand the conditions under which general recursion, and thus non-termination, can be introduced into otherwise terminating languages by extending them with higher-order references. In particular, the paper investigates whether higher-order references alone are sufficient for this or if additional features are required.", "method": "The authors approach this by examining Landin's Knot, a classic technique for encoding recursion, in the context of a closure-converted language. They analyze the role of impredicative quantification in the environment of functions and demonstrate how this quantification enables recursion when references are present.", "result": "The main result is that higher-order references alone do not always enable non-termination. It is the combination of references and impredicative quantification over function environments that allows for recursion as encoded by Landin's Knot. The authors further conjecture that by restricting environment quantification, it might be possible to safely add higher-order references to terminating languages without more complex type systems or restrictions.", "conclusion": "The study concludes that the risk of introducing general recursion with higher-order references depends critically on the use of unrestricted quantification over environments, not merely on references storing functions. Therefore, controlling quantification might be a more precise and less restrictive way to maintain termination properties in languages extended with higher-order references."}}
{"id": "2507.21329", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.21329", "abs": "https://arxiv.org/abs/2507.21329", "authors": ["Saikat Mondal", "Chanchal K. Roy"], "title": "Does Editing Improve Answer Quality on Stack Overflow? A Data-Driven Investigation", "comment": "Accepted in the 41st International Conference on Software Maintenance\n  and Evolution (ICSME 2025 - Research Track)", "summary": "High-quality answers in technical Q&A platforms like Stack Overflow (SO) are\ncrucial as they directly influence software development practices. Poor-quality\nanswers can introduce inefficiencies, bugs, and security vulnerabilities, and\nthus increase maintenance costs and technical debt in production software. To\nimprove content quality, SO allows collaborative editing, where users revise\nanswers to enhance clarity, correctness, and formatting. Several studies have\nexamined rejected edits and identified the causes of rejection. However, prior\nresearch has not systematically assessed whether accepted edits enhance key\nquality dimensions. While one study investigated the impact of edits on C/C++\nvulnerabilities, broader quality aspects remain unexplored. In this study, we\nanalyze 94,994 Python-related answers that have at least one accepted edit to\ndetermine whether edits improve (1) semantic relevance, (2) code usability, (3)\ncode complexity, (4) security vulnerabilities, (5) code optimization, and (6)\nreadability. Our findings show both positive and negative effects of edits.\nWhile 53.3% of edits improve how well answers match questions, 38.1% make them\nless relevant. Some previously broken code (9%) becomes executable, yet working\ncode (14.7%) turns non-parsable after edits. Many edits increase complexity\n(32.3%), making code harder to maintain. Instead of fixing security issues,\n20.5% of edits introduce additional issues. Even though 51.0% of edits optimize\nperformance, execution time still increases overall. Readability also suffers,\nas 49.7% of edits make code harder to read. This study highlights the\ninconsistencies in editing outcomes and provides insights into how edits impact\nsoftware maintainability, security, and efficiency that might caution users and\nmoderators and help future improvements in collaborative editing systems.", "AI": {"tldr": "Accepted edits on Stack Overflow Python answers do not always improve quality\u2014in many cases, they decrease readability, increase security risks, and break working code, suggesting that collaborative editing needs stricter quality controls.", "motivation": "Technical Q&A platforms like Stack Overflow are vital to software development, but poor-quality answers can create bugs, security issues, and technical debt. While collaborative editing is intended to improve answer quality, it is unclear whether accepted edits truly enhance important quality aspects. Previous studies focused on edit rejection or narrow aspects (like C/C++ vulnerabilities), leaving a gap in comprehensive quality assessment, especially in popular tags like Python.", "method": "The authors systematically analyzed 94,994 Python-related Stack Overflow answers that have at least one accepted edit. They evaluated the impact of edits across six key quality dimensions: semantic relevance, code usability, code complexity, security vulnerabilities, code optimization, and readability.", "result": "Results reveal mixed outcomes from accepted edits: 53.3% of edits improved answer-question relevance, while 38.1% made them less relevant. Edits rendered 9% of previously broken code executable, but broke 14.7% of working code. Edits often increased code complexity (32.3%) and introduced new security issues in 20.5% of cases. Though 51% improved performance, overall execution time increased. Notably, 49.7% of edits reduced code readability.", "conclusion": "Accepted edits do not consistently improve answer quality; instead, they often introduce new issues, negatively affecting maintainability, security, and usability. The study highlights inconsistencies in collaborative editing outcomes and underscores the need for better mechanisms to guide and monitor edits on technical Q&A platforms."}}
{"id": "2507.21439", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.21439", "abs": "https://arxiv.org/abs/2507.21439", "authors": ["Yong Qi Foo", "Brian Sze-Kai Cheong", "Michael D. Adams"], "title": "Fixed-Point-Oriented Programming: A Concise and Elegant Paradigm", "comment": null, "summary": "Fixed-Point-Oriented Programming (FPOP) is an emerging paradigm designed to\nstreamline the implementation of problems involving self-referential\ncomputations. These include graph algorithms, static analysis, parsing, and\ndistributed computing-domains that traditionally require complex and\ntricky-to-implement work-queue algorithms. Existing programming paradigms lack\ndirect support for these inherently fixed-point computations, leading to\ninefficient and error-prone implementations.\n  This white paper explores the potential of the FPOP paradigm, which offers a\nhigh-level abstraction that enables concise and expressive problem\nformulations. By leveraging structured inference rules and user-directed\noptimizations, FPOP allows developers to write declarative specifications while\nthe compiler ensures efficient execution. It not only reduces implementation\ncomplexity for programmers but also enhances adaptability, making it easier for\nprogrammers to explore alternative solutions and optimizations without\nmodifying the core logic of their program.\n  We demonstrate how FPOP simplifies algorithm implementation, improves\nmaintainability, and enables rapid prototyping by allowing problems to be\nclearly and concisely expressed. For example, the graph distance problem can be\nexpressed in only two executable lines of code with FPOP, while it takes an\norder of magnitude more code in other paradigms. By bridging the gap between\ntheoretical fixed-point formulations and practical implementations, we aim to\nfoster further research and adoption of this paradigm.", "AI": {"tldr": "FPOP is a new programming paradigm that makes fixed-point computations easy and concise, reducing code size and complexity, improving maintainability, and enabling rapid prototyping for problems like graph algorithms and static analysis.", "motivation": "Many computational problems, such as graph algorithms and static analysis, involve self-referential fixed-point computations. Traditionally, these require complicated and difficult-to-maintain work-queue approaches due to a lack of native support in existing programming paradigms.", "method": "The authors describe and explore the Fixed-Point-Oriented Programming (FPOP) paradigm. It leverages structured inference rules and user-directed optimizations to let developers specify problems declaratively, while the compiler handles efficient execution.", "result": "FPOP enables concise and expressive problem formulations, drastically reducing implementation complexity and code size. For example, the graph distance problem can be solved with only two lines of executable FPOP code, compared to significantly more in other paradigms. The paradigm improves maintainability, adaptability, and supports rapid prototyping.", "conclusion": "The FPOP paradigm bridges the gap between theoretical fixed-point formulations and practical implementations, streamlining development and fostering further research and adoption through its high-level abstractions."}}
{"id": "2507.21382", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.21382", "abs": "https://arxiv.org/abs/2507.21382", "authors": ["Ruiyin Li", "Yiran Zhang", "Xiyu Zhou", "Peng Liang", "Weisong Sun", "Jifeng Xuan", "Zhi Jin", "Yang Liu"], "title": "MAAD: Automate Software Architecture Design through Knowledge-Driven Multi-Agent Collaboration", "comment": "23 pages, 8 images, 1 table, Manuscript submitted to a journal (2025)", "summary": "Software architecture design is a critical, yet inherently complex and\nknowledge-intensive phase of software development. It requires deep domain\nexpertise, development experience, architectural knowledge, careful trade-offs\namong competing quality attributes, and the ability to adapt to evolving\nrequirements. Traditionally, this process is time-consuming and\nlabor-intensive, and relies heavily on architects, often resulting in limited\ndesign alternatives, especially under the pressures of agile development. While\nLarge Language Model (LLM)-based agents have shown promising performance across\nvarious SE tasks, their application to architecture design remains relatively\nscarce and requires more exploration, particularly in light of diverse domain\nknowledge and complex decision-making. To address the challenges, we proposed\nMAAD (Multi-Agent Architecture Design), an automated framework that employs a\nknowledge-driven Multi-Agent System (MAS) for architecture design. MAAD\norchestrates four specialized agents (i.e., Analyst, Modeler, Designer and\nEvaluator) to collaboratively interpret requirements specifications and produce\narchitectural blueprints enriched with quality attributes-based evaluation\nreports. We then evaluated MAAD through a case study and comparative\nexperiments against MetaGPT, a state-of-the-art MAS baseline. Our results show\nthat MAAD's superiority lies in generating comprehensive architectural\ncomponents and delivering insightful and structured architecture evaluation\nreports. Feedback from industrial architects across 11 requirements\nspecifications further reinforces MAAD's practical usability. We finally\nexplored the performance of the MAAD framework with three LLMs (GPT-4o,\nDeepSeek-R1, and Llama 3.3) and found that GPT-4o exhibits better performance\nin producing architecture design, emphasizing the importance of LLM selection\nin MAS-driven architecture design.", "AI": {"tldr": "MAAD is a multi-agent framework leveraging LLMs to automate and enhance software architecture design; it surpasses a strong baseline and gains industry approval, with GPT-4o providing the best results among tested LLMs.", "motivation": "Software architecture design is critical but complex, requiring deep expertise and often resulting in limited design alternatives under agile development pressures. There is a need to make this process more efficient and to explore how Large Language Model (LLM)-based agents can support architecture design, an area with limited prior research.", "method": "The authors proposed MAAD, a knowledge-driven Multi-Agent Architecture Design framework, where four specialized agents (Analyst, Modeler, Designer, Evaluator) collaborate to analyze requirements and generate architectural blueprints with quality evaluation reports. MAAD was evaluated through case studies, comparative experiments against MetaGPT, and feedback from industrial architects.", "result": "MAAD outperformed MetaGPT by producing more comprehensive architectural components and more structured, insightful evaluation reports. Industrial architects found MAAD practically usable in real scenarios. Additionally, among various LLMs used in MAAD, GPT-4o performed best, highlighting the significance of LLM choice in MAS-driven architecture design.", "conclusion": "MAAD demonstrates the advantages of a multi-agent, LLM-driven approach to automating software architecture design, outperforming existing baselines and receiving positive feedback from practitioners. The framework's effectiveness also depends on selecting powerful LLMs like GPT-4o."}}
{"id": "2507.22048", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.22048", "abs": "https://arxiv.org/abs/2507.22048", "authors": ["Di Wang"], "title": "Composable Effect Handling for Programming LLM-integrated Scripts", "comment": null, "summary": "Implementing LLM-integrated scripts introduces challenges in modularity and\nperformance, as scripts are often coupled to specific LLM implementations and\nfail to exploit parallelization opportunities. This paper proposes using\ncomposable effect handling to separate workflow logic from effectful\noperations, such as LLM calls, I/O, and concurrency, enabling modularity\nwithout sacrificing the opportunity for performance optimization. By treating\nthese operations as abstract interfaces and discharging them via effect\nhandlers, this paper shows that scripts can achieve significant speedups (e.g.,\n10$\\times$ in a Tree-of-Thoughts case study) without compromising modularity.\nThis paper aims to promote composable effect handling as a programming style\nfor LLM scripting.", "AI": {"tldr": "Separating workflow logic from effectful operations via composable effect handling greatly improves both modularity and speed (10x) for LLM-integrated scripts, and is recommended for future scripting practices.", "motivation": "Current LLM-integrated scripts are tightly coupled to specific LLMs and do not effectively use parallelization, leading to challenges in modularity and performance.", "method": "The paper introduces composable effect handling, which separates workflow logic from effectful operations (like LLM calls, I/O, concurrency) using abstract interfaces and effect handlers.", "result": "Scripts using this method can achieve significant speedups (e.g., 10x in a Tree-of-Thoughts case study) while retaining modularity.", "conclusion": "Composable effect handling enables both modular and high-performance LLM scripting and is recommended as a programming style for such applications."}}
{"id": "2507.21447", "categories": ["cs.SE", "cs.ET"], "pdf": "https://arxiv.org/pdf/2507.21447", "abs": "https://arxiv.org/abs/2507.21447", "authors": ["Zachariah Sollenberger", "Rahul Patel", "Saieda Ali Zada", "Sunita Chandrasekaran"], "title": "LLM4VV: Evaluating Cutting-Edge LLMs for Generation and Evaluation of Directive-Based Parallel Programming Model Compiler Tests", "comment": null, "summary": "The usage of Large Language Models (LLMs) for software and test development\nhas continued to increase since LLMs were first introduced, but only recently\nhave the expectations of LLMs become more realistic. Verifying the correctness\nof code generated by LLMs is key to improving their usefulness, but there have\nbeen no comprehensive and fully autonomous solutions developed yet.\nHallucinations are a major concern when LLMs are applied blindly to problems\nwithout taking the time and effort to verify their outputs, and an inability to\nexplain the logical reasoning of LLMs leads to issues with trusting their\nresults. To address these challenges while also aiming to effectively apply\nLLMs, this paper proposes a dual-LLM system (i.e. a generative LLM and a\ndiscriminative LLM) and experiments with the usage of LLMs for the generation\nof a large volume of compiler tests. We experimented with a number of LLMs\npossessing varying parameter counts and presented results using ten\ncarefully-chosen metrics that we describe in detail in our narrative. Through\nour findings, it is evident that LLMs possess the promising potential to\ngenerate quality compiler tests and verify them automatically.", "AI": {"tldr": "This paper proposes and evaluates a dual-LLM framework for generating and automatically verifying compiler tests. By leveraging generative and discriminative LLMs, the authors show that quality, trustworthy compiler test generation is achievable, demonstrating the promising potential of LLMs for reliable software engineering tasks.", "motivation": "The motivation behind this paper is the increasing reliance on Large Language Models (LLMs) for software and test development, and the need to address concerns surrounding the correctness of code generated by LLMs. Issues like hallucinations (incorrect outputs) and lack of logical explainability hinder trust and widespread adoption.", "method": "The paper proposes a dual-LLM system, utilizing both a generative LLM and a discriminative LLM, to generate and verify a large volume of compiler tests. The approach is evaluated using several LLMs with different parameter sizes and assessed across ten carefully-selected metrics.", "result": "The experimental results show that LLMs have significant potential not only to generate quality compiler tests but also to automatically verify them, when used in the proposed dual-LLM framework.", "conclusion": "LLMs, when properly guided and verified using a dual-LLM system, can effectively contribute to the generation and autonomous verification of compiler tests, addressing key challenges such as hallucinations and lack of trust in automated code generation."}}
{"id": "2507.21485", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.21485", "abs": "https://arxiv.org/abs/2507.21485", "authors": ["Jing Wang", "Shang Liu", "Yao Lu", "Zhiyao Xie"], "title": "HLSDebugger: Identification and Correction of Logic Bugs in HLS Code with LLM Solutions", "comment": "This work has been accepted at ICCAD 2025 (International Conference\n  on Computer-Aided Design)", "summary": "High-level synthesis (HLS) accelerates hardware design by enabling the\nautomatic translation of high-level descriptions into efficient hardware\nimplementations. However, debugging HLS code is a challenging and\nlabor-intensive task, especially for novice circuit designers or software\nengineers without sufficient hardware domain knowledge. The recent emergence of\nLarge Language Models (LLMs) is promising in automating the HLS debugging\nprocess. Despite the great potential, three key challenges persist when\napplying LLMs to HLS logic debugging: 1) High-quality circuit data for training\nLLMs is scarce, posing a significant challenge. 2) Debugging logic bugs in\nhardware is inherently more complex than identifying software bugs with\nexisting golden test cases. 3) The absence of reliable test cases requires\nmulti-tasking solutions, performing both bug identification and correction.\ncomplicates the multi-tasking required for effective HLS debugging. In this\nwork, we propose a customized solution named HLSDebugger to address the\nchallenges. HLSDebugger first generates and releases a large labeled dataset\nwith 300K data samples, targeting HLS logic bugs. The HLSDebugger model adopts\nan encoder-decoder structure, performing bug location identification, bug type\nprediction, and bug correction with the same model. HLSDebugger significantly\noutperforms advanced LLMs like GPT-4 in bug identification and by more than 3x\nin bug correction. It makes a substantial advancement in the exploration of\nautomated debugging of HLS code.", "AI": {"tldr": "HLSDebugger is a new automated tool that uses a large dataset and an encoder-decoder model to identify and correct HLS code bugs more effectively than existing large language models like GPT-4.", "motivation": "Debugging HLS code is time-consuming and difficult, particularly for individuals without deep hardware expertise. The complexity of hardware bugs and lack of training data exacerbate the difficulty, while recent advancements in large language models (LLMs) present an opportunity to automate and improve the HLS debugging process.", "method": "The authors present HLSDebugger, a customized model based on an encoder-decoder architecture designed to automate HLS logic debugging. HLSDebugger is trained on a newly created dataset of 300,000 labeled HLS bug samples. The model is designed to simultaneously perform bug location identification, bug type prediction, and bug correction.", "result": "HLSDebugger outperforms advanced LLMs like GPT-4 in HLS bug identification and achieves over 3x improvement in bug correction performance. The tool demonstrates significant advances in automated debugging capabilities for HLS code.", "conclusion": "HLSDebugger introduces a specialized approach to automated debugging for HLS, leveraging a large, labeled dataset and a multitasking model structure. It significantly advances the field by providing superior bug identification and correction compared to state-of-the-art general-purpose LLMs."}}
{"id": "2507.21583", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.21583", "abs": "https://arxiv.org/abs/2507.21583", "authors": ["Sergio Cobos", "Javier Luis C\u00e1novas Izquierdo"], "title": "Ethical Classification of Non-Coding Contributions in Open-Source Projects via Large Language Models", "comment": "Accepted at the 2025 8th AAAI/ACM Conference on AI, Ethics, and\n  Society (AIES'25)", "summary": "The development of Open-Source Software (OSS) is not only a technical\nchallenge, but also a social one due to the diverse mixture of contributors. To\nthis aim, social-coding platforms, such as GitHub, provide the infrastructure\nneeded to host and develop the code, but also the support for enabling the\ncommunity's collaboration, which is driven by non-coding contributions, such as\nissues (i.e., change proposals or bug reports) or comments to existing\ncontributions. As with any other social endeavor, this development process\nfaces ethical challenges, which may put at risk the project's sustainability.\nTo foster a productive and positive environment, OSS projects are increasingly\ndeploying codes of conduct, which define rules to ensure a respectful and\ninclusive participatory environment, with the Contributor Covenant being the\nmain model to follow. However, monitoring and enforcing these codes of conduct\nis a challenging task, due to the limitations of current approaches. In this\npaper, we propose an approach to classify the ethical quality of non-coding\ncontributions in OSS projects by relying on Large Language Models (LLM), a\npromising technology for text classification tasks. We defined a set of ethical\nmetrics based on the Contributor Covenant and developed a classification\napproach to assess ethical behavior in OSS non-coding contributions, using\nprompt engineering to guide the model's output.", "AI": {"tldr": "The paper introduces an LLM-based framework using the Contributor Covenant for ethically evaluating OSS project interactions, aiming to automate and improve community code of conduct enforcement.", "motivation": "Open Source Software development faces not only technical challenges but also social and ethical ones due to the diverse backgrounds of contributors and the importance of fostering a collaborative, respectful environment. Existing approaches for monitoring and enforcing ethical participation via codes of conduct are limited and difficult to scale.", "method": "The authors propose using Large Language Models (LLMs) for classifying the ethical quality of non-coding contributions, such as issues and comments, in OSS projects. They developed ethical metrics based on the Contributor Covenant and used prompt engineering to tailor LLM outputs for this classification task.", "result": "A classification approach leveraging LLMs was developed to assess ethical behavior in OSS non-coding contributions. The approach evaluates these interactions based on a set of predefined ethical metrics inspired by the Contributor Covenant.", "conclusion": "LLMs can be effectively guided through prompt engineering and tailored metrics to classify and assess the ethical quality of non-coding contributions in OSS projects, offering a scalable and automated solution to support positive community behavior."}}
{"id": "2507.21678", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.21678", "abs": "https://arxiv.org/abs/2507.21678", "authors": ["Yiming Xu", "Runzhi He", "Hengzhi Ye", "Minghui Zhou", "Huaimin Wang"], "title": "Predicting Maintenance Cessation of Open Source Software Repositories with An Integrated Feature Framework", "comment": null, "summary": "The maintenance risks of open source software (OSS) projects pose significant\nthreats to the quality, security, and resilience of modern software supply\nchains. While prior research has proposed diverse approaches for predicting OSS\nmaintenance risk -- leveraging signals ranging from surface features (e.g.,\nstars, commits) to social network analyses and behavioral patterns -- existing\nmethods often suffer from ambiguous operational definitions, limited\ninterpretability, and datasets of insufficient scale or generalizability. In\nthis work, we introduce ``maintenance cessation'', grounded in both explicit\narchival status and rigorous semantic analysis of project documentation.\nBuilding on this foundation, we curate a large-scale, longitudinal dataset of\n115,466 GitHub repositories -- encompassing 57,733 confirmed cessation events\n-- complemented by comprehensive, timeline-based behavioral features. We\npropose an integrated, multi-perspective feature framework for predicting\nmaintenance cessation, systematically combining user-centric features,\nmaintainer-centric features and project evolution features. AFT survival\nanalysis demonstrates a high C-index (0.846), substantially outperforming\nmodels relying only on surface features. Feature ablation and SHAP analysis\nfurther confirm the effectiveness and interpretability of our approach.\nFinally, we demonstrate real-world applicability by deploying a GBSA classifier\nin the openEuler ecosystem for proactive package risk screening. Our work\nestablishes a scalable, interpretable foundation for maintenance-risk\nprediction, enabling reproducible risk management across large-scale open\nsource ecosystems.", "AI": {"tldr": "The authors present a new, interpretable approach for predicting when OSS projects will stop being maintained, using advanced features and a large GitHub dataset. Their model outperforms previous methods and has been validated in real-world ecosystem risk screening.", "motivation": "Open source software (OSS) projects face significant maintenance risks, threatening software supply chains, yet current prediction methods for these risks are often ambiguous, hard to interpret, or not generalizable.", "method": "The paper introduces the concept of 'maintenance cessation,' linking explicit archival status with semantic analysis of documentation. A large longitudinal GitHub dataset (115,466 repositories) is analyzed. An integrated framework using user-, maintainer-, and project evolution-centric features is developed. AFT survival analysis and SHAP are used to evaluate prediction models, and a GBSA classifier is deployed in the openEuler ecosystem.", "result": "Their model achieves a high C-index (0.846), significantly outperforming models based only on surface features. Feature ablation and SHAP confirm both effectiveness and interpretability. The framework is shown to be effective in a real-world OSS risk screening application.", "conclusion": "The work provides a scalable and interpretable method for predicting maintenance cessation (risk) in OSS, establishing a reproducible foundation for large-scale risk management."}}
{"id": "2507.21693", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.21693", "abs": "https://arxiv.org/abs/2507.21693", "authors": ["Basak Demirok", "Mucahid Kutlu", "Selin Mergen"], "title": "MultiAIGCD: A Comprehensive dataset for AI Generated Code Detection Covering Multiple Languages, Models,Prompts, and Scenarios", "comment": null, "summary": "As large language models (LLMs) rapidly advance, their role in code\ngeneration has expanded significantly. While this offers streamlined\ndevelopment, it also creates concerns in areas like education and job\ninterviews. Consequently, developing robust systems to detect AI-generated code\nis imperative to maintain academic integrity and ensure fairness in hiring\nprocesses. In this study, we introduce MultiAIGCD, a dataset for AI-generated\ncode detection for Python, Java, and Go. From the CodeNet dataset's problem\ndefinitions and human-authored codes, we generate several code samples in Java,\nPython, and Go with six different LLMs and three different prompts. This\ngeneration process covered three key usage scenarios: (i) generating code from\nproblem descriptions, (ii) fixing runtime errors in human-written code, and\n(iii) correcting incorrect outputs. Overall, MultiAIGCD consists of 121,271\nAI-generated and 32,148 human-written code snippets. We also benchmark three\nstate-of-the-art AI-generated code detection models and assess their\nperformance in various test scenarios such as cross-model and cross-language.\nWe share our dataset and codes to support research in this field.", "AI": {"tldr": "The paper introduces MultiAIGCD, a major new dataset for detecting AI-generated code in Python, Java, and Go, featuring various generation scenarios. The authors benchmark leading detection models and release their resources to advance research in this increasingly critical field.", "motivation": "As large language models (LLMs) increasingly generate useful code, legitimate concerns have arisen regarding their impact on education and job recruitment, with the need for reliable detection systems to ensure fairness and academic integrity.", "method": "The authors created MultiAIGCD, a large dataset for AI-generated code detection in Python, Java, and Go, using CodeNet problem definitions, human-authored codes, and code samples generated from six LLMs with three prompts under various scenarios. They benchmarked three detection models on this dataset across tasks, including cross-model and cross-language testing.", "result": "They produced a dataset of over 121,000 AI-generated and 32,000 human-written code snippets, and evaluated the detection ability of state-of-the-art systems in multiple scenarios. The dataset and code are publicly shared for further research.", "conclusion": "MultiAIGCD is a valuable new resource that enables systematic evaluation of AI-generated code detection methods, facilitating advances in maintaining academic and professional integrity as code generation by LLMs grows."}}
{"id": "2507.21928", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2507.21928", "abs": "https://arxiv.org/abs/2507.21928", "authors": ["Christian Meske", "Tobias Hermanns", "Esther von der Weiden", "Kai-Uwe Loser", "Thorsten Berger"], "title": "Vibe Coding as a Reconfiguration of Intent Mediation in Software Development: Definition, Implications, and Research Agenda", "comment": null, "summary": "Software development is undergoing a fundamental transformation as vibe\ncoding becomes widespread, with large portions of contemporary codebases now\nbeing AI-generated. The disconnect between rapid adoption and limited\nconceptual understanding highlights the need for an inquiry into this emerging\nparadigm. Drawing on an intent perspective and historical analysis, we define\nvibe coding as a software development paradigm where humans and generative AI\nengage in collaborative flow to co-create software artifacts through natural\nlanguage dialogue, shifting the mediation of developer intent from\ndeterministic instruction to probabilistic inference. By intent mediation, we\nrefer to the fundamental process through which developers translate their\nconceptual goals into representations that computational systems can execute.\nOur results show that vibe coding reconfigures cognitive work by redistributing\nepistemic labor between humans and machines, shifting the expertise in the\nsoftware development process away from traditional areas such as design or\ntechnical implementation toward collaborative orchestration. We identify key\nopportunities, including democratization, acceleration, and systemic leverage,\nalongside risks, such as black box codebases, responsibility gaps, and\necosystem bias. We conclude with a research agenda spanning human-,\ntechnology-, and organization-centered directions to guide future\ninvestigations of this paradigm.", "AI": {"tldr": "Vibe coding, where humans and AI co-create software using natural language, is rapidly changing software development. It shifts expertise and responsibilities, introduces both new opportunities and risks, and calls for a comprehensive research agenda to understand its implications.", "motivation": "The paper is motivated by the rapid adoption of AI-generated code (vibe coding) in software development, despite limited understanding of its conceptual impact. There is a growing gap between the use of generative AI tools in coding and our theoretical grasp of their influence on software engineering.", "method": "The authors use an intent perspective and historical analysis to define and investigate vibe coding. They examine how the mediation of developer intent is altered by collaborative flow between humans and generative AI, and assess how cognitive work and expertise distribution shift in this new paradigm.", "result": "Vibe coding shifts epistemic labor from humans to machines and redistributes expertise from traditional domains like design and technical skills toward collaborative orchestration of AI-human interaction. Key opportunities identified are democratization, acceleration, and systemic leverage, while key risks include black box codebases, responsibility gaps, and bias. The paper offers a research agenda for future study.", "conclusion": "Vibe coding fundamentally transforms software development by enabling collaborative creation between humans and AI, which requires a rethinking of intent mediation, expertise, opportunities, risks, and research needs across human, technological, and organizational domains."}}
{"id": "2507.21952", "categories": ["cs.SE", "cs.LG"], "pdf": "https://arxiv.org/pdf/2507.21952", "abs": "https://arxiv.org/abs/2507.21952", "authors": ["Peihong Lin", "Pengfei Wang", "Xu Zhou", "Wei Xie", "Gen Zhang", "Kai Lu"], "title": "DeepGo: Predictive Directed Greybox Fuzzing", "comment": null, "summary": "The state-of-the-art DGF techniques redefine and optimize the fitness metric\nto reach the target sites precisely and quickly. However, optimizations for\nfitness metrics are mainly based on heuristic algorithms, which usually rely on\nhistorical execution information and lack foresight on paths that have not been\nexercised yet. Thus, those hard-to-execute paths with complex constraints would\nhinder DGF from reaching the targets, making DGF less efficient. In this paper,\nwe propose DeepGo, a predictive directed grey-box fuzzer that can combine\nhistorical and predicted information to steer DGF to reach the target site via\nan optimal path. We first propose the path transition model, which models DGF\nas a process of reaching the target site through specific path transition\nsequences. The new seed generated by mutation would cause the path transition,\nand the path corresponding to the high-reward path transition sequence\nindicates a high likelihood of reaching the target site through it. Then, to\npredict the path transitions and the corresponding rewards, we use deep neural\nnetworks to construct a Virtual Ensemble Environment (VEE), which gradually\nimitates the path transition model and predicts the rewards of path transitions\nthat have not been taken yet. To determine the optimal path, we develop a\nReinforcement Learning for Fuzzing (RLF) model to generate the transition\nsequences with the highest sequence rewards. The RLF model can combine\nhistorical and predicted path transitions to generate the optimal path\ntransition sequences, along with the policy to guide the mutation strategy of\nfuzzing. Finally, to exercise the high-reward path transition sequence, we\npropose the concept of an action group, which comprehensively optimizes the\ncritical steps of fuzzing to realize the optimal path to reach the target\nefficiently.", "AI": {"tldr": "DeepGo is a novel fuzzer that uses reinforcement learning and deep learning to predict and guide optimal paths to complex software targets, surpassing traditional fuzzing methods that rely only on past execution data.", "motivation": "Current Directed Grey-box Fuzzing (DGF) techniques optimize the fitness metric using heuristic algorithms. These heuristics often rely only on historical execution paths, lacking the ability to efficiently anticipate or explore paths that have not yet been executed, especially those with complex constraints. This limits the efficiency of DGF in reaching hard-to-execute target sites.", "method": "The authors introduce DeepGo, a predictive DGF that integrates both historical and predicted information using machine learning. They propose a path transition model to frame DGF as navigating through path transition sequences toward a target. A deep neural network-based Virtual Ensemble Environment (VEE) is used to imitate and predict rewards for both tried and untried path transitions. Reinforcement Learning for Fuzzing (RLF) is developed to generate optimal path transition sequences, combining past and forecast transitions and guiding mutation strategies using a policy. The concept of an action group is also proposed to optimize these mutation strategies for higher efficiency.", "result": "DeepGo can identify and exercise optimal paths to reach complex target sites more efficiently by leveraging both predicted and historical path transition information. The approach comprehensively improves DGF by predicting high-reward (effective) transitions, determining the best mutation strategies, and optimizing the overall fuzzing process.", "conclusion": "Combining reinforcement learning and deep neural networks with DGF provides a significant advancement in guiding fuzzers toward complex targets. By modeling path transitions and their rewards, DeepGo overcomes the deficiencies of heuristic-only approaches, making fuzzing more effective at reaching hard-to-execute paths."}}
{"id": "2507.21954", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.21954", "abs": "https://arxiv.org/abs/2507.21954", "authors": ["Zengyang Li", "Yimeng Li", "Binbin Huang", "Peng Liang", "Ran Mo", "Hui Liu", "Yutao Ma"], "title": "Fine-Tuning Code Language Models to Detect Cross-Language Bugs", "comment": "33 pages, 6 images, 9 tables, Manuscript submitted to a journal\n  (2025)", "summary": "Multilingual programming, which involves using multiple programming languages\n(PLs) in a single project, is increasingly common due to its benefits. However,\nit introduces cross-language bugs (CLBs), which arise from interactions between\ndifferent PLs and are difficult to detect by single-language bug detection\ntools. This paper investigates the potential of pre-trained code language\nmodels (CodeLMs) in CLB detection. We developed CLCFinder, a cross-language\ncode identification tool, and constructed a CLB dataset involving three PL\ncombinations (Python-C/C++, Java-C/C++, and Python-Java) with nine interaction\ntypes. We fine-tuned 13 CodeLMs on this dataset and evaluated their\nperformance, analyzing the effects of dataset size, token sequence length, and\ncode comments. Results show that all CodeLMs performed poorly before\nfine-tuning, but exhibited varying degrees of performance improvement after\nfine-tuning, with UniXcoder-base achieving the best F1 score (0.7407). Notably,\nsmall fine-tuned CodeLMs tended to performe better than large ones. CodeLMs\nfine-tuned on single-language bug datasets performed poorly on CLB detection,\ndemonstrating the distinction between CLBs and single-language bugs.\nAdditionally, increasing the fine-tuning dataset size significantly improved\nperformance, while longer token sequences did not necessarily improve the model\nperformance. The impact of code comments varied across models. Some fine-tuned\nCodeLMs' performance was improved, while others showed degraded performance.", "AI": {"tldr": "Detecting cross-language bugs in multilingual programming projects requires fine-tuning code models on specific datasets, as single-language bug detection methods are ineffective. Model size, dataset size, and code comments all impact performance.", "motivation": "Multilingual programming is increasingly prevalent because of its benefits, but it introduces cross-language bugs (CLBs) that are hard to detect with standard single-language bug detection tools.", "method": "The authors developed CLCFinder, a cross-language bug identification tool, and built a CLB dataset across three programming language combinations with nine interaction types. They fine-tuned 13 pre-trained code language models (CodeLMs) on this dataset and evaluated their CLB detection ability, examining the effects of dataset size, token sequence length, and code comments.", "result": "Pre-trained CodeLMs performed poorly on CLB detection before fine-tuning, but improved after fine-tuning, with UniXcoder-base achieving the best F1 score (0.7407). Smaller fine-tuned models generally outperformed larger ones. Models fine-tuned on single-language bug datasets were ineffective for CLB detection. Larger fine-tuning datasets significantly improved performance, but longer code token sequences did not always help. Code comments had mixed effects, sometimes improving and sometimes degrading performance.", "conclusion": "Fine-tuning code language models on targeted CLB datasets is essential for effective cross-language bug detection. Single-language bug detection models do not generalize to CLBs. Model size, dataset size, code token sequence length, and code comments all influence detection performance in nuanced ways."}}

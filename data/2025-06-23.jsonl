{"id": "2506.15884", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.15884", "abs": "https://arxiv.org/abs/2506.15884", "authors": ["Shamse Tasnim Cynthia", "Nuri Almarimi", "Banani Roy"], "title": "How Do Community Smells Influence Self-Admitted Technical Debt in Machine Learning Projects?", "comment": null, "summary": "Community smells reflect poor organizational practices that often lead to\nsocio-technical issues and the accumulation of Self-Admitted Technical Debt\n(SATD). While prior studies have explored these problems in general software\nsystems, their interplay in machine learning (ML)-based projects remains\nlargely underexamined. In this study, we investigated the prevalence of\ncommunity smells and their relationship with SATD in open-source ML projects,\nanalyzing data at the release level. First, we examined the prevalence of ten\ncommunity smell types across the releases of 155 ML-based systems and found\nthat community smells are widespread, exhibiting distinct distribution patterns\nacross small, medium, and large projects. Second, we detected SATD at the\nrelease level and applied statistical analysis to examine its correlation with\ncommunity smells. Our results showed that certain smells, such as Radio Silence\nand Organizational Silos, are strongly correlated with higher SATD occurrences.\nThird, we considered the six identified types of SATD to determine which\ncommunity smells are most associated with each debt category. Our analysis\nrevealed authority- and communication-related smells often co-occur with\npersistent code and design debt. Finally, we analyzed how the community smells\nand SATD evolve over the releases, uncovering project size-dependent trends and\nshared trajectories. Our findings emphasize the importance of early detection\nand mitigation of socio-technical issues to maintain the long-term quality and\nsustainability of ML-based systems."}
{"id": "2506.16101", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16101", "abs": "https://arxiv.org/abs/2506.16101", "authors": ["Yupeng Jiang", "Shuaiyi Sun", "Xi Zheng"], "title": "Regression Testing Optimization for ROS-based Autonomous Systems: A Comprehensive Review of Techniques", "comment": null, "summary": "Regression testing plays a critical role in maintaining software reliability,\nparticularly for ROS-based autonomous systems (ROSAS), which frequently undergo\ncontinuous integration and iterative development. However, conventional\nregression testing techniques face significant challenges when applied to\nautonomous systems due to their dynamic and non-deterministic behaviors,\ncomplex multi-modal sensor data, asynchronous distributed architectures, and\nstringent safety and real-time constraints. Although numerous studies have\nexplored test optimization in traditional software contexts, regression testing\noptimization specifically for ROSAS remains largely unexplored. To address this\ngap, we present the first comprehensive survey systematically reviewing\nregression testing optimization techniques tailored for ROSAS. We analyze and\ncategorize 122 representative studies into regression test case prioritization,\nminimization, and selection methods. A structured taxonomy is introduced to\nclearly illustrate their applicability and limitations within ROSAS contexts.\nFurthermore, we highlight major challenges specific to regression testing for\nROSAS, including effectively prioritizing tests in response to frequent system\nmodifications, efficiently minimizing redundant tests, and difficulty in\naccurately selecting impacted test cases. Finally, we propose research insights\nand identify promising future directions, such as leveraging frame-to-vector\ncoverage metrics, multi-source foundation models, and neurosymbolic reasoning\nto enhance regression testing efficiency and effectiveness. This survey\nprovides a foundational reference and practical roadmap for advancing the\nstate-of-the-art in regression testing optimization for ROSAS."}
{"id": "2506.16136", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16136", "abs": "https://arxiv.org/abs/2506.16136", "authors": ["Kai Huang", "Jian Zhang", "Xiaofei Xie", "Chunyang Chen"], "title": "Seeing is Fixing: Cross-Modal Reasoning with Multimodal LLMs for Visual Software Issue Fixing", "comment": null, "summary": "Large language model-(LLM) based automated program repair (APR) techniques\nhave shown promising results in resolving real-world GitHub issue tasks.\nExisting APR systems are primarily evaluated in unimodal settings (e.g.,\nSWE-bench). However, these autonomous systems struggle to resolve multimodal\nproblem scenarios (e.g., SWE-bench M) due to limitations in interpreting and\nleveraging visual information. In multimodal scenarios, LLMs need to rely on\nvisual information in the graphical user interface (GUI) to understand bugs and\ngenerate fixes. To bridge this gap, we propose GUIRepair, a cross-modal\nreasoning approach for resolving multimodal issue scenarios by understanding\nand capturing visual information. Specifically, GUIRepair integrates two key\ncomponents, Image2Code and Code2Image, to enhance fault comprehension and patch\nvalidation. Image2Code extracts relevant project documents based on the issue\nreport, then applies this domain knowledge to generate the reproduced code\nresponsible for the visual symptoms, effectively translating GUI images into\nexecutable context for better fault comprehension. Code2Image replays the\nvisual issue scenario using the reproduced code and captures GUI renderings of\nthe patched program to assess whether the fix visually resolves the issue,\nproviding feedback for patch validation. We evaluate GUIRepair on SWE-bench M,\nand the approach demonstrates significant effectiveness. When utilizing GPT-4o\nas the base model, GUIRepair solves 157 instances, outperforming the best\nopen-source baseline by 26 instances. Furthermore, when using o4-mini as the\nbase model, GUIRepair can achieve even better results and solve 175 instances,\noutperforming the top commercial system by 22 instances. This emphasizes the\nsuccess of our new perspective on incorporating cross-modal reasoning by\nunderstanding and capturing visual information to resolve multimodal issues."}
{"id": "2506.16214", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16214", "abs": "https://arxiv.org/abs/2506.16214", "authors": ["Klara Borowa", "Andrzej Ratkowski", "Roberto Verdecchia"], "title": "The Technical Debt Gamble: A Case Study on Technical Debt in a Large-Scale Industrial Microservice Architecture", "comment": "Preprint accepted to Journal of Systems and Software", "summary": "Microservice architectures provide an intuitive promise of high\nmaintainability and evolvability due to loose coupling. However, these quality\nattributes are notably vulnerable to technical debt (TD). Few studies address\nTD in microservice systems, particularly on a large scale. This research\nexplores how TD manifests in a large-scale microservice-based industrial\nsystem. The research is based on a mixed-method case study of a project\nincluding over 100 microservices and serving over 15k locations. Results are\ncollected via a quantitative method based static code analyzers combined with\nqualitative insights derived from a focus group discussion with the development\nteam and a follow-up interview with the lead architect of the case study\nsystem. Results show that (1) simple static source code analysis can be an\nefficient and effective entry point for holistic TD discovery, (2) inadequate\ncommunication significantly contributes to TD, (3) misalignment between\narchitectural and organizational structures can exacerbate TD accumulation, (4)\nmicroservices can rapidly cycle through TD accumulation and resolution, a\nphenomenon referred to as \"microservice architecture technical debt gamble\".\nFinally, we identify a set of fitting strategies for TD management in\nmicroservice architectures."}
{"id": "2506.15875", "categories": ["cs.PL", "cs.AR", "cs.DC", "cs.ET", "D.3; D.1; I.6; J.2"], "pdf": "https://arxiv.org/pdf/2506.15875", "abs": "https://arxiv.org/abs/2506.15875", "authors": ["Dirk Van Essendelft", "Patrick Wingo", "Terry Jordan", "Ryan Smith", "Wissam Saidi"], "title": "A System Level Compiler for Massively-Parallel, Spatial, Dataflow Architectures", "comment": "26 pages, 5 figures, 14 listings", "summary": "We have developed a novel compiler called the Multiple-Architecture Compiler\nfor Advanced Computing Hardware (MACH) designed specifically for\nmassively-parallel, spatial, dataflow architectures like the Wafer Scale\nEngine. Additionally, MACH can execute code on traditional unified-memory\ndevices. MACH addresses the complexities in compiling for spatial architectures\nthrough a conceptual Virtual Machine, a flexible domain-specific language, and\na compiler that can lower high-level languages to machine-specific code in\ncompliance with the Virtual Machine concept. While MACH is designed to be\noperable on several architectures and provide the flexibility for several\nstandard and user-defined data mappings, we introduce the concept with dense\ntensor examples from NumPy and show lowering to the Wafer Scale Engine by\ntargeting Cerebras' hardware specific languages."}
{"id": "2506.16440", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16440", "abs": "https://arxiv.org/abs/2506.16440", "authors": ["Ebube Alor", "SayedHassan Khatoonabadi", "Emad Shihab"], "title": "Evaluating the Use of LLMs for Documentation to Code Traceability", "comment": null, "summary": "Large Language Models (LLMs) offer new potential for automating\ndocumentation-to-code traceability, yet their capabilities remain\nunderexplored. We present a comprehensive evaluation of LLMs (Claude 3.5\nSonnet, GPT-4o, and o3-mini) in establishing trace links between various\nsoftware documentation (including API references and user guides) and source\ncode. We create two novel datasets from two open-source projects (Unity Catalog\nand Crawl4AI). Through systematic experiments, we assess three key\ncapabilities: (1) trace link identification accuracy, (2) relationship\nexplanation quality, and (3) multi-step chain reconstruction. Results show that\nthe best-performing LLM achieves F1-scores of 79.4% and 80.4% across the two\ndatasets, substantially outperforming our baselines (TF-IDF, BM25, and\nCodeBERT). While fully correct relationship explanations range from 42.9% to\n71.1%, partial accuracy exceeds 97%, indicating that fundamental connections\nare rarely missed. For multi-step chains, LLMs maintain high endpoint accuracy\nbut vary in capturing precise intermediate links. Error analysis reveals that\nmany false positives stem from naming-based assumptions, phantom links, or\novergeneralization of architectural patterns. We demonstrate that task-framing,\nsuch as a one-to-many matching strategy, is critical for performance. These\nfindings position LLMs as powerful assistants for trace discovery, but their\nlimitations could necessitate human-in-the-loop tool design and highlight\nspecific error patterns for future research."}
{"id": "2506.16048", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2506.16048", "abs": "https://arxiv.org/abs/2506.16048", "authors": ["Byeongjee Kang", "Harsh Desai", "Limin Jia", "Brandon Lucia"], "title": "WAMI: Compilation to WebAssembly through MLIR without Losing Abstraction", "comment": null, "summary": "WebAssembly (Wasm) is a portable bytecode format that serves as a compilation\ntarget for high-level languages, enabling their secure and efficient execution\nacross diverse platforms, including web browsers and embedded systems. To\nimprove support for high-level languages without incurring significant code\nsize or performance overheads, Wasm continuously evolves by integrating\nhigh-level features such as Garbage Collection and Stack Switching. However,\nexisting compilation approaches either lack reusable design -- requiring\nredundant implementation efforts for each language -- or lose abstraction by\nlowering high-level constructs into low-level shared representations like LLVM\nIR, which hinder the adoption of high-level features. MLIR compiler\ninfrastructure provides the compilation pipeline with multiple levels of\nabstraction, preserving high-level abstractions throughout the compilation\npipeline, yet the current MLIR pipeline relies on the LLVM backend for Wasm\ncode generation, thereby inheriting LLVM's limitations.\n  This paper presents a novel compilation pipeline for Wasm, featuring Wasm\ndialects explicitly designed to represent high-level Wasm constructs within\nMLIR. Our approach enables direct generation of high-level Wasm code from\ncorresponding high-level MLIR dialects without losing abstraction, providing a\nmodular and extensible way to incorporate high-level Wasm features. We\nillustrate this extensibility through a case study that leverages Stack\nSwitching, a recently introduced high-level feature of Wasm. Performance\nevaluations on PolyBench benchmarks show that our pipeline, benefiting from\noptimizations within the MLIR and Wasm ecosystems, produces code with at most\n7.7\\% slower, and faster in some execution environments, compared to LLVM-based\ncompilers."}
{"id": "2506.16453", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16453", "abs": "https://arxiv.org/abs/2506.16453", "authors": ["Buthayna AlMulla", "Maram Assi", "Safwat Hassan"], "title": "Understanding the Challenges and Promises of Developing Generative AI Apps: An Empirical Study", "comment": "45 pages, 24 figures, 7 tables", "summary": "The release of ChatGPT in 2022 triggered a rapid surge in generative\nartificial intelligence mobile apps (i.e., Gen-AI apps). Despite widespread\nadoption, little is known about how end users perceive and evaluate these\nGen-AI functionalities in practice. In this work, we conduct a user-centered\nanalysis of 676,066 reviews from 173 Gen-AI apps on the Google Play Store. We\nintroduce a four-phase methodology, SARA (Selection, Acquisition, Refinement,\nand Analysis), that enables the systematic extraction of user insights using\nprompt-based LLM techniques. First, we demonstrate the reliability of LLMs in\ntopic extraction, achieving 91% accuracy through five-shot prompting and\nnon-informative review filtering. Then, we apply this method to the informative\nreviews, identify the top 10 user-discussed topics (e.g., AI Performance,\nContent Quality, and Content Policy & Censorship) and analyze the key\nchallenges and emerging opportunities. Finally, we examine how these topics\nevolve over time, offering insight into shifting user expectations and\nengagement patterns with Gen-AI apps. Based on our findings and observations,\nwe present actionable implications for developers and researchers."}
{"id": "2506.16883", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2506.16883", "abs": "https://arxiv.org/abs/2506.16883", "authors": ["Christoph Jung", "C. F. Bolz-Tereick"], "title": "Low Overhead Allocation Sampling in a Garbage Collected Virtual Machine", "comment": null, "summary": "Compared to the more commonly used time-based profiling, allocation profiling\nprovides an alternate view of the execution of allocation heavy dynamically\ntyped languages. However, profiling every single allocation in a program is\nvery inefficient. We present a sampling allocation profiler that is deeply\nintegrated into the garbage collector of PyPy, a Python virtual machine. This\nintegration ensures tunable low overhead for the allocation profiler, which we\nmeasure and quantify. Enabling allocation sampling profiling with a sampling\nperiod of 4 MB leads to a maximum time overhead of 25% in our benchmarks, over\nun-profiled regular execution."}
{"id": "2506.16557", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16557", "abs": "https://arxiv.org/abs/2506.16557", "authors": ["Hernán Gagliardi", "Victor Braberman", "Sebastian Uchitel"], "title": "Scaling GR(1) Synthesis via a Compositional Framework for LTL Discrete Event Control", "comment": "To be published in CAV25", "summary": "We present a compositional approach to controller synthesis of discrete event\nsystem controllers with linear temporal logic (LTL) goals. We exploit the\nmodular structure of the plant to be controlled, given as a set of labelled\ntransition systems (LTS), to mitigate state explosion that monolithic\napproaches to synthesis are prone to. Maximally permissive safe controllers are\niteratively built for subsets of the plant LTSs by solving weaker control\nproblems. Observational synthesis equivalence is used to reduce the size of the\ncontrolled subset of the plant by abstracting away local events. The result of\nsynthesis is also compositional, a set of controllers that when run in parallel\nensure the LTL goal. We implement synthesis in the MTSA tool for an expressive\nsubset of LTL, GR(1), and show it computes solutions to that can be up to 1000\ntimes larger than those that the monolithic approach can solve."}
{"id": "2506.16586", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2506.16586", "abs": "https://arxiv.org/abs/2506.16586", "authors": ["Ihor Pysmennyi", "Roman Kyslyi", "Kyrylo Kleshch"], "title": "AI-Driven Tools in Modern Software Quality Assurance: An Assessment of Benefits, Challenges, and Future Directions", "comment": "11 pages, 9 figures", "summary": "Traditional quality assurance (QA) methods face significant challenges in\naddressing the complexity, scale, and rapid iteration cycles of modern software\nsystems and are strained by limited resources available, leading to substantial\ncosts associated with poor quality. The object of this research is the Quality\nAssurance processes for modern distributed software applications. The subject\nof the research is the assessment of the benefits, challenges, and prospects of\nintegrating modern AI-oriented tools into quality assurance processes. We\nperformed comprehensive analysis of implications on both verification and\nvalidation processes covering exploratory test analyses, equivalence\npartitioning and boundary analyses, metamorphic testing, finding\ninconsistencies in acceptance criteria (AC), static analyses, test case\ngeneration, unit test generation, test suit optimization and assessment, end to\nend scenario execution. End to end regression of sample enterprise application\nutilizing AI-agents over generated test scenarios was implemented as a proof of\nconcept highlighting practical use of the study. The results, with only 8.3%\nflaky executions of generated test cases, indicate significant potential for\nthe proposed approaches. However, the study also identified substantial\nchallenges for practical adoption concerning generation of semantically\nidentical coverage, \"black box\" nature and lack of explainability from\nstate-of-the-art Large Language Models (LLMs), the tendency to correct mutated\ntest cases to match expected results, underscoring the necessity for thorough\nverification of both generated artifacts and test execution results. The\nresearch demonstrates AI's transformative potential for QA but highlights the\nimportance of a strategic approach to implementing these technologies,\nconsidering the identified limitations and the need for developing appropriate\nverification methodologies."}
{"id": "2506.16639", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16639", "abs": "https://arxiv.org/abs/2506.16639", "authors": ["Boqi Chen", "Aren A. Babikian", "Shuzhao Feng", "Dániel Varró", "Gunter Mussbacher"], "title": "LLM-based Satisfiability Checking of String Requirements by Consistent Data and Checker Generation", "comment": "Accepted at the 33rd IEEE International Requirements Engineering 2025\n  conference", "summary": "Requirements over strings, commonly represented using natural language (NL),\nare particularly relevant for software systems due to their heavy reliance on\nstring data manipulation. While individual requirements can usually be analyzed\nmanually, verifying properties (e.g., satisfiability) over sets of NL\nrequirements is particularly challenging. Formal approaches (e.g., SMT solvers)\nmay efficiently verify such properties, but are known to have theoretical\nlimitations. Additionally, the translation of NL requirements into formal\nconstraints typically requires significant manual effort. Recently, large\nlanguage models (LLMs) have emerged as an alternative approach for formal\nreasoning tasks, but their effectiveness in verifying requirements over strings\nis less studied. In this paper, we introduce a hybrid approach that verifies\nthe satisfiability of NL requirements over strings by using LLMs (1) to derive\na satisfiability outcome (and a consistent string, if possible), and (2) to\ngenerate declarative (i.e., SMT) and imperative (i.e., Python) checkers, used\nto validate the correctness of (1). In our experiments, we assess the\nperformance of four LLMs. Results show that LLMs effectively translate natural\nlanguage into checkers, even achieving perfect testing accuracy for\nPython-based checkers. These checkers substantially help LLMs in generating a\nconsistent string and accurately identifying unsatisfiable requirements,\nleading to more than doubled generation success rate and F1-score in certain\ncases compared to baselines without generated checkers."}
{"id": "2506.16650", "categories": ["cs.SE", "cs.AI", "cs.MA"], "pdf": "https://arxiv.org/pdf/2506.16650", "abs": "https://arxiv.org/abs/2506.16650", "authors": ["Anvith Pabba", "Alex Mathai", "Anindya Chakraborty", "Baishakhi Ray"], "title": "SemAgent: A Semantics Aware Program Repair Agent", "comment": null, "summary": "Large Language Models (LLMs) have shown impressive capabilities in downstream\nsoftware engineering tasks such as Automated Program Repair (APR). In\nparticular, there has been a lot of research on repository-level\nissue-resolution benchmarks such as SWE-Bench. Although there has been\nsignificant progress on this topic, we notice that in the process of solving\nsuch issues, existing agentic systems tend to hyper-localize on immediately\nsuspicious lines of code and fix them in isolation, without a deeper\nunderstanding of the issue semantics, code semantics, or execution semantics.\nConsequently, many existing systems generate patches that overfit to the user\nissue, even when a more general fix is preferable. To address this limitation,\nwe introduce SemAgent, a novel workflow-based procedure that leverages issue,\ncode, and execution semantics to generate patches that are complete -\nidentifying and fixing all lines relevant to the issue. We achieve this through\na novel pipeline that (a) leverages execution semantics to retrieve relevant\ncontext, (b) comprehends issue-semantics via generalized abstraction, (c)\nisolates code-semantics within the context of this abstraction, and (d)\nleverages this understanding in a two-stage architecture: a repair stage that\nproposes fine-grained fixes, followed by a reviewer stage that filters relevant\nfixes based on the inferred issue-semantics. Our evaluations show that our\nmethodology achieves a solve rate of 44.66% on the SWEBench-Lite benchmark\nbeating all other workflow-based approaches, and an absolute improvement of\n7.66% compared to our baseline, which lacks such deep semantic understanding.\nWe note that our approach performs particularly well on issues requiring\nmulti-line reasoning (and editing) and edge-case handling, suggesting that\nincorporating issue and code semantics into APR pipelines can lead to robust\nand semantically consistent repairs."}
{"id": "2506.16653", "categories": ["cs.SE", "cs.AI", "cs.LG"], "pdf": "https://arxiv.org/pdf/2506.16653", "abs": "https://arxiv.org/abs/2506.16653", "authors": ["Vladislav Belozerov", "Peter J Barclay", "Askhan Sami"], "title": "LLMs in Coding and their Impact on the Commercial Software Engineering Landscape", "comment": null, "summary": "Large-language-model coding tools are now mainstream in software engineering.\nBut as these same tools move human effort up the development stack, they\npresent fresh dangers: 10% of real prompts leak private data, 42% of generated\nsnippets hide security flaws, and the models can even ``agree'' with wrong\nideas, a trait called sycophancy. We argue that firms must tag and review every\nAI-generated line of code, keep prompts and outputs inside private or\non-premises deployments, obey emerging safety regulations, and add tests that\ncatch sycophantic answers -- so they can gain speed without losing security and\naccuracy."}
{"id": "2506.16831", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16831", "abs": "https://arxiv.org/abs/2506.16831", "authors": ["Filippo Scaramuzza", "Damian A. Tamburri", "Willem-Jan van den Heuvel"], "title": "Accountability of Robust and Reliable AI-Enabled Systems: A Preliminary Study and Roadmap", "comment": "To be published in https://link.springer.com/book/9789819672370", "summary": "This vision paper presents initial research on assessing the robustness and\nreliability of AI-enabled systems, and key factors in ensuring their safety and\neffectiveness in practical applications, including a focus on accountability.\nBy exploring evolving definitions of these concepts and reviewing current\nliterature, the study highlights major challenges and approaches in the field.\nA case study is used to illustrate real-world applications, emphasizing the\nneed for innovative testing solutions. The incorporation of accountability is\ncrucial for building trust and ensuring responsible AI development. The paper\noutlines potential future research directions and identifies existing gaps,\npositioning robustness, reliability, and accountability as vital areas for the\ndevelopment of trustworthy AI systems of the future."}
{"id": "2506.16876", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16876", "abs": "https://arxiv.org/abs/2506.16876", "authors": ["Halit Eris", "Stefan Wagner"], "title": "Revolutionizing Validation and Verification: Explainable Testing Methodologies for Intelligent Automotive Decision-Making Systems", "comment": "Preprint to be published at SE4ADS", "summary": "Autonomous Driving Systems (ADS) use complex decision-making (DM) models with\nmultimodal sensory inputs, making rigorous validation and verification (V&V)\nessential for safety and reliability. These models pose challenges in\ndiagnosing failures, tracing anomalies, and maintaining transparency, with\ncurrent manual testing methods being inefficient and labor-intensive. This\nvision paper presents a methodology that integrates explainability,\ntransparency, and interpretability into V&V processes. We propose refining V&V\nrequirements through literature reviews and stakeholder input, generating\nexplainable test scenarios via large language models (LLMs), and enabling\nreal-time validation in simulation environments. Our framework includes test\noracle, explanation generation, and a test chatbot, with empirical studies\nplanned to evaluate improvements in diagnostic efficiency and transparency. Our\ngoal is to streamline V&V, reduce resources, and build user trust in autonomous\ntechnologies."}
{"id": "2506.16878", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16878", "abs": "https://arxiv.org/abs/2506.16878", "authors": ["Man Zhang", "Yuechen Li", "Tao Yue", "Kai-Yuan Cai"], "title": "Quantum Optimization for Software Engineering: A Survey", "comment": null, "summary": "Quantum computing, particularly in the area of quantum optimization, is\nsteadily progressing toward practical applications, supported by an expanding\nrange of hardware platforms and simulators. While Software Engineering (SE)\noptimization has a strong foundation, which is exemplified by the active\nSearch-Based Software Engineering (SBSE) community and numerous classical\noptimization methods, the growing complexity of modern software systems and\ntheir engineering processes demands innovative solutions. This Systematic\nLiterature Review (SLR) focuses specifically on studying the literature that\napplies quantum or quantum-inspired algorithms to solve classical SE\noptimization problems. We examine 77 primary studies selected from an initial\npool of 2083 publications obtained through systematic searches of six digital\ndatabases using carefully crafted search strings. Our findings reveal\nconcentrated research efforts in areas such as SE operations and software\ntesting, while exposing significant gaps across other SE activities.\nAdditionally, the SLR uncovers relevant works published outside traditional SE\nvenues, underscoring the necessity of this comprehensive review. Overall, our\nstudy provides a broad overview of the research landscape, empowering the SBSE\ncommunity to leverage quantum advancements in addressing next-generation SE\nchallenges."}
{"id": "2506.16997", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.16997", "abs": "https://arxiv.org/abs/2506.16997", "authors": ["Hannah Deters", "Laura Reinhardt", "Jakob Droste", "Martin Obaidi", "Kurt Schneider"], "title": "Identifying Explanation Needs: Towards a Catalog of User-based Indicators", "comment": "This paper has been accepted at the research track of the 33rd IEEE\n  International Requirements Engineering Conference (RE 2025)", "summary": "In today's digitalized world, where software systems are becoming\nincreasingly ubiquitous and complex, the quality aspect of explainability is\ngaining relevance. A major challenge in achieving adequate explanations is the\nelicitation of individual explanation needs, as it may be subject to severe\nhypothetical or confirmation biases. To address these challenges, we aim to\nestablish user-based indicators concerning user behavior or system events that\ncan be captured at runtime to determine when a need for explanations arises. In\nthis work, we conducted explorative research in form of an online study to\ncollect self-reported indicators that could indicate a need for explanation. We\ncompiled a catalog containing 17 relevant indicators concerning user behavior,\n8 indicators concerning system events and 14 indicators concerning emotional\nstates or physical reactions. We also analyze the relationships between these\nindicators and different types of need for explanation. The established\nindicators can be used in the elicitation process through prototypes, as well\nas after publication to gather requirements from already deployed applications\nusing telemetry and usage data. Moreover, these indicators can be used to\ntrigger explanations at appropriate moments during the runtime."}
{"id": "2506.17057", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.17057", "abs": "https://arxiv.org/abs/2506.17057", "authors": ["Fernando Pastor Ricós", "Beatriz Marín", "I. S. W. B. Prasetya", "Tanja E. J. Vos", "Joseph Davidson", "Karel Hovorka"], "title": "Behavior Driven Development for 3D Games", "comment": null, "summary": "Computer 3D games are complex software environments that require novel\ntesting processes to ensure high-quality standards. The Intelligent\nVerification/Validation for Extended Reality Based Systems (iv4XR) framework\naddresses this need by enabling the implementation of autonomous agents to\nautomate game testing scenarios. This framework facilitates the automation of\nregression test cases for complex 3D games like Space Engineers. Nevertheless,\nthe technical expertise required to define test scripts using iv4XR can\nconstrain seamless collaboration between developers and testers. This paper\nreports how integrating a Behavior-driven Development (BDD) approach with the\niv4XR framework allows the industrial company behind Space Engineers to\nautomate regression testing. The success of this industrial collaboration has\ninspired the iv4XR team to integrate the BDD approach to improve the automation\nof play-testing for the experimental 3D game LabRecruits. Furthermore, the\niv4XR framework has been extended with tactical programming to enable the\nautomation of long-play test scenarios in Space Engineers. These results\nunderscore the versatility of the iv4XR framework in supporting diverse testing\napproaches while showcasing how BDD empowers users to create, manage, and\nexecute automated game tests using comprehensive and human-readable statements."}
{"id": "2506.17095", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.17095", "abs": "https://arxiv.org/abs/2506.17095", "authors": ["Ronnie de Souza Santos", "Matheus de Morais Leca", "Reydne Santos", "Cleyton Magalhaes"], "title": "Software Fairness Testing in Practice", "comment": null, "summary": "Software testing ensures that a system functions correctly, meets specified\nrequirements, and maintains high quality. As artificial intelligence and\nmachine learning (ML) technologies become integral to software systems, testing\nhas evolved to address their unique complexities. A critical advancement in\nthis space is fairness testing, which identifies and mitigates biases in AI\napplications to promote ethical and equitable outcomes. Despite extensive\nacademic research on fairness testing, including test input generation, test\noracle identification, and component testing, practical adoption remains\nlimited. Industry practitioners often lack clear guidelines and effective tools\nto integrate fairness testing into real-world AI development. This study\ninvestigates how software professionals test AI-powered systems for fairness\nthrough interviews with 22 practitioners working on AI and ML projects. Our\nfindings highlight a significant gap between theoretical fairness concepts and\nindustry practice. While fairness definitions continue to evolve, they remain\ndifficult for practitioners to interpret and apply. The absence of\nindustry-aligned fairness testing tools further complicates adoption,\nnecessitating research into practical, accessible solutions. Key challenges\ninclude data quality and diversity, time constraints, defining effective\nmetrics, and ensuring model interoperability. These insights emphasize the need\nto bridge academic advancements with actionable strategies and tools, enabling\npractitioners to systematically address fairness in AI systems."}
{"id": "2506.17120", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.17120", "abs": "https://arxiv.org/abs/2506.17120", "authors": ["Atish Kumar Dipongkor", "Ziyu Yao", "Kevin Moran"], "title": "Reassessing Code Authorship Attribution in the Era of Language Models", "comment": "12 pages", "summary": "The study of Code Stylometry, and in particular Code Authorship Attribution\n(CAA), aims to analyze coding styles to identify the authors of code samples.\nCAA is crucial in cybersecurity and software forensics for addressing,\ndetecting plagiarism, and supporting criminal prosecutions. However, CAA is a\ncomplex and error prone task, due to the need for recognizing nuanced\nrelationships between coding patterns. This challenge is compounded in large\nsoftware systems with numerous authors due to the subtle variability of\npatterns that signify the coding style of one author among many. Given the\nchallenges related to this task, researchers have proposed and studied\nautomated approaches that rely upon classical Machine Learning and Deep\nLearning techniques. However, such techniques have historically relied upon\nhand-crafted features, and due to the often intricate interaction of different\nfeatures (e.g., formatting, etc.), have key limitations in properly\ncharacterizing authorship, and are sensitive to adversarial code perturbations.\nRecently, transformer-based Language Models (LMs) have shown remarkable\nefficacy across a range of software engineering tasks, and in the authorship\nattribution on natural language in the NLP domain. However, their effectiveness\nin CAA is not well understood. As such, we conduct the first extensive\nempirical study applying two larger state-of-the-art code LMs, and five smaller\ncode LMs to the task of CAA to 6 diverse datasets that encompass 12k code\nsnippets written by 463 developers. Furthermore, we perform an in-depth\nanalysis of our studied models' performance on CAA using established machine\nlearning interpretability techniques. The results of our analysis illustrate\nimportant findings that illuminate the behavior of LMs in understanding\nstylometric code patterns during the task of CAA, and point towards important\ndirections for future work."}
{"id": "2506.17125", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2506.17125", "abs": "https://arxiv.org/abs/2506.17125", "authors": ["Xue Jiang", "Yihong Dong", "Zheng Fang", "Yingwei Ma", "Tangxinyu Wang", "Rongyu Cao", "Binhua Li", "Zhi Jin", "Wenpin Jiao", "Yongbin Li", "Ge Li"], "title": "Large Language Model Unlearning for Source Code", "comment": null, "summary": "LLM4SE has demonstrated significant success, but LLMs' potential memorization\nof sensitive or outdated training data introduces critical risks to legal\ncompliance, software security, and code quality. LLM unlearning techniques,\nwhich can eliminate the influence of undesired data from LLMs in a\npost-training way, present a promising solution to address these concerns.\nWhile recent efforts in LLM unlearning show effectiveness in natural language,\ntheir applicability to source code remains underexplored. Our empirical study\nreveals that existing LLM unlearning approaches, when applied to source code,\ncause severe model utility degradation, rendering models practically unusable\nfor code generation. In this paper, we propose PROD, a novel unlearning\napproach that enables LLMs to forget undesired code content while effectively\npreserving their code generation capabilities. PROD suppresses the probability\nof forget data in LLMs' output distribution while promoting candidate\ndistributional components, enabling the model to jointly learn to forget\nspecific content and retain its general capabilities. To facilitate this study,\nwe establish a benchmark for code unlearning evaluation, which includes three\ncritical downstream tasks: copyrighted code unlearning, insecure code\nunlearning, and deprecated API unlearning. Our evaluation demonstrates that\nPROD achieves superior balance between forget quality and model utility\ncompared to existing unlearning approaches across three downstream tasks, while\nconsistently exhibiting improvements when applied to LLMs of varying series.\nPROD also exhibits superior robustness against adversarial attacks without\ngenerating or exposing the data to be forgotten. The results underscore that\nour approach not only extends the application boundary of unlearning techniques\nto source code, but also holds significant implications for advancing reliable\ncode generation."}
{"id": "2506.17208", "categories": ["cs.SE", "cs.AI", "cs.CL"], "pdf": "https://arxiv.org/pdf/2506.17208", "abs": "https://arxiv.org/abs/2506.17208", "authors": ["Matias Martinez", "Xavier Franch"], "title": "Dissecting the SWE-Bench Leaderboards: Profiling Submitters and Architectures of LLM- and Agent-Based Repair Systems", "comment": null, "summary": "The rapid progress in Automated Program Repair (APR) has been driven by\nadvances in AI, particularly large language models (LLMs) and agent-based\nsystems. SWE-Bench is a recent benchmark designed to evaluate LLM-based repair\nsystems using real issues and pull requests mined from 12 popular open-source\nPython repositories. Its public leaderboards, SWE-Bench Lite and SWE-Bench\nVerified, have become central platforms for tracking progress and comparing\nsolutions. However, because the submission process does not require detailed\ndocumentation, the architectural design and origin of many solutions remain\nunclear. In this paper, we present the first comprehensive study of all\nsubmissions to the SWE-Bench Lite (68 entries) and Verified (79 entries)\nleaderboards, analyzing 67 unique approaches across dimensions such as\nsubmitter type, product availability, LLM usage, and system architecture. Our\nfindings reveal the dominance of proprietary LLMs (especially Claude 3.5/3.7),\nthe presence of both agentic and non-agentic designs, and a contributor base\nspanning from individual developers to large tech companies."}

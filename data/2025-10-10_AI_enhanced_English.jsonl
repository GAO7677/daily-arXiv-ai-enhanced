{"id": "2510.07582", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2510.07582", "abs": "https://arxiv.org/abs/2510.07582", "authors": ["Yuyan Bao", "Tiark Rompf"], "title": "Type, Ability, and Effect Systems: Perspectives on Purity, Semantics, and Expressiveness", "comment": null, "summary": "Programming benefits from a clear separation between pure, mathematical\ncomputation and impure, effectful interaction with the world. Existing\napproaches to enforce this separation include monads, type-and-effect systems,\nand capability systems. All share a tension between precision and usability,\nand each one has non-obvious strengths and weaknesses.\n  This paper aims to raise the bar in assessing such systems. First, we propose\na semantic definition of purity, inspired by contextual equivalence, as a\nbaseline independent of any specific typing discipline. Second, we propose that\nexpressiveness should be measured by the degree of completeness, i.e., how many\nsemantically pure terms can be typed as pure. Using this measure, we focus on\nminimal meaningful effect and capability systems and show that they are\nincomparable, i.e., neither subsumes the other in terms of expressiveness.\n  Based on this result, we propose a synthesis and show that type, ability, and\neffect systems combine their respective strengths while avoiding their\nweaknesses. As part of our formal model, we provide a logical relation to\nfacilitate proofs of purity and other properties for a variety of effect typing\ndisciplines.", "AI": {"tldr": "The paper introduces a semantic foundation for reasoning about purity in effectful programming, a new way to measure how expressive effect systems are, finds that minimal capability and effect systems are not directly comparable, and proposes a unified model that combines their advantages.", "motivation": "Programming paradigms strive to clearly distinguish pure computation from effectful interactions, but existing mechanisms (monads, type-and-effect systems, capabilities) have trade-offs between precision and usability. This creates a need for more precise assessment tools for such systems.", "method": "The paper first introduces a semantic, system-agnostic definition of purity based on contextual equivalence. It then develops a new criterion for expressiveness (degree of completeness) and applies it to minimal effect and capability systems, comparing their ability to classify pure terms. The authors also present a unification combining type, ability, and effect systems, supported by a formal logical relation for reasoning about purity.", "result": "Minimal effect and capability systems are shown to be incomparable in expressiveness; neither is strictly more powerful. The proposed unified system provides a framework that combines the strengths and avoids the weaknesses of traditional approaches. Logical relations are introduced to enable rigorous proofs of purity and related properties across systems.", "conclusion": "A new semantic foundation and evaluation metric for purity and expressiveness allow better analysis of effect systems and capabilities. The authors' synthesis offers a robust model benefiting from the best aspects of types, abilities, and effects, facilitating practical and precise reasoning about program purity."}}
{"id": "2510.07851", "categories": ["cs.PL", "cs.LO"], "pdf": "https://arxiv.org/pdf/2510.07851", "abs": "https://arxiv.org/abs/2510.07851", "authors": ["Willem Heijltjes"], "title": "The Functional Machine Calculus III: Control", "comment": null, "summary": "The Functional Machine Calculus (Heijltjes 2022) is a new approach to\nunifying the imperative and functional programming paradigms. It extends the\nlambda-calculus, preserving the key features of confluent reduction and typed\ntermination, to embed computational effects, evaluation strategies, and control\nflow operations. The first instalment modelled sequential higher-order\ncomputation with global store, input/output, probabilities, and\nnon-determinism, and embedded both the call-by-name and call-by-value\nlambda-calculus, as well as Moggi's computational metalanguage and Levy's\ncall-by-push-value. The present paper extends the calculus from sequential to\nbranching and looping control flow. This allows the faithful embedding of a\nminimal but complete imperative language, including conditionals, exception\nhandling, and iteration, as well as constants and algebraic data types.\n  The calculus is defined through a simple operational semantics, extending the\n(simplified) Krivine machine for the lambda-calculus with multiple operand\nstacks to model effects and a continuation stack to model sequential,\nbranching, and looping computation. It features a confluent reduction relation\nand a system of simple types that guarantees termination of the machine and\nstrong normalization of reduction (in the absence of iteration). These\nproperties carry over to the embedded imperative language, providing a unified\nfunctional-imperative model of computation that supports simple types, a direct\nand intuitive operational semantics, and a confluent reduction semantics.", "AI": {"tldr": "This paper extends the Functional Machine Calculus to unify functional and imperative programming, now supporting not only sequential effects but also branching and iteration. It preserves strong theoretical properties (like confluence and termination for non-iterative programs), allowing both paradigms to be modeled in a simple, unified calculus with clear operational semantics.", "motivation": "There is a longstanding divide between imperative and functional programming paradigms. Existing models generally preserve the strengths of one paradigm while struggling to represent the constructs of the other cleanly. This work seeks to bridge that gap, unifying imperative and functional features in a single, coherent calculus, while maintaining desirable properties like typed termination and confluence.", "method": "The paper extends the Functional Machine Calculus, which originally brought together a variety of computational effects and evaluation strategies within an extended lambda-calculus framework. The new work pushes the model further, enlarging its semantic machinery (adding multiple operand stacks, a continuation stack, and operational semantics inspired by the Krivine machine) to faithfully model branching and looping constructs typical of imperative languages.", "result": "The new calculus successfully embeds a minimal yet complete imperative language (supporting conditionals, loops, exception handling, constants, and algebraic data types) into the extended framework. It preserves important meta-theoretical properties such as confluent reduction and type-based guarantees of machine termination and strong normalization (except in the presence of iteration).", "conclusion": "The extended Functional Machine Calculus offers a unified and operationally intuitive framework that encompasses both functional and imperative paradigms. It supports simple types, a confluent reduction semantics, and faithfully models both sequential and branching/looping effects, paving the way for a more seamless integration of these traditions in programming language theory."}}
{"id": "2510.07435", "categories": ["cs.SE", "cs.HC"], "pdf": "https://arxiv.org/pdf/2510.07435", "abs": "https://arxiv.org/abs/2510.07435", "authors": ["Zixuan Feng", "Sadia Afroz", "Anita Sarma"], "title": "Modeling Developer Burnout with GenAI Adoption", "comment": "10 pages, LLM", "summary": "Generative AI (GenAI) is rapidly reshaping software development workflows.\nWhile prior studies emphasize productivity gains, the adoption of GenAI also\nintroduces new pressures that may harm developers' well-being. In this paper,\nwe investigate the relationship between the adoption of GenAI and developers'\nburnout. We utilized the Job Demands--Resources (JD--R) model as the analytic\nlens in our empirical study. We employed a concurrent embedded mixed-methods\nresearch design, integrating quantitative and qualitative evidence. We first\nsurveyed 442 developers across diverse organizations, roles, and levels of\nexperience. We then employed Partial Least Squares--Structural Equation\nModeling (PLS-SEM) and regression to model the relationships among job demands,\njob resources, and burnout, complemented by a qualitative analysis of\nopen-ended responses to contextualize the quantitative findings. Our results\nshow that GenAI adoption heightens burnout by increasing job demands, while job\nresources and positive perceptions of GenAI mitigate these effects, reframing\nadoption as an opportunity.", "AI": {"tldr": "GenAI adoption in software development increases burnout by raising job demands, but adequate support and positive perceptions can help turn this challenge into an opportunity.", "motivation": "Generative AI is transforming software development workflows, but concerns have arisen about its impact on developer well-being, particularly burnout. The paper seeks to understand the relationship between GenAI adoption and burnout.", "method": "The study uses the Job Demands\u2013Resources (JD\u2013R) model and employs a concurrent embedded mixed-methods research design. It combines quantitative (survey of 442 developers, PLS-SEM, and regression analysis) and qualitative (open-ended responses) evidence.", "result": "The adoption of GenAI increases burnout among developers mainly by raising job demands. However, sufficient job resources and positive attitudes towards GenAI can mitigate these negative effects and help reframe adoption as beneficial.", "conclusion": "While GenAI can lead to increased burnout due to heightened job demands, organizations and individuals can reduce its negative impact by enhancing job resources and fostering positive perceptions of GenAI adoption."}}
{"id": "2510.07529", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.07529", "abs": "https://arxiv.org/abs/2510.07529", "authors": ["Carol Hanna", "Federica Sarro", "Mark Harman", "Justyna Petke"], "title": "HotBugs.jar: A Benchmark of Hot Fixes for Time-Critical Bugs", "comment": null, "summary": "Hot fixes are urgent, unplanned changes deployed to production systems to\naddress time-critical issues. Despite their importance, no existing evaluation\nbenchmark focuses specifically on hot fixes. We present HotBugs$.$jar, the\nfirst dataset dedicated to real-world hot fixes. From an initial mining of 10\nactive Apache projects totaling over 190K commits and 150K issue reports, we\nidentified 746 software patches that met our hot-fix criteria. After manual\nevaluation, 679 were confirmed as genuine hot fixes, of which 110 are\nreproducible using a test suite. Building upon the Bugs$.$jar framework,\nHotBugs$.$jar integrates these 110 reproducible cases and makes available all\n679 manually validated hot fixes, each enriched with comprehensive metadata to\nsupport future research. Each hot fix was systematically identified using Jira\nissue data, validated by independent reviewers, and packaged in a reproducible\nformat with buggy and fixed versions, test suites, and metadata. HotBugs$.$jar\nhas already been adopted as the official challenge dataset for the Search-Based\nSoftware Engineering (SBSE) Conference Challenge Track, demonstrating its\nimmediate impact. This benchmark enables the study and evaluation of tools for\nrapid debugging, automated repair, and production-grade resilience in modern\nsoftware systems to drive research in this essential area forward.", "AI": {"tldr": "The paper introduces HotBugs.jar: the first comprehensive, manually validated, and reproducible dataset specifically for real-world software hot fixes, facilitating research and evaluation of rapid debugging and repair tools in modern production systems.", "motivation": "Hot fixes are crucial for addressing urgent, high-priority issues in production systems, yet there has been no dedicated evaluation benchmark or dataset specifically for hot fixes in software engineering research. The lack of such resources hinders the development and assessment of debugging and automated repair tools in these scenarios.", "method": "The authors mined 10 active Apache projects, analyzing over 190,000 commits and 150,000 issue reports. They systematically filtered and manually evaluated software patches based on specific hot-fix criteria, using Jira issue data. Independent reviewers validated the patches. The confirmed hot fixes were then packaged in a reproducible format\u2014including buggy and fixed code, test suites, and extensive metadata\u2014based on the Bugs.jar framework.", "result": "From the data mining and manual validation process, 746 candidate hot fixes were identified, and 679 were confirmed as genuine. Out of these, 110 are reproducible with available test suites. The dataset, called HotBugs.jar, contains both the 110 reproducible and all 679 validated hot fixes, with comprehensive metadata to assist future research. The dataset has already seen adoption in a major conference challenge track.", "conclusion": "HotBugs.jar is the first rigorous, reproducible, and metadata-rich benchmark dedicated to hot fixes in software, filling a critical gap in the research community. It enables systematic evaluation of tools targeting urgent production fixes, fostering advancement in automated repair and resilience of software systems."}}
{"id": "2510.07604", "categories": ["cs.SE", "D.2.4"], "pdf": "https://arxiv.org/pdf/2510.07604", "abs": "https://arxiv.org/abs/2510.07604", "authors": ["Yubo Bai", "Tapti Palit"], "title": "RustAssure: Differential Symbolic Testing for LLM-Transpiled C-to-Rust Code", "comment": "13 pages to appear in Proceedings of ASE 2025", "summary": "Rust is a memory-safe programming language that significantly improves\nsoftware security. Existing codebases written in unsafe memory languages, such\nas C, must first be transpiled to Rust to take advantage of Rust's improved\nsafety guarantees. RustAssure presents a system that uses Large Language Models\n(LLMs) to automatically transpile existing C codebases to Rust. RustAssure uses\nprompt engineering techniques to maximize the chances of the LLM generating\nidiomatic and safe Rust code. Moreover, because LLMs often generate code with\nsubtle bugs that can be missed under traditional unit or fuzz testing,\nRustAssure performs differential symbolic testing to establish the semantic\nsimilarity between the original C and LLM-transpiled Rust code. We evaluated\nRustAssure with five real-world applications and libraries, and showed that our\nsystem is able to generate compilable Rust functions for 89.8% of all C\nfunctions, of which 69.9% produced equivalent symbolic return values for both\nthe C and Rust functions.", "AI": {"tldr": "RustAssure leverages LLMs and advanced testing to automatically convert C code to safe Rust, achieving high compilation and semantic equivalence rates in real applications.", "motivation": "Rust is recognized for its memory safety, which is vital for software security. Many legacy codebases are written in memory-unsafe languages such as C. Efficiently and safely migrating these codebases to Rust is a significant challenge, requiring automation to harness Rust's benefits at scale.", "method": "RustAssure uses Large Language Models (LLMs) for automatic transpilation of C code to Rust, applying prompt engineering to guide the LLM toward generating idiomatic and safe Rust code. To ensure correctness beyond what basic tests provide, it employs differential symbolic testing to compare the semantic equivalence of the input C code and the generated Rust code.", "result": "RustAssure was tested on five real-world applications and libraries. It successfully generated compilable Rust functions from 89.8% of C functions. Out of these, 69.9% of the functions produced symbolically identical return values when comparing the original C function with its Rust counterpart.", "conclusion": "RustAssure demonstrates the potential of LLMs in automating the migration from C to Rust, generating mostly correct and safe Rust code while identifying the limitations and areas where semantics may diverge, thus enhancing software security through systematic translation and verification."}}
{"id": "2510.07740", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.07740", "abs": "https://arxiv.org/abs/2510.07740", "authors": ["Dezhi Ran", "Yuan Cao", "Mengzhou Wu", "Simin Chen", "Yuzhe Guo", "Jun Ren", "Zihe Song", "Hao Yu", "Jialei Wei", "Linyi Li", "Wei Yang", "Baishakhi Ray", "Tao Xie"], "title": "AppForge: From Assistant to Independent Developer -- Are GPTs Ready for Software Development?", "comment": "Under Review. Benchmark and leadboards at\n  https://appforge-bench.github.io/", "summary": "Large language models (LLMs) have demonstrated remarkable capability in\nfunction-level code generation tasks. Unlike isolated functions, real-world\napplications demand reasoning over the entire software system: developers must\norchestrate how different components interact, maintain consistency across\nstates over time, and ensure the application behaves correctly within the\nlifecycle and framework constraints. Yet, no existing benchmark adequately\nevaluates whether LLMs can bridge this gap and construct entire software\nsystems from scratch. To address this gap, we propose APPFORGE, a benchmark\nconsisting of 101 software development problems drawn from real-world Android\napps. Given a natural language specification detailing the app functionality, a\nlanguage model is tasked with implementing the functionality into an Android\napp from scratch. Developing an Android app from scratch requires understanding\nand coordinating app states, lifecycle management, and asynchronous operations,\ncalling for LLMs to generate context-aware, robust, and maintainable code. To\nconstruct APPFORGE, we design a multi-agent system to automatically summarize\nthe main functionalities from app documents and navigate the app to synthesize\ntest cases validating the functional correctness of app implementation.\nFollowing rigorous manual verification by Android development experts, APPFORGE\nincorporates the test cases within an automated evaluation framework that\nenables reproducible assessment without human intervention, making it easily\nadoptable for future research. Our evaluation on 12 flagship LLMs show that all\nevaluated models achieve low effectiveness, with the best-performing model\n(GPT-5) developing only 18.8% functionally correct applications, highlighting\nfundamental limitations in current models' ability to handle complex,\nmulti-component software engineering challenges.", "AI": {"tldr": "APPFORGE is a new, rigorous benchmark for assessing whether LLMs can create whole Android apps from scratch based on natural language specs. Tests of 12 leading models show all perform poorly, indicating major challenges for LLMs in real-world software engineering.", "motivation": "While large language models have excelled at function-level code generation, real-world software engineering tasks require reasoning and coordination at the application level. There is currently no suitable benchmark to evaluate whether LLMs can create full software systems from scratch.", "method": "The authors introduce APPFORGE, a benchmark composed of 101 software development problems based on real-world Android applications. They use a multi-agent system to extract functionalities from documentation and generate tests for validating implementations. Manual expert vetting ensures the quality of the benchmark, which includes automated evaluation to make assessments reproducible and scalable.", "result": "All 12 LLMs tested, including top models such as GPT-5, performed poorly, with the highest rate of correct full application implementation at only 18.8%. This reveals significant limitations in current LLMs' abilities to handle complex, multi-component software engineering tasks.", "conclusion": "Current large language models are far from sufficient in generating robust, functionally correct, real-world software applications, particularly when complex component interaction, state management, and lifecycle control are required. APPFORGE provides a rigorous benchmark for evaluating and improving LLMs on these holistic software engineering challenges."}}
{"id": "2510.07815", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.07815", "abs": "https://arxiv.org/abs/2510.07815", "authors": ["Zeyu Sun", "Jingjing Liang", "Weiyi Wang", "Chenyao Suo", "Junjie Chen", "Fanjiang Xu"], "title": "Interleaved Learning and Exploration: A Self-Adaptive Fuzz Testing Framework for MLIR", "comment": null, "summary": "MLIR (Multi-Level Intermediate Representation) has rapidly become a\nfoundational technology for modern compiler frameworks, enabling extensibility\nacross diverse domains. However, ensuring the correctness and robustness of\nMLIR itself remains challenging. Existing fuzzing approaches-based on manually\ncrafted templates or rule-based mutations-struggle to generate sufficiently\ndiverse and semantically valid test cases, making it difficult to expose subtle\nor deep-seated bugs within MLIR's complex and evolving code space. In this\npaper, we present FLEX, a novel self-adaptive fuzzing framework for MLIR. FLEX\nleverages neural networks for program generation, a perturbed sampling strategy\nto encourage diversity, and a feedback-driven augmentation loop that\niteratively improves its model using both crashing and non-crashing test cases.\nStarting from a limited seed corpus, FLEX progressively learns valid syntax and\nsemantics and autonomously produces high-quality test inputs. We evaluate FLEX\non the upstream MLIR compiler against four state-of-the-art fuzzers. In a\n30-day campaign, FLEX discovers 80 previously unknown bugs-including multiple\nnew root causes and parser bugs-while in 24-hour fixed-revision comparisons, it\ndetects 53 bugs (over 3.5x as many as the best baseline) and achieves 28.2%\ncode coverage, outperforming the next-best tool by 42%. Ablation studies\nfurther confirm the critical role of both perturbed generation and diversity\naugmentation in FLEX's effectiveness.", "AI": {"tldr": "FLEX is a new self-adaptive fuzzing tool for MLIR that uses neural networks and feedback loops to learn and generate diverse, valid test cases. It dramatically outperforms current fuzzers in both bug discovery and code coverage, proving to be a significant advancement for MLIR robustness testing.", "motivation": "Ensuring the correctness and robustness of MLIR, a foundational technology for compiler frameworks, is challenging due to the limitations of existing fuzzing approaches that fail to effectively generate diverse and semantically valid test cases.", "method": "The authors introduce FLEX, a self-adaptive fuzzing framework that uses neural networks for program generation, a perturbed sampling strategy for diversity, and a feedback-driven augmentation loop to iteratively refine its model based on collected test cases.", "result": "FLEX outperforms four state-of-the-art fuzzers on the upstream MLIR compiler, discovering 80 previously unknown bugs in a 30-day campaign and 53 bugs in 24-hour fixed-revision tests (over 3.5 times more than the best baseline), and achieving 28.2% code coverage, 42% higher than the next-best tool. Ablation studies highlight the importance of perturbed generation and diversity augmentation.", "conclusion": "FLEX effectively addresses the shortcomings of traditional MLIR fuzzing by autonomously generating high-quality, diverse, and valid test cases, leading to superior bug discovery and code coverage."}}
{"id": "2510.07834", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.07834", "abs": "https://arxiv.org/abs/2510.07834", "authors": ["Lingjun Liu", "Feiran Qin", "Owolabi Legunsen", "Marcelo d'Amorim"], "title": "Bug Histories as Sources of Compiler Fuzzing Mutators", "comment": null, "summary": "Bugs in compilers, which are critical infrastructure today, can have outsized\nnegative impacts. Mutational fuzzers aid compiler bug detection by\nsystematically mutating compiler inputs, i.e., programs. Their effectiveness\ndepends on the quality of the mutators used. Yet, no prior work used compiler\nbug histories as a source of mutators. We propose IssueMut, the first approach\nfor extracting compiler fuzzing mutators from bug histories. Our insight is\nthat bug reports contain hints about program elements that induced compiler\nbugs; they can guide fuzzers towards similar bugs. IssueMut uses an automated\nmethod to mine mutators from bug reports and retrofit such mutators into\nexisting mutational compiler fuzzers. Using IssueMut, we mine 587 mutators from\n1760 GCC and LLVM bug reports. Then, we run IssueMut on these compilers, with\nall their test inputs as seed corpora. We find that \"bug history\" mutators are\neffective: they find new bugs that a state-of-the-art mutational compiler\nfuzzer misses-28 in GCC and 37 in LLVM. Of these, 60 were confirmed or fixed,\nvalidating our idea that bug histories have rich information that compiler\nfuzzers should leverage.", "AI": {"tldr": "The paper presents IssueMut, the first system to extract compiler fuzzing mutators from bug histories. By mining 587 mutators from 1760 GCC and LLVM bug reports and integrating them into fuzzers, IssueMut uncovered dozens of unique bugs missed by mainstream fuzzers, with 60 confirmed or fixed, demonstrating that bug reports are highly valuable for guiding future compiler fuzzing.", "motivation": "Compiler bugs can cause serious issues in infrastructure, and finding these bugs is vital. While mutational fuzzers help by generating varied inputs, their effectiveness is limited by the sophistication of their mutators. Previous research hasn't exploited compiler bug histories as a source for new mutators.", "method": "The authors propose IssueMut, an automated approach to mine mutators directly from compiler bug reports. These mutators are then integrated into existing mutational fuzzers. They extracted 587 mutators from 1760 bug reports for both GCC and LLVM compilers and tested them by running IssueMut-enhanced fuzzers on seed test corpora.", "result": "IssueMut-derived mutators were able to find 28 new bugs in GCC and 37 in LLVM that were missed by state-of-the-art fuzzers. 60 of these bugs were confirmed or fixed, demonstrating the value of mining bug reports for mutators.", "conclusion": "Bug histories are a rich and largely untapped source of knowledge for improving compiler fuzzers. The automatic mining of mutators from bug reports significantly enhances bug-finding capabilities, as validated by the discovery and confirmation of new bugs."}}
{"id": "2510.07941", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2510.07941", "abs": "https://arxiv.org/abs/2510.07941", "authors": ["Srijita Basu", "Haraldsson Bengt", "Miroslaw Staron", "Christian Berger", "Jennifer Horkoff", "Magnus Almgren"], "title": "An AUTOSAR-Aligned Architectural Study of Vulnerabilities in Automotive SoC Software", "comment": "16 pages, 7 figures, 18th International Conference on the Quality of\n  Information and Communications Technology", "summary": "Cooperative, Connected and Automated Mobility (CCAM) are complex\ncyber-physical systems (CPS) that integrate computation, communication, and\ncontrol in safety-critical environments. At their core, System-on-Chip (SoC)\nplatforms consolidate processing units, communication interfaces, AI\naccelerators, and security modules into a single chip. AUTOSAR (AUTomotive Open\nSystem ARchitecture) standard was developed in the automotive domain to better\nmanage this complexity, defining layered software structures and interfaces to\nfacilitate reuse of HW/SW components. However, in practice, this integrated SoC\nsoftware architecture still poses security challenges, particularly in\nreal-time, safety-critical environments. Recent reports highlight a surge in\nSoC-related vulnerabilities, yet systematic analysis of their root causes and\nimpact within AUTOSAR-aligned architectures is lacking. This study fills that\ngap by analyzing 180 publicly reported automotive SoC vulnerabilities, mapped\nto a representative SoC software architecture model that is aligned with\nAUTOSAR principles for layered abstraction and service orientation. We identify\n16 root causes and 56 affected software modules, and examine mitigation delays\nacross Common Weakness Enumeration (CWE) categories and architectural layers.\nWe uncover dominant vulnerability patterns and critical modules with prolonged\npatch delays, and provide actionable insights for securing automotive CPS\nplatforms, including guides for improved detection, prioritization, and\nlocalization strategies for SoC software architectures in SoC-based vehicle\nplatforms.", "AI": {"tldr": "Security vulnerabilities in automotive SoC platforms, especially within AUTOSAR-aligned architectures, are systematically analyzed by mapping 180 reported cases. The study identifies key problems, root causes, affected modules, and delays in patching, offering practical strategies to strengthen security in modern vehicle systems.", "motivation": "The increasing complexity and integration of Cooperative, Connected and Automated Mobility (CCAM) systems based on System-on-Chip (SoC) architectures in the automotive sector has led to rising security concerns, especially given recent vulnerabilities and lack of systematic analysis within AUTOSAR-aligned designs.", "method": "The study systematically analyzes 180 publicly reported SoC vulnerabilities in automotive contexts, mapping each to a representative AUTOSAR-aligned SoC software architecture. The analysis involves identifying root causes, affected modules, and examining patch/mitigation delays across different CWE categories and architecture layers.", "result": "The authors identify 16 root causes and 56 affected software modules, revealing dominant vulnerability patterns and problematic modules with extended patch delays. They also uncover trends in mitigation timelines by mapping issues to architectural and CWE categories.", "conclusion": "This paper provides actionable recommendations for improving detection, prioritization, and localization of vulnerabilities in SoC-based automotive platforms. The insights help guide developers and integrators towards more robust security practices in CCAM-focused CPS."}}
{"id": "2510.08005", "categories": ["cs.SE", "cs.AI"], "pdf": "https://arxiv.org/pdf/2510.08005", "abs": "https://arxiv.org/abs/2510.08005", "authors": ["Utku Boran Torun", "Mehmet Taha Demircan", "Mahmut Furkan G\u00f6n", "Eray T\u00fcz\u00fcn"], "title": "Past, Present, and Future of Bug Tracking in the Generative AI Era", "comment": "Submitted to ACM TOSEM Special Issue: 2030 Software Engineering\n  Roadmap", "summary": "Traditional bug tracking systems rely heavily on manual reporting,\nreproduction, triaging, and resolution, each carried out by different\nstakeholders such as end users, customer support, developers, and testers. This\ndivision of responsibilities requires significant coordination and widens the\ncommunication gap between non-technical users and technical teams, slowing the\nprocess from bug discovery to resolution. Moreover, current systems are highly\nasynchronous; users often wait hours or days for a first response, delaying\nfixes and contributing to frustration. This paper examines the evolution of bug\ntracking, from early paper-based reporting to today's web-based and SaaS\nplatforms. Building on this trajectory, we propose an AI-powered bug tracking\nframework that augments existing tools with intelligent, large language model\n(LLM)-driven automation. Our framework addresses two main challenges: reducing\ntime-to-fix and minimizing human overhead. Users report issues in natural\nlanguage, while AI agents refine reports, attempt reproduction, and request\nmissing details. Reports are then classified, invalid ones resolved through\nno-code fixes, and valid ones localized and assigned to developers. LLMs also\ngenerate candidate patches, with human oversight ensuring correctness. By\nintegrating automation into each phase, our framework accelerates response\ntimes, improves collaboration, and strengthens software maintenance practices\nfor a more efficient, user-centric future.", "AI": {"tldr": "Manual bug tracking is slow due to coordination gaps and delays. This paper proposes an AI framework using LLMs to automate bug handling steps, reduce human effort, and offer quicker, more accurate fixes\u2014ultimately speeding up software maintenance and user satisfaction.", "motivation": "Bug tracking systems are currently slow and inefficient due to heavy reliance on manual processes and poor communication between users and technical teams, leading to delays and frustration.", "method": "The paper proposes an AI-powered bug tracking framework that integrates large language model-driven automation into existing tools. The framework enables users to report issues in natural language and uses AI to refine, reproduce, classify, and triage bugs. LLMs help generate candidate patches, with human oversight to ensure correctness.", "result": "The framework streamlines bug reporting, reduces human overhead, automates each phase from reporting to patch generation, accelerates response times, and improves collaboration between end users and developers.", "conclusion": "Integrating intelligent automation into bug tracking systems significantly improves efficiency, reduces delays, enhances collaboration, and leads to a more user-centric and robust software maintenance process."}}
{"id": "2510.08200", "categories": ["cs.SE", "68N15", "D.2.13"], "pdf": "https://arxiv.org/pdf/2510.08200", "abs": "https://arxiv.org/abs/2510.08200", "authors": ["Alexander Hellwig", "Nico Jansen", "Bernhard Rumpe"], "title": "Building Whitespace-Sensitive Languages Using Whitespace-Insensitive Components", "comment": "11 pages, 4 figures, 6 listings", "summary": "In Software Language Engineering, there is a trend towards reusability by\ncomposing modular language components. However, this reusability is severely\ninhibited by a gap in integrating whitespace-sensitive and\nwhitespace-insensitive languages. There is currently no consistent procedure\nfor seamlessly reusing such language components in both cases, such that\nlibraries often cannot be reused, and whitespacesensitive languages are\ndeveloped from scratch. This paper presents a technique for using modular,\nwhitespaceinsensitive language modules to construct whitespace sensitive\nlanguages by pre-processing language artifacts before parsing. The approach is\nevaluated by reconstructing a simplified version of the programming language\nPython. Our solution aims to increase the reusability of existing language\ncomponents to reduce development time and increase the overall quality of\nsoftware languages.", "AI": {"tldr": "This paper proposes a pre-processing approach that allows modular, whitespace-insensitive language components to be reused for building whitespace-sensitive languages, validated by reconstructing a simplified Python, thus improving reusability and efficiency in language engineering.", "motivation": "There is a growing need for reusability in Software Language Engineering through composable modular language components. However, this is hindered by difficulties in integrating whitespace-sensitive and whitespace-insensitive languages, which limits the reuse of libraries and necessitates developing whitespace-sensitive languages from scratch.", "method": "The paper proposes a technique that involves pre-processing language artifacts before parsing, allowing modular, whitespace-insensitive language modules to be used in constructing whitespace-sensitive languages.", "result": "The approach was evaluated by reconstructing a simplified version of Python, demonstrating increased reusability of existing language components.", "conclusion": "The presented technique can bridge the gap between whitespace-sensitive and -insensitive language modules, thus improving reusability, reducing development time, and enhancing the quality of software languages."}}

<div id=toc></div>

# Table of Contents

- [cs.SE](#cs.SE) [Total: 14]


<div id='cs.SE'></div>

# cs.SE [[Back]](#toc)

### [1] [Beyond Single LLMs: Enhanced Code Generation via Multi-Stage Performance-Guided LLM Orchestration](https://arxiv.org/abs/2510.01379)
*Huashan Chen,Zhenyu Qi,Haotang Li,Hong Chen,Jinfu Chen,Kebin Peng,In Kee Kim,Kyu Hyung Lee,Sen He*

Main category: cs.SE

TL;DR: Instead of relying on a single LLM for code generation, using a performance-guided framework to route tasks among multiple top-performing models yields much better correctness and speed, and is scalable for future AI advances.


<details>
  <summary>Details</summary>
Motivation: Current code generation approaches use a single language model, ignoring the varied computational strengths of different models across programming languages, problem types, and stages of software development.

Method: Comprehensive empirical evaluation of 17 state-of-the-art LLMs across five programming languages on code generation tasks, using correctness and performance metrics. Based on these insights, a multi-stage, performance-guided orchestration framework called PerfOrch was designed, which routes tasks dynamically among models in a generate-fix-refine workflow, with stage-wise validation and rollback mechanisms.

Result: PerfOrch, without requiring model fine-tuning, achieves substantially higher correctness (up to 96.22% on HumanEval-X and 91.37% on EffiBench-X) compared to GPT-4o and other single-model baselines. It also improves runtime performance across benchmarks, with median speedups between 17.67% and 27.66%. The system is scalable and supports seamless integration of new LLMs.

Conclusion: A multi-model orchestration framework can significantly outperform single-model approaches to code generation in both correctness and efficiency, and the plug-and-play architecture enables scalable, adaptable automated software engineering workflows.

Abstract: While Large Language Models (LLMs) have become the predominant paradigm for
automated code generation, current single-model approaches fundamentally ignore
the heterogeneous computational strengths that different models exhibit across
programming languages, algorithmic domains, and development stages. This paper
challenges the single-model convention by introducing a multi-stage,
performance-guided orchestration framework that dynamically routes coding tasks
to the most suitable LLMs within a structured generate-fix-refine workflow. Our
approach is grounded in a comprehensive empirical study of 17 state-of-the-art
LLMs across five programming languages (Python, Java, C++, Go, and Rust) using
HumanEval-X benchmark. The study, which evaluates both functional correctness
and runtime performance metrics (execution time, mean/max memory utilization,
and CPU efficiency), reveals pronounced performance heterogeneity by language,
development stage, and problem category. Guided by these empirical insights, we
present PerfOrch, an LLM agent that orchestrates top-performing LLMs for each
task context through stage-wise validation and rollback mechanisms. Without
requiring model fine-tuning, PerfOrch achieves substantial improvements over
strong single-model baselines: average correctness rates of 96.22% and 91.37%
on HumanEval-X and EffiBench-X respectively, surpassing GPT-4o's 78.66% and
49.11%. Beyond correctness gains, the framework delivers consistent performance
optimizations, improving execution time for 58.76% of problems with median
speedups ranging from 17.67% to 27.66% across languages on two benchmarks. The
framework's plug-and-play architecture ensures practical scalability, allowing
new LLMs to be profiled and integrated seamlessly, thereby offering a paradigm
for production-grade automated software engineering that adapts to the rapidly
evolving generative AI landscape.

</details>


### [2] [Deciphering WONTFIX: A Mixed-Method Study on Why GitHub Issues Get Rejected](https://arxiv.org/abs/2510.01514)
*J. Alexander Curtis,Sharadha Kasiviswanathan,Nasir Eisty*

Main category: cs.SE

TL;DR: The paper analyzes why and how the 'wontfix' label is used in popular GitHub repositories. It finds that about 30% of projects employ this label, mostly on bug reports and feature requests, with eight main reasons identified. While useful for project management, the label can hinder community participation and transparency.


<details>
  <summary>Details</summary>
Motivation: Despite frequent use, the actual impact and rationale for applying the wontfix label in open-source projects is unclear, affecting both management and community dynamics.

Method: A mixed-method approach, analyzing both quantitative repository data and qualitative open coding/thematic analysis on the reasoning behind the wontfix label usage.

Result: About 30% of projects on GitHub use the wontfix label, commonly on user-submitted bug reports and feature requests. Eight main themes for its usage were identified, showing diverse rationale from user-related issues to maintainer decisions.

Conclusion: The wontfix label is an important resource management tool in GitHub projects but may also discourage community engagement and reduce transparency.

Abstract: Context: The ``wontfix'' label is a widely used yet narrowly understood tool
in GitHub repositories, indicating that an issue will not be pursued further.
Despite its prevalence, the impact of this label on project management and
community dynamics within open-source software development is not clearly
defined. Objective: This study examines the prevalence and reasons behind
issues being labeled as wontfix across various open-source repositories on
GitHub. Method: Employing a mixed-method approach, we analyze both quantitative
data to assess the prevalence of the wontfix label and qualitative data to
explore the reasoning that it was used. Data were collected from 3,132 of
GitHub's most-popular repositories. Later, we employ open coding and thematic
analysis to categorize the reasons behind wontfix labels, providing a
structured understanding of the issue management landscape. Results: Our
findings show that about 30% of projects on GitHub apply the wontfix label to
some issues. These issues most often occur on user-submitted issues for bug
reports and feature requests. The study identified eight common themes behind
labeling issues as wontfix, ranging from user-specific control factors to
maintainer-specific decisions. Conclusions: The wontfix label is a critical
tool for managing resources and guiding contributor efforts in GitHub projects.
However, it can also discourage community involvement and obscure the
transparency of project management. Understanding these reasons aids project
managers in making informed decisions and fostering efficient collaboration
within open-source communities.

</details>


### [3] [MIMIC: Integrating Diverse Personality Traits for Better Game Testing Using Large Language Model](https://arxiv.org/abs/2510.01635)
*Yifei Chen,Sarra Habchi,Lili Wei*

Main category: cs.SE

TL;DR: MIMIC improves automated game testing by mimicking varied human playstyles, yielding better coverage and diversity of interactions than previous agents.


<details>
  <summary>Details</summary>
Motivation: Traditional automated testing methods in video games are insufficient because they fail to replicate the diverse strategies and playstyles of human players, limiting the ability to uncover edge cases and achieve thorough test coverage.

Method: The paper introduces MIMIC, a framework that integrates personality traits into gaming agents. These agents can mimic different human playstyles and strategies in similar game scenarios, leading to more varied gameplay behaviors.

Result: MIMIC demonstrates improved test coverage and richer in-game interactions across multiple games. In Minecraft, it outperforms existing state-of-the-art agents by achieving a higher task completion rate and generating more diverse solutions.

Conclusion: MIMIC enables gaming agents to better reflect human diversity, thus triggering more game scenarios and edge cases, improving the effectiveness of automated game testing.

Abstract: Modern video games pose significant challenges for traditional automated
testing algorithms, yet intensive testing is crucial to ensure game quality. To
address these challenges, researchers designed gaming agents using
Reinforcement Learning, Imitation Learning, or Large Language Models. However,
these agents often neglect the diverse strategies employed by human players due
to their different personalities, resulting in repetitive solutions in similar
situations. Without mimicking varied gaming strategies, these agents struggle
to trigger diverse in-game interactions or uncover edge cases.
  In this paper, we present MIMIC, a novel framework that integrates diverse
personality traits into gaming agents, enabling them to adopt different gaming
strategies for similar situations. By mimicking different playstyles, MIMIC can
achieve higher test coverage and richer in-game interactions across different
games. It also outperforms state-of-the-art agents in Minecraft by achieving a
higher task completion rate and providing more diverse solutions. These results
highlight MIMIC's significant potential for effective game testing.

</details>


### [4] [FOSS-chain: using blockchain for Open Source Software license compliance](https://arxiv.org/abs/2510.01740)
*Kypros Iacovou,Georgia M. Kapitsaki,Evangelia Vanezi*

Main category: cs.SE

TL;DR: This paper presents FOSS-chain, a blockchain-based web platform to automate open source license compliance for derivative works. Covering 14 OSS licenses, FOSS-chain showed promising results in a small user study, indicating its potential to address license compatibility and transparency issues in OSS development.


<details>
  <summary>Details</summary>
Motivation: Ensuring compliance with OSS license terms in derivative works is complex, with compatibility issues leading to legal risks. Current processes lack transparency and automation.

Method: The paper introduces FOSS-chain, a web platform integrating blockchain technology to automate and ensure OSS license compliance when creating derivative works. The system covers 14 OSS licenses and logs all actions immutably for transparency. A preliminary evaluation was conducted via a small user study.

Result: The initial prototype of FOSS-chain was tested in a small-scale user study. The results indicated promise in automating license compliance and transparency, suggesting potential for real-world adaptation.

Conclusion: Blockchain can improve OSS license management by enabling transparent, automated compliance. FOSS-chain demonstrates feasibility and potential, though further, larger-scale validation is needed.

Abstract: Open Source Software (OSS) is widely used and carries licenses that indicate
the terms under which the software is provided for use, also specifying
modification and distribution rules. Ensuring that users are respecting OSS
license terms when creating derivative works is a complex process. Compliance
issues arising from incompatibilities among licenses may lead to legal
disputes. At the same time, the blockchain technology with immutable entries
offers a mechanism to provide transparency when it comes to licensing and
ensure software changes are recorded. In this work, we are introducing an
integration of blockchain and license management when creating derivative
works, in order to tackle the issue of OSS license compatibility. We have
designed, implemented and performed a preliminary evaluation of FOSS-chain, a
web platform that uses blockchain and automates the license compliance process,
covering 14 OSS licenses. We have evaluated the initial prototype version of
the FOSS-chain platform via a small scale user study. Our preliminary results
are promising, demonstrating the potential of the platform for adaptation on
realistic software systems.

</details>


### [5] [ARENA: A tool for measuring and analysing the energy efficiency of Android apps](https://arxiv.org/abs/2510.01754)
*Hina Anwar*

Main category: cs.SE

TL;DR: Accurately measuring Android app energy use is hard with current hardware methods. ARENA, a plugin for IntelliJ and Android Studio, streamlines this process by integrating measurement, analysis, and visualization directly into the IDE, making it much easier for developers.


<details>
  <summary>Details</summary>
Motivation: Developers and researchers need to accurately and efficiently measure the energy consumption of Android apps to build energy-efficient applications. Current hardware-based measurement processes are complex, time-consuming, and difficult to reproduce, with a lack of open-source tools that facilitate reliable measurements integrated within development environments.

Method: The authors designed and implemented ARENA, a tool integrated as a plugin for IntelliJ and Android Studio. ARENA connects to physical energy measurement devices, automates the experimental workflow (setup, execution, data collection, cleaning, aggregation, and visualization), and allows comparative analysis of app energy consumption directly within the IDE.

Result: ARENA enables developers and researchers to seamlessly perform hardware-based energy measurements, compare different app versions, and efficiently analyze, report, and visualize energy usage data, all from within their familiar development environments.

Conclusion: ARENA significantly reduces the barrier and effort required for reliable hardware-based energy measurement and analysis of Android apps, making the process easier, more reproducible, and accessible to both developers and researchers.

Abstract: To build energy-efficient apps, there is a need to estimate and analyze their
energy consumption in typical usage scenarios. The energy consumption of
Android apps could be estimated via software-based and hardware-based
approaches. Software-based approaches, while easier to implement, are not as
accurate as hardware-based approaches. The process of measuring the energy
consumption of an Android app via a hardware-based approach typically involves
1) setting up a measurement environment, 2) executing the app under test on a
mobile device, 3) recording current/voltage data via a hardware device to
measure energy consumption, and 4) cleaning and aggregating data for analyses,
reports, and visualizations. Specialized scripts are written for selected
hardware and software components to ensure reliable energy measurements. The
energy measurement process is repeated many times and aggregated to remove
noise. These steps make the hardware-based energy measurement process
time-consuming and not easy to adapt or reproduce. There is a lack of
open-source tools available for developers and researchers to take reliable
energy measurements via hardware devices. In this paper, we present and
demonstrate ARENA, a support tool that enables developers and researchers to
connect to a physical measurement device without leaving the comfort of their
IDE. Developers could use ARENA during development to compare energy
consumption between different apps or versions of the same app. ARENA
calculates energy consumption on an Android smartphone by executing a test
scenario on the app under development. Further, ARENA helps aggregate,
statistically analyze, report, and visualize the data, allowing developers and
researchers to dig into the data directly or visually. We implemented ARENA as
an IntelliJ and Android Studio plugin.

</details>


### [6] [Towards Speeding up Program Repair with Non-Autoregressive Model](https://arxiv.org/abs/2510.01825)
*Zhenyu Yang,Yue Pan,Zhen Yang,Zhongxing Yu*

Main category: cs.SE

TL;DR: Traditional machine learning approaches for program repair are slow due to sequential generation. This paper introduces NARRepair, the first non-autoregressive model for APR, which is much faster and matches or beats existing methods on both speed and accuracy thanks to several smart design choices.


<details>
  <summary>Details</summary>
Motivation: Current machine learning-based automatic program repair (APR) methods use autoregressive (AR) models, which suffer from significant delays during the bug fixing process due to their token-by-token generation process. These delays become worse as model size increases.

Method: The authors propose NARRepair, a novel non-autoregressive (NAR) code generation model specifically customized for APR. It addresses AR limitations using three key innovations: a repair action predictor (reduces over-correction), an inter-token dependency extractor (improves token relationships), and a two-stage decoder (enhances contextual understanding).

Result: Experiments on three popular APR datasets show that NARRepair dramatically improves repair speed (1.4-6.4x faster than AR-based models) and achieves superior performance in limited repair time. It reaches state-of-the-art results in both repair speed and accuracy.

Conclusion: NARRepair is a significant advance in machine learning-based APR: by leveraging non-autoregressive modeling and tailored innovations, it delivers faster and more accurate program repairs than prior techniques.

Abstract: Enlightened by the success of machine learning techniques in various
application areas, recent years have witnessed a surge of research efforts on
automatic program repair (APR) using machine learning techniques. Previous
machine learning-based APR techniques essentially modified bugs in the
autoregressive (AR) manner, which predicts future values based on past values.
Due to the manner of token-by-token generation, the AR-based APR technique has
a huge time delay. In particular, the delay of the APR model with a large
number of parameters is more serious. To address the issue, we aim to apply the
non-autoregressive (NAR) method to the APR task, which can output target code
in a parallel manner to avoid huge repair delays. However, the naive use of the
NAR manner for the APR task suffers from the issue of compromised patch
quality. To effectively adapt the NAR manner for the APR task, we in this paper
propose NARRepair, the first customized NAR code generation model for the APR
task. The NARRepair model features three major novelties, including 1) the
repair action predictor for alleviating the over-correction issue, 2) the
inter-token dependency extractor for alleviating the issue of lacking
inter-token dependency information, and 3) the two-stage decoder for
alleviating the issue of lacking contextual information. We evaluated NARRepair
on three widely used datasets in the APR community, and the results show that
1) compared to other APR techniques, the NARRepair model has the best
performance within the limited repair time, and 2) compared to AR-based APR
techniques, the repair speed of NARRepair has been increased by 1.4-6.4 times
in the GPU environment. Overall, the results show that NARRepair has achieved
state-of-the-art comprehensive performance in terms of repair speed and
accuracy.

</details>


### [7] [RefFilter: Improving Semantic Conflict Detection via Refactoring-Aware Static Analysis](https://arxiv.org/abs/2510.01960)
*Victor Lira,Paulo Borba,Rodrigo Bonifácio,Galileu Santos e Matheus barbosa*

Main category: cs.SE

TL;DR: RefFilter is a novel tool that uses automated refactoring detection to filter out harmless code changes, reducing false positives in interference detection by 32%, thus making merge conflict detection more accurate and practical for developers.


<details>
  <summary>Details</summary>
Motivation: Collaborative software development often faces challenges due to semantic interference caused by code changes, with current static analysis methods yielding many false positives, particularly from behavior-preserving code refactorings.

Method: The paper introduces RefFilter, a static analysis tool that automatically detects refactorings and filters out behavior-preserving code changes to improve accuracy in semantic interference detection.

Result: RefFilter significantly reduced false positives by almost 32% in the labeled dataset, with only a minor, statistically insignificant rise in false negatives, leading to an overall increase in precision.

Conclusion: Refactoring-aware semantic interference detection, as implemented in RefFilter, presents an effective approach to enhance merge support processes, offering marked improvements in precision for software development workflows.

Abstract: Detecting semantic interference remains a challenge in collaborative software
development. Recent lightweight static analysis techniques improve efficiency
over SDG-based methods, but they still suffer from a high rate of false
positives. A key cause of these false positives is the presence of
behavior-preserving code refactorings, which current techniques cannot
effectively distinguish from changes that impact behavior and can interfere
with others. To handle this problem we present RefFilter, a refactoring-aware
tool for semantic interference detection. It builds on existing static
techniques by incorporating automated refactoring detection to improve
precision. RefFilter discards behavior-preserving refactorings from reports,
reducing false positives while preserving detection coverage. To evaluate
effectiveness and scalability, use two datasets: a labeled dataset with 99
scenarios and ground truth, and a novel dataset of 1,087 diverse merge
scenarios that we have built. Experimental results show that RefFilter reduces
false positives by nearly 32% on the labeled dataset. While this reduction
comes with a non significant increase in false negatives, the overall gain in
precision significantly outweighs the minor trade-off in recall. These findings
demonstrate that refactoring-aware interference detection is a practical and
effective strategy for improving merge support in modern development workflows.

</details>


### [8] [Clarifying Semantics of In-Context Examples for Unit Test Generation](https://arxiv.org/abs/2510.01994)
*Chen Yang,Lin Yang,Ziqi Wang,Dong Wang,Jianyi Zhou,Junjie Chen*

Main category: cs.SE

TL;DR: CLAST is a new technique for refining unit tests to boost their clarity, outperforming the current standard (UTgen) and enhancing LLM-driven test generation through better in-context examples. Benchmarks and user studies confirm its effectiveness.


<details>
  <summary>Details</summary>
Motivation: Effective unit test generation with LLMs is heavily dependent on the quality of in-context examples. Poorly structured or unclear tests reduce generation quality; thus, improving semantic clarity of example tests is crucial.

Method: CLAST leverages program analysis and LLM-based rewriting to decompose and refine complex unit tests, making them more logically clear and semantically precise. Comparative evaluation was conducted against UTgen and through user studies.

Result: CLAST fully retains original test effectiveness. It outperformed UTgen, which reduced effectiveness metrics significantly. User studies showed over 85% preference for CLAST-refined tests' clarity. When used as examples for ICL-based test generation, CLAST led to substantial improvements in generated tests’ compilation success rate, pass rate, and coverage.

Conclusion: CLAST significantly improves the semantic clarity of unit tests used as in-context examples, outperforming existing refinement techniques and positively impacting LLM-based test generation.

Abstract: Recent advances in large language models (LLMs) have enabled promising
performance in unit test generation through in-context learning (ICL). However,
the quality of in-context examples significantly influences the effectiveness
of generated tests-poorly structured or semantically unclear test examples
often lead to suboptimal outputs. In this paper, we propose CLAST, a novel
technique that systematically refines unit tests to improve their semantic
clarity, thereby enhancing their utility as in-context examples. The approach
decomposes complex tests into logically clearer ones and improves semantic
clarity through a combination of program analysis and LLM-based rewriting. We
evaluated CLAST on four open-source and three industrial projects. The results
demonstrate that CLAST largely outperforms UTgen, the state-of-the-art
refinement technique, in both preserving test effectiveness and enhancing
semantic clarity. Specifically, CLAST fully retains the original effectiveness
of unit tests, while UTgen reduces compilation success rate (CSR), pass rate
(PR), test coverage (Cov), and mutation score (MS) by an average of 12.90%,
35.82%, 4.65%, and 5.07%, respectively. Over 85.33% of participants in our user
study preferred the semantic clarity of CLAST-refined tests. Notably,
incorporating CLAST-refined tests as examples effectively improves ICL-based
unit test generation approaches such as RAGGen and TELPA, resulting in an
average increase of 25.97% in CSR, 28.22% in PR, and 45.99% in Cov for
generated tests, compared to incorporating UTgen-refined tests. The insights
from the follow-up user study not only reinforce CLAST's potential impact in
software testing practice but also illuminate avenues for future research.

</details>


### [9] [Automatic Generation of Combinatorial Reoptimisation Problem Specifications: A Vision](https://arxiv.org/abs/2510.02002)
*Maximilian Kratz,Steffen Zschaler,Jens Kosiol,Gabriele Taentzer*

Main category: cs.SE

TL;DR: The paper addresses the need to efficiently adapt solutions to optimisation problems when circumstances change, introducing a model-driven engineering approach for systematically deriving reoptimisation specifications. They illustrate their method using a tool and a practical example involving resource allocation.


<details>
  <summary>Details</summary>
Motivation: When real-world conditions change, existing solutions to optimisation problems need minimal, targeted updates, rather than complete re-solutions. Current approaches lack systematicity in specifying and solving these reoptimisation tasks. The paper aims to address this gap by leveraging model-driven techniques.

Method: The authors leverage declarative modelling languages and model transformations to systematically derive reoptimisation specifications. They offer a proof-of-concept implementation using the GIPS tool and demonstrate their approach with a resource allocation case study.

Result: The paper delivers an initial categorisation framework for reoptimisation problems and strategies, provides a proof-of-concept implementation, and successfully applies the approach to a teaching assistant allocation problem, demonstrating feasibility.

Conclusion: Model-Driven Engineering can facilitate the structured derivation of reoptimisation problems, making adaptations more systematic and potentially less disruptive. Their implementation shows initial promise for practical applications.

Abstract: Once an optimisation problem has been solved, the solution may need
adaptation when contextual factors change. This challenge, also known as
reoptimisation, has been addressed in various problem domains, such as railway
crew rescheduling, nurse rerostering, or aircraft recovery. This requires a
modified problem to be solved again to ensure that the adapted solution is
optimal in the new context. However, the new optimisation problem differs
notably from the original problem: (i) we want to make only minimal changes to
the original solution to minimise the impact; (ii) we may be unable to change
some parts of the original solution (e.g., because they refer to past
allocations); and (iii) we need to derive a change script from the original
solution to the new solution. In this paper, we argue that Model-Driven
Engineering (MDE) - in particular, the use of declarative modelling languages
and model transformations for the high-level specification of optimisation
problems - offers new opportunities for the systematic derivation of
reoptimisation problems from the original optimisation problem specification.
We focus on combinatorial reoptimisation problems and provide an initial
categorisation of changing problems and strategies for deriving the
corresponding reoptimisation specifications. We introduce an initial
proof-of-concept implementation based on the GIPS (Graph-Based (Mixed) Integer
Linear Programming Problem Specification) tool and apply it to an example
resource-allocation problem: the allocation of teaching assistants to teaching
sessions.

</details>


### [10] [ACM SIGSOFT SEN Empirical Software Engineering: Introducing Our New Regular Column](https://arxiv.org/abs/2510.02007)
*Justus Bogner,Roberto Verdecchia*

Main category: cs.SE

TL;DR: SEN-ESE is a new ACM SIGSOFT SEN column dedicated to discussing overlooked meta-issues in empirical software engineering research, inviting community input and fostering better practices.


<details>
  <summary>Details</summary>
Motivation: Despite advances, ESE research faces ongoing challenges such as reproducibility, external validity, subjective reviews, and industry adoption; documentation gaps make it hard for newcomers to learn the field.

Method: The column will feature content based on expert interviews, focus groups, surveys, and position papers, covering meta-aspects of ESE such as replication best practices and statistical methods.

Result: SEN-ESE introduces regular conversations on under-discussed or implicit ESE topics, inviting contributions and feedback to shape the direction of the column according to community interests.

Conclusion: The new SEN-ESE column aims to foster continuous reflection and improvement in empirical software engineering (ESE) research by providing a forum for meta-discussions and community input.

Abstract: From its early foundations in the 1970s, empirical software engineering (ESE)
has evolved into a mature research discipline that embraces a plethora of
different topics, methodologies, and industrial practices. Despite its
remarkable progress, the ESE research field still needs to keep evolving, as
new impediments, shortcoming, and technologies emerge. Research
reproducibility, limited external validity, subjectivity of reviews, and
porting research results to industrial practices are just some examples of the
drivers for improvements to ESE research. Additionally, several facets of ESE
research are not documented very explicitly, which makes it difficult for
newcomers to pick them up. With this new regular ACM SIGSOFT SEN column
(SEN-ESE), we introduce a venue for discussing meta-aspects of ESE research,
ranging from general topics such as the nature and best practices for
replication packages, to more nuanced themes such as statistical methods,
interview transcription tools, and publishing interdisciplinary research. Our
aim for the column is to be a place where we can regularly spark conversations
on ESE topics that might not often be touched upon or are left implicit.
Contributions to this column will be grounded in expert interviews, focus
groups, surveys, and position pieces, with the goal of encouraging reflection
and improvement in how we conduct, communicate, teach, and ultimately improve
ESE research. Finally, we invite feedback from the ESE community on
challenging, controversial, or underexplored topics, as well as suggestions for
voices you would like to hear from. While we cannot promise to act on every
idea, we aim to shape this column around the community interests and are
grateful for all contributions.

</details>


### [11] [Towards fairer public transit: Real-time tensor-based multimodal fare evasion and fraud detection](https://arxiv.org/abs/2510.02165)
*Peter Wauyo,Dalia Bwiza,Alain Murara,Edwin Mugume,Eric Umuhoza*

Main category: cs.SE

TL;DR: This paper presents a multimodal system that fuses video and audio data using advanced tensor fusion techniques to significantly improve real-time detection of fare evasion and fraud in public transport, outperforming previous approaches in accuracy and recall.


<details>
  <summary>Details</summary>
Motivation: Current public transportation systems face significant revenue loss and operational challenges due to fraud and fare evasion, which are difficult to automatically detect using unimodal approaches.

Method: The researchers developed a multimodal detection system combining CCTV video data (using ViViT) and audio data (using AST). These features are fused using a Tensor Fusion Network (TFN) that models complex unimodal and bimodal interactions, achieving more nuanced detection of fraudulent activity.

Result: The system achieved 89.5% accuracy, 87.2% precision, and 84.0% recall on a custom dataset, outperforming typical recall rates (75%) in prior work and showing significant improvements in F1 score and recall over simpler fusion methods.

Conclusion: Tensor fusion of video and audio data enables real-time, robust detection of public transportation fraud and fare evasion, offering clear benefits in operational compliance, safety, and revenue protection.

Abstract: This research introduces a multimodal system designed to detect fraud and
fare evasion in public transportation by analyzing closed circuit television
(CCTV) and audio data. The proposed solution uses the Vision Transformer for
Video (ViViT) model for video feature extraction and the Audio Spectrogram
Transformer (AST) for audio analysis. The system implements a Tensor Fusion
Network (TFN) architecture that explicitly models unimodal and bimodal
interactions through a 2-fold Cartesian product. This advanced fusion technique
captures complex cross-modal dynamics between visual behaviors (e.g.,
tailgating,unauthorized access) and audio cues (e.g., fare transaction sounds).
The system was trained and tested on a custom dataset, achieving an accuracy of
89.5%, precision of 87.2%, and recall of 84.0% in detecting fraudulent
activities, significantly outperforming early fusion baselines and exceeding
the 75% recall rates typically reported in state-of-the-art transportation
fraud detection systems. Our ablation studies demonstrate that the tensor
fusion approach provides a 7.0% improvement in the F1 score and an 8.8% boost
in recall compared to traditional concatenation methods. The solution supports
real-time detection, enabling public transport operators to reduce revenue
loss, improve passenger safety, and ensure operational compliance.

</details>


### [12] [SIEVE: Towards Verifiable Certification for Code-datasets](https://arxiv.org/abs/2510.02166)
*Fatou Ndiaye Mbodji,El-hacen Diallo,Jordan Samhi,Kui Liu,Jacques Klein,Tegawendé F. Bissyande*

Main category: cs.SE

TL;DR: Current code dataset quality assurance is fragmented and costly. SIEVE is proposed as a community-driven framework offering machine-verifiable, statistically bounded certificates (Confidence Cards) to improve dataset quality assurance, reduce costs, and increase trust.


<details>
  <summary>Details</summary>
Motivation: Code agents and empirical software engineering heavily rely on public code datasets, but there is currently no verifiable guarantee of the quality of these datasets. Existing methods like static dataset cards lack statistical and auditable assurance, causing reliability and cost issues.

Method: The authors propose SIEVE, a community-driven framework that transforms property checks into 'Confidence Cards,' which are machine-readable, verifiable certificates offering statistical guarantees that are valid at any time.

Result: SIEVE introduces statistical bounds and verifiable certification for code datasets, aiming to reduce fragmentation, lower quality-assurance costs, and increase dataset reliability.

Conclusion: Transitioning from narrative dataset cards to SIEVE's verifiable Confidence Cards will enhance the trustworthiness and accessibility of quality data, benefiting teams in terms of effectiveness and cost.

Abstract: Code agents and empirical software engineering rely on public code datasets,
yet these datasets lack verifiable quality guarantees. Static 'dataset cards'
inform, but they are neither auditable nor do they offer statistical
guarantees, making it difficult to attest to dataset quality. Teams build
isolated, ad-hoc cleaning pipelines. This fragments effort and raises cost. We
present SIEVE, a community-driven framework. It turns per-property checks into
Confidence Cards-machine-readable, verifiable certificates with anytime-valid
statistical bounds. We outline a research plan to bring SIEVE to maturity,
replacing narrative cards with anytime-verifiable certification. This shift is
expected to lower quality-assurance costs and increase trust in code-datasets.

</details>


### [13] [TAIBOM: Bringing Trustworthiness to AI-Enabled Systems](https://arxiv.org/abs/2510.02169)
*Vadim Safronov,Anthony McCaigue,Nicholas Allott,Andrew Martin*

Main category: cs.SE

TL;DR: Existing SBOM frameworks aren't equipped for the unique dependency and trust challenges of AI systems. TAIBOM extends SBOM principles with AI-specific features for dependency modeling, integrity propagation, and provenance attestation, leading to more secure, compliant, and transparent AI workflows.


<details>
  <summary>Details</summary>
Motivation: Traditional Software Bills of Materials (SBOMs) are insufficient for capturing the complexity and characteristics of AI-driven software systems, which often involve dynamic, loosely coupled dependencies across datasets, models, and code. Fragmented governance and a lack of robust verification tools further exacerbate trust and compliance challenges.

Method: The authors present TAIBOM—Trusted AI Bill of Materials—a framework that extends the principles of SBOMs to the AI domain. TAIBOM introduces a tailored dependency model for AI components, propagates integrity statements across diverse AI pipelines, and establishes a trust attestation process for verifying provenance of components.

Result: TAIBOM is shown to support improved assurance, security, and compliance in AI workflows and demonstrates advantages over existing standards such as SPDX and CycloneDX. The framework provides structured transparency and traceability specific to AI-enabled environments.

Conclusion: TAIBOM lays the groundwork for trustworthy and verifiable AI systems through enhanced transparency, integrity, and trust verification in software supply chains.

Abstract: The growing integration of open-source software and AI-driven technologies
has introduced new layers of complexity into the software supply chain,
challenging existing methods for dependency management and system assurance.
While Software Bills of Materials (SBOMs) have become critical for enhancing
transparency and traceability, current frameworks fall short in capturing the
unique characteristics of AI systems -- namely, their dynamic, data-driven
nature and the loosely coupled dependencies across datasets, models, and
software components. These challenges are compounded by fragmented governance
structures and the lack of robust tools for ensuring integrity, trust, and
compliance in AI-enabled environments.
  In this paper, we introduce Trusted AI Bill of Materials (TAIBOM) -- a novel
framework extending SBOM principles to the AI domain. TAIBOM provides (i) a
structured dependency model tailored for AI components, (ii) mechanisms for
propagating integrity statements across heterogeneous AI pipelines, and (iii) a
trust attestation process for verifying component provenance. We demonstrate
how TAIBOM supports assurance, security, and compliance across AI workflows,
highlighting its advantages over existing standards such as SPDX and CycloneDX.
This work lays the foundation for trustworthy and verifiable AI systems through
structured software transparency.

</details>


### [14] [FalseCrashReducer: Mitigating False Positive Crashes in OSS-Fuzz-Gen Using Agentic AI](https://arxiv.org/abs/2510.02185)
*Paschal C. Amusuo,Dongge Liu,Ricardo Andres Calvo Mendez,Jonathan Metzman,Oliver Chang,James C. Davis*

Main category: cs.SE

TL;DR: AI-driven strategies that enforce input constraints and validate crashes contextually can effectively reduce false positives in automated fuzz driver generation, halving reported crashes and increasing trust in large-scale fuzzing efforts like OSS-Fuzz-Gen.


<details>
  <summary>Details</summary>
Motivation: Fuzz testing is widely used to find software bugs and security vulnerabilities, but manually creating fuzz drivers for each function is costly and requires expertise. Automated methods exist, but often lead to false positive crashes, which is a significant problem, especially on large-scale projects like OSS-Fuzz-Gen.

Method: The paper introduces two AI-driven strategies within OSS-Fuzz-Gen: (1) constraint-based fuzz driver generation, which proactively enforces input and state constraints during driver creation, and (2) context-based crash validation, which reactively analyzes function callers to determine real feasibility of reported crashes from entry points.

Result: On a benchmark of 1,500 OSS-Fuzz functions, the strategies reduced spurious (false positive) crashes by up to 8%, decreased total reported crashes by over 50%, and illustrated the effectiveness of advanced language models as program analysis agents.

Conclusion: Integrating AI, particularly with constraint enforcement and context-aware crash validation, can significantly reduce false positives in automated fuzz driver generation and reporting. This improves the reliability and trust in large-scale fuzzing pipelines, though challenges remain.

Abstract: Fuzz testing has become a cornerstone technique for identifying software bugs
and security vulnerabilities, with broad adoption in both industry and
open-source communities. Directly fuzzing a function requires fuzz drivers,
which translate random fuzzer inputs into valid arguments for the target
function. Given the cost and expertise required to manually develop fuzz
drivers, methods exist that leverage program analysis and Large Language Models
to automatically generate these drivers. However, the generated fuzz drivers
frequently lead to false positive crashes, especially in functions highly
structured input and complex state requirements. This problem is especially
crucial in industry-scale fuzz driver generation efforts like OSS-Fuzz-en, as
reporting false positive crashes to maintainers impede trust in both the system
and the team.
  This paper presents two AI-driven strategies to reduce false positives in
OSS-Fuzz-Gen, a multi-agent system for automated fuzz driver generation. First,
constraint-based fuzz driver generation proactively enforces constraints on a
function's inputs and state to guide driver creation. Second, context-based
crash validation reactively analyzes function callers to determine whether
reported crashes are feasible from program entry points. Using 1,500 benchmark
functions from OSS-Fuzz, we show that these strategies reduce spurious crashes
by up to 8%, cut reported crashes by more than half, and demonstrate that
frontier LLMs can serve as reliable program analysis agents. Our results
highlight the promise and challenges of integrating AI into large-scale fuzzing
pipelines.

</details>

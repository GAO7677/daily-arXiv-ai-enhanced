{"id": "2507.12640", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.12640", "abs": "https://arxiv.org/abs/2507.12640", "authors": ["Tom Smeding", "Miko\u0142aj Konarski", "Simon Peyton Jones", "Andrew Fitzgibbon"], "title": "Dual-Numbers Reverse AD for Functional Array Languages", "comment": null, "summary": "The standard dual-numbers construction works well for forward-mode automatic\ndifferentiation (AD) and is attractive due to its simplicity; recently, it also\nhas been adapted to reverse-mode AD, but practical performance, especially on\narray programs, leaves a lot to be desired. In this paper we introduce\nfirst-class support for multidimensional arrays in dual-numbers reverse-mode AD\nwith little to no performance overhead. The algorithm consists of three\nloosely-coupled components: a semantics-preserving vectorisation code\ntransformation (the bulk-operation transform or BOT), a fairly straightforward\nlifting of the basic dual-numbers reverse AD algorithm to a mostly first-order\narray language, and symbolic interpretation to achieve an end-to-end\ncompilation pipeline. Unfortunately, we lose some of the nice generalisable\naspects of dual-numbers AD in the process, most importantly support for\nhigher-order code.\n  We do support some higher-order array combinators, but only a\ncarefully-chosen set: 'build' (elementwise array construction), 'gather' and\n'scatter'. In return, the BOT can eliminate the essential (for AD)\nhigher-orderness of the input program, meaning that AD gets essentially\npresented with a first-order program. This allows the naive trick of lifting\ndual numbers to \"dual arrays\" to work without much modification.", "AI": {"tldr": "This paper presents an efficient method for reverse-mode AD on array programs by transforming code to a first-order form and supporting specific higher-order operations, achieving minimal performance overhead but at the cost of general higher-order support.", "motivation": "The motivation is to improve the performance and practicality of reverse-mode automatic differentiation (AD) for array programs. Existing dual-numbers constructions for reverse-mode AD often suffer from performance issues, particularly for arrays.", "method": "The paper introduces a new algorithm with three parts: a semantics-preserving vectorisation code transformation (bulk-operation transform, BOT), an extension of the dual-numbers reverse-mode AD to a first-order array language, and symbolic interpretation for an end-to-end compilation pipeline. Only specific higher-order array combinators are supported to ensure first-order transformation.", "result": "The proposed method enables first-class support for multidimensional arrays in dual-numbers reverse-mode AD with little to no performance overhead. This is achieved by transforming higher-order code into first-order code, allowing for straightforward 'dual array' lifting.", "conclusion": "The approach sacrifices some generalizability, especially regarding general higher-order functions, but achieves practical, efficient reverse-mode AD for array programs by supporting a select set of higher-order combinators and focusing on first-order transformations."}}
{"id": "2507.13091", "categories": ["cs.PL"], "pdf": "https://arxiv.org/pdf/2507.13091", "abs": "https://arxiv.org/abs/2507.13091", "authors": ["Aur\u00e8le Barri\u00e8re", "Victor Deng", "Cl\u00e9ment Pit-Claudel"], "title": "Formal Verification for JavaScript Regular Expressions: a Proven Semantics and its Applications", "comment": "25 pages, 3 pages of references, 6 pages of appendix", "summary": "We present the first mechanized, succinct, practical, complete, and\nproven-faithful semantics for a modern regular expression language with\nbacktracking semantics. We ensure its faithfulness by proving it equivalent to\na preexisting line-by-line embedding of the official ECMAScript specification\nof JavaScript regular expressions. We demonstrate its practicality by\npresenting two real-world applications. First, a new notion of contextual\nequivalence for modern regular expressions, which we use to prove or disprove\nrewrites drawn from previous work. Second, the first formal proof of the PikeVM\nalgorithm used in many real-world engines. In contrast with the specification\nand other formalization work, our semantics captures not only the top-priority\nmatch, but a full backtracking tree recording all possible matches and their\nrespective priority. All our definitions and results have been mechanized in\nthe Rocq proof assistant.", "AI": {"tldr": "The paper introduces a fully formalized and mechanized semantics for JavaScript-style regular expressions with backtracking. Proven equivalent to the ECMAScript spec, it supports comprehensive analysis, enables correctness proofs of regex algorithms like PikeVM, and evaluates contextual equivalence for optimizations.", "motivation": "Formalizing the semantics of modern regular expressions, especially those used in JavaScript (ECMAScript), is challenging but important for program verification and understanding engine behaviors, especially with complex features such as backtracking. Prior work lacked practical, complete, or fully proven-faithful semantics.", "method": "The authors mechanized the semantics of a regular expression language with backtracking in the Rocq proof assistant. Their approach ensures faithfulness by proving equivalence to a line-by-line translation of the ECMAScript specification. They also track all possible matches and their priorities by capturing the entire backtracking tree, not just the highest priority match.", "result": "They developed a proven-faithful and practical mechanized semantics for JavaScript regular expressions. The approach is demonstrated with two applications: (1) introducing contextual equivalence for modern regexes and validating rewrite rules, and (2) providing the first formal proof of the PikeVM algorithm used in industry regex engines.", "conclusion": "This work provides the first comprehensive, mechanical, and faithful formalization of modern regular expressions with backtracking, along with practical applications and complete mechanization in Rocq."}}
{"id": "2507.13290", "categories": ["cs.PL", "cs.AI"], "pdf": "https://arxiv.org/pdf/2507.13290", "abs": "https://arxiv.org/abs/2507.13290", "authors": ["Aaron Councilman", "David Fu", "Aryan Gupta", "Chengxiao Wang", "David Grove", "Yu-Xiong Wang", "Vikram Adve"], "title": "Towards Formal Verification of LLM-Generated Code from Natural Language Prompts", "comment": "31 pages, 9 figures", "summary": "In the past few years LLMs have emerged as a tool that can aid programmers by\ntaking natural language descriptions and generating code based on it. However,\nLLMs often generate incorrect code that users need to fix and the literature\nsuggests users often struggle to detect these errors. In this work we seek to\noffer formal guarantees of correctness to LLM generated code; such guarantees\ncould improve the experience of using AI Code Assistants and potentially enable\nnatural language programming for users with little or no programming knowledge.\nTo address this challenge we propose to incorporate a formal query language\nthat can represent a user's intent in a formally defined but natural\nlanguage-like manner that a user can confirm matches their intent. Then, using\nsuch a query we propose to verify LLM generated code to ensure it matches the\nuser's intent. We implement these ideas in our system, Astrogator, for the\nAnsible programming language which includes such a formal query language, a\ncalculus for representing the behavior of Ansible programs, and a symbolic\ninterpreter which is used for the verification. On a benchmark suite of 21\ncode-generation tasks, our verifier is able to verify correct code in 83% of\ncases and identify incorrect code in 92%.", "AI": {"tldr": "This paper introduces Astrogator, a system for verifying LLM-generated code against user intent using a formal query language and symbolic verification, achieving strong results on Ansible tasks and improving trust in AI-generated code.", "motivation": "LLMs are increasingly used to generate code from natural language, but often produce incorrect code that users struggle to identify and fix. Providing formal correctness guarantees could improve user trust and usability, especially for non-programmers.", "method": "The authors introduce a formal query language allowing users to specify intent in a natural, confirmable way, integrated with a system called Astrogator for Ansible. Astrogator includes a calculus for Ansible program behaviors and a symbolic interpreter for code verification against user-specified intent.", "result": "Astrogator was evaluated on 21 code-generation tasks and could verify correct code in 83% of cases and identify incorrect code in 92% of cases.", "conclusion": "The proposed approach improves the reliability of LLM-generated code by enabling formal, intent-based verification, thus enhancing the experience of AI code assistants and making code generation more accessible and trustworthy."}}
{"id": "2507.12472", "categories": ["cs.SE", "cs.CL"], "pdf": "https://arxiv.org/pdf/2507.12472", "abs": "https://arxiv.org/abs/2507.12472", "authors": ["Lingzhe Zhang", "Tong Jia", "Mengxi Jia", "Yifan Wu", "Aiwei Liu", "Yong Yang", "Zhonghai Wu", "Xuming Hu", "Philip S. Yu", "Ying Li"], "title": "A Survey of AIOps in the Era of Large Language Models", "comment": "Accepted By CSUR, an extended version of \"A Survey of AIOps for\n  Failure Management in the Era of Large Language Models\" [arXiv:2406.11213]", "summary": "As large language models (LLMs) grow increasingly sophisticated and\npervasive, their application to various Artificial Intelligence for IT\nOperations (AIOps) tasks has garnered significant attention. However, a\ncomprehensive understanding of the impact, potential, and limitations of LLMs\nin AIOps remains in its infancy. To address this gap, we conducted a detailed\nsurvey of LLM4AIOps, focusing on how LLMs can optimize processes and improve\noutcomes in this domain. We analyzed 183 research papers published between\nJanuary 2020 and December 2024 to answer four key research questions (RQs). In\nRQ1, we examine the diverse failure data sources utilized, including advanced\nLLM-based processing techniques for legacy data and the incorporation of new\ndata sources enabled by LLMs. RQ2 explores the evolution of AIOps tasks,\nhighlighting the emergence of novel tasks and the publication trends across\nthese tasks. RQ3 investigates the various LLM-based methods applied to address\nAIOps challenges. Finally, RQ4 reviews evaluation methodologies tailored to\nassess LLM-integrated AIOps approaches. Based on our findings, we discuss the\nstate-of-the-art advancements and trends, identify gaps in existing research,\nand propose promising directions for future exploration.", "AI": {"tldr": "This paper surveys 183 recent studies on using large language models in AIOps, summarizing current trends, challenges, methods, and evaluation strategies, while mapping out key research gaps and future opportunities.", "motivation": "As large language models (LLMs) become more advanced and widely used, there is growing interest in their application to Artificial Intelligence for IT Operations (AIOps). However, there is a lack of comprehensive understanding regarding the impact, potential, and limitations of LLMs in AIOps.", "method": "The authors conducted a detailed survey, analyzing 183 research papers published between January 2020 and December 2024. They structured their analysis around four research questions focusing on data sources, the evolution of AIOps tasks, LLM-based methods for addressing challenges, and evaluation methodologies for LLM-integrated AIOps.", "result": "The survey reveals: (1) a variety of failure data sources and advanced LLM-based processing techniques for legacy and new data, (2) emergence and publication trends of new AIOps tasks aided by LLMs, (3) different LLM-based approaches to AIOps challenges, and (4) specialized evaluation methodologies. The findings highlight trends, current advancements, and research gaps in the field.", "conclusion": "The study consolidates the state-of-the-art in applying LLMs to AIOps, identifies underexplored areas, and suggests future research directions to better optimize and advance AIOps using LLMs."}}
{"id": "2507.12480", "categories": ["cs.SE", "cs.AI", "cs.ET"], "pdf": "https://arxiv.org/pdf/2507.12480", "abs": "https://arxiv.org/abs/2507.12480", "authors": ["Nazanin Siavash", "Armin Moin"], "title": "LLM-Powered Quantum Code Transpilation", "comment": "IEEE International Conference on Quantum Computing and Engineering\n  (QCE) 2025 - Extended Abstract", "summary": "There exist various Software Development Kits (SDKs) tailored to different\nquantum computing platforms. These are known as Quantum SDKs (QSDKs). Examples\ninclude but are not limited to Qiskit, Cirq, and PennyLane. However, this\ndiversity presents significant challenges for interoperability and\ncross-platform development of hybrid quantum-classical software systems.\nTraditional rule-based transpilers for translating code between QSDKs are\ntime-consuming to design and maintain, requiring deep expertise and rigid\nmappings in the source and destination code. In this study, we explore the use\nof Large Language Models (LLMs) as a flexible and automated solution.\nLeveraging their pretrained knowledge and contextual reasoning capabilities, we\nposition LLMs as programming language-agnostic transpilers capable of\nconverting quantum programs from one QSDK to another while preserving\nfunctional equivalence. Our approach eliminates the need for manually defined\ntransformation rules and offers a scalable solution to quantum software\nportability. This work represents a step toward enabling intelligent,\ngeneral-purpose transpilation in the quantum computing ecosystem.", "AI": {"tldr": "Using LLMs to automatically translate quantum programs between different SDKs enables easy interoperability without manual rules, making quantum software more portable and development more efficient.", "motivation": "The diversity of Quantum SDKs (QSDKs) like Qiskit, Cirq, and PennyLane leads to significant challenges in interoperability and cross-platform development for hybrid quantum-classical software systems. Existing rule-based transpilers require deep expertise and are difficult to maintain, creating a barrier for efficient code translation between QSDKs.", "method": "The paper explores the use of Large Language Models (LLMs) as automated, programming language-agnostic transpilers that convert quantum programs between different QSDKs. LLMs leverage their pretrained knowledge and contextual reasoning skills to perform these conversions without relying on manually specified transformation rules.", "result": "LLMs are demonstrated to successfully act as flexible and automated transpilers, converting quantum programs across various QSDKs while preserving their functionality. This approach removes the necessity for hand-crafted rules and expertise-intensive mapping, providing a scalable alternative for quantum program transformation.", "conclusion": "The study shows that LLMs can serve as intelligent, general-purpose transpilers for quantum programming, offering a robust and scalable solution to software portability challenges in the quantum computing landscape."}}
{"id": "2507.12482", "categories": ["cs.SE", "cs.AI", "cs.CE", "cs.LG", "68N30, 68T05, 68T50", "D.2.5; D.2.7; F.3.2; I.2.6; I.2.7"], "pdf": "https://arxiv.org/pdf/2507.12482", "abs": "https://arxiv.org/abs/2507.12482", "authors": ["Ishraq Khan", "Assad Chowdary", "Sharoz Haseeb", "Urvish Patel"], "title": "Kodezi Chronos: A Debugging-First Language Model for Repository-Scale, Memory-Driven Code Understanding", "comment": "10 pages, 10 figures, 7 tables, IEEE Conference format, Q4 2025 model\n  release, Q1 2026 Kodezi OS deployment", "summary": "Large Language Models (LLMs) have advanced code generation and software\nautomation, but are fundamentally constrained by limited inference-time context\nand lack of explicit code structure reasoning. We introduce Kodezi Chronos, a\nnext-generation architecture for autonomous code understanding, debugging, and\nmaintenance, designed to operate across ultra-long contexts comprising entire\ncodebases, histories, and documentation, all without fixed window limits.\nKodezi Chronos leverages a multi-level embedding memory engine, combining\nvector and graph-based indexing with continuous code-aware retrieval. This\nenables efficient and accurate reasoning over millions of lines of code,\nsupporting repository-scale comprehension, multi-file refactoring, and\nreal-time self-healing actions. Our evaluation introduces a novel Multi Random\nRetrieval benchmark, specifically tailored to the software engineering domain.\nUnlike classical retrieval benchmarks, this method requires the model to\nresolve arbitrarily distant and obfuscated associations across code artifacts,\nsimulating realistic tasks such as variable tracing, dependency migration, and\nsemantic bug localization. Chronos outperforms prior LLMs and code models,\ndemonstrating a 23% improvement in real-world bug detection and reducing\ndebugging cycles by up to 40% compared to traditional sequence-based\napproaches. By natively interfacing with IDEs and CI/CD workflows, Chronos\nenables seamless, autonomous software maintenance, elevating code reliability\nand productivity while reducing manual effort. These results mark a critical\nadvance toward self-sustaining, continuously optimized software ecosystems.", "AI": {"tldr": "Kodezi Chronos is a new, advanced architecture for large-scale code understanding and maintenance, overcoming context limitations of traditional LLMs. It uses multi-level memory and retrieval methods to work over entire codebases, outperforming prior models by detecting more bugs and speeding up debugging, marking progress toward autonomous, self-improving software.", "motivation": "Current Large Language Models (LLMs) used for code generation and software automation are limited by their context window sizes and lack the capability for explicit, structured reasoning over complex codebases. This restricts their effectiveness in large-scale, real-world software maintenance and debugging tasks.", "method": "The authors introduce Kodezi Chronos, a novel system utilizing a multi-level embedding memory engine that combines vector and graph-based indexing with continuous, code-aware retrieval. This architecture is designed to function across entire codebases and histories without context window limitations. They also present a new Multi Random Retrieval (MRR) benchmark to evaluate the model on realistic software engineering problems.", "result": "Kodezi Chronos significantly outperforms previous LLMs and code models, achieving a 23% improvement in real-world bug detection and reducing debugging cycles by up to 40% compared to sequence-based models. It natively integrates with development and deployment environments, supporting advanced code comprehension and maintenance capabilities.", "conclusion": "Kodezi Chronos represents a substantial advance in autonomous code understanding, debugging, and maintenance over ultra-long contexts. Its memory engine architecture and superior performance on realistic tasks bring closer the vision of self-sustaining, continuously improving software systems."}}
{"id": "2507.12483", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.12483", "abs": "https://arxiv.org/abs/2507.12483", "authors": ["Dong Wang", "Hanmo You", "Lingwei Zhu", "Kaiwei Lin", "Zheng Chen", "Chen Yang", "Junji Yu", "Zan Wang", "Junjie Chen"], "title": "A Survey of Reinforcement Learning for Software Engineering", "comment": null, "summary": "Reinforcement Learning (RL) has emerged as a powerful paradigm for sequential\ndecision-making and has attracted growing interest across various domains,\nparticularly following the advent of Deep Reinforcement Learning (DRL) in 2015.\nSimultaneously, the rapid advancement of Large Language Models (LLMs) has\nfurther fueled interest in integrating RL with LLMs to enable more adaptive and\nintelligent systems. In the field of software engineering (SE), the increasing\ncomplexity of systems and the rising demand for automation have motivated\nresearchers to apply RL to a broad range of tasks, from software design and\ndevelopment to quality assurance and maintenance. Despite growing research in\nRL-for-SE, there remains a lack of a comprehensive and systematic survey of\nthis evolving field. To address this gap, we reviewed 115 peer-reviewed studies\npublished across 22 premier SE venues since the introduction of DRL. We\nconducted a comprehensive analysis of publication trends, categorized SE topics\nand RL algorithms, and examined key factors such as dataset usage, model design\nand optimization, and evaluation practices. Furthermore, we identified open\nchallenges and proposed future research directions to guide and inspire ongoing\nwork in this evolving area. To summarize, this survey offers the first\nsystematic mapping of RL applications in software engineering, aiming to\nsupport both researchers and practitioners in navigating the current landscape\nand advancing the field. Our artifacts are publicly available:\nhttps://github.com/KaiWei-Lin-lanina/RL4SE.", "AI": {"tldr": "This paper provides the first thorough survey of reinforcement learning applications in software engineering, analyzing 115 studies, mapping trends, identifying challenges, and offering guidance for future work, with all findings and artifacts freely accessible online.", "motivation": "The complexity of modern software systems and the demand for enhanced automation in software engineering have driven interest in applying reinforcement learning approaches in this field. Despite increasing research efforts, there is a lack of a comprehensive, systematic review that maps out the state of RL applications in software engineering.", "method": "The paper conducts a systematic literature review of 115 peer-reviewed studies from 22 leading software engineering venues since the introduction of deep reinforcement learning. It analyzes publication trends, categorizes relevant software engineering topics and RL algorithms, assesses dataset usage, model design choices, optimization strategies, and evaluation practices. The study also identifies research gaps and outlines future research directions.", "result": "The survey provides the first systematic mapping of reinforcement learning applications in software engineering, presenting a detailed landscape of how RL is being used across various SE tasks, current trends, challenges, and best practices. It highlights key topics, algorithms, and evaluation methods, and makes research artifacts publicly available.", "conclusion": "This work fills a critical gap by offering a comprehensive overview of RL applications in software engineering, identifying open challenges, and proposing future research directions to guide both researchers and practitioners. The study supports further advancement of the field through accessible resources and systematic insights."}}
{"id": "2507.12558", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.12558", "abs": "https://arxiv.org/abs/2507.12558", "authors": ["Tien P. T. Le", "Anh M. T. Bui", "Huy N. D. Pham", "Alessio Bucaioni", "Phuong T. Nguyen"], "title": "When Retriever Meets Generator: A Joint Model for Code Comment Generation", "comment": "The paper has been peer-reviewed and accepted for publication in the\n  proceedings of the 19th ACM/IEEE International Symposium on Empirical\n  Software Engineering and Measurement (ESEM 2025)", "summary": "Automatically generating concise, informative comments for source code can\nlighten documentation effort and accelerate program comprehension.\nRetrieval-augmented approaches first fetch code snippets with existing comments\nand then synthesize a new comment, yet retrieval and generation are typically\noptimized in isolation, allowing irrelevant neighbors topropagate noise\ndownstream. To tackle the issue, we propose a novel approach named RAGSum with\nthe aim of both effectiveness and efficiency in recommendations. RAGSum is\nbuilt on top offuse retrieval and generation using a single CodeT5 backbone. We\nreport preliminary results on a unified retrieval-generation framework built on\nCodeT5. A contrastive pre-training phase shapes code embeddings for\nnearest-neighbor search; these weights then seed end-to-end training with a\ncomposite loss that (i) rewards accurate top-k retrieval; and (ii) minimizes\ncomment-generation error. More importantly, a lightweight self-refinement loop\nis deployed to polish the final output. We evaluated theframework on three\ncross-language benchmarks (Java, Python, C), and compared it with three\nwell-established baselines. The results show that our approach substantially\noutperforms thebaselines with respect to BLEU, METEOR, and ROUTE-L. These\nfindings indicate that tightly coupling retrieval and generationcan raise the\nceiling for comment automation and motivateforthcoming replications and\nqualitative developer studies.", "AI": {"tldr": "RAGSum, a unified retrieval-generation model for code comment automation built on CodeT5, significantly outperforms existing methods on multiple benchmarks by better integrating code retrieval and comment generation.", "motivation": "Automatically generating concise, informative comments for source code reduces documentation effort and accelerates program understanding. However, retrieval-augmented methods often suffer from noise because retrieval and generation are optimized separately, allowing irrelevant examples to influence results.", "method": "The authors introduce RAGSum, a unified framework that fuses code snippet retrieval and comment generation into a single model, based on CodeT5. The method uses a contrastive pre-training phase to shape code embeddings for effective retrieval and then carries out end-to-end training with a composite loss that rewards accurate retrieval and minimizes generation error. Additionally, a self-refinement loop further improves output quality.", "result": "RAGSum was tested on three cross-language (Java, Python, C) benchmarks and compared against three established baselines. The approach outperforms baselines in BLEU, METEOR, and ROUTE-L metrics, demonstrating its effectiveness.", "conclusion": "By tightly coupling retrieval and generation within a unified framework, RAGSum substantially improves automatic code comment generation, suggesting higher potential for automation and encouraging future studies in this direction."}}
{"id": "2507.12561", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.12561", "abs": "https://arxiv.org/abs/2507.12561", "authors": ["Samal Nursapa", "Anastassiya Samuilova", "Alessio Bucaioni. Phuong T. Nguyen"], "title": "ROSE: Transformer-Based Refactoring Recommendation for Architectural Smells", "comment": "The paper has been peer-reviewed and accepted for publication in the\n  proceedings of the 19th ACM/IEEE International Symposium on Empirical\n  Software Engineering and Measurement (ESEM 2025)", "summary": "Architectural smells such as God Class, Cyclic Dependency, and Hub-like\nDependency degrade software quality and maintainability. Existing tools detect\nsuch smells but rarely suggest how to fix them. This paper explores the use of\npre-trained transformer models--CodeBERT and CodeT5--for recommending suitable\nrefactorings based on detected smells. We frame the task as a three-class\nclassification problem and fine-tune both models on over 2 million refactoring\ninstances mined from 11,149 open-source Java projects. CodeT5 achieves 96.9%\naccuracy and 95.2% F1, outperforming CodeBERT and traditional baselines. Our\nresults show that transformer-based models can effectively bridge the gap\nbetween smell detection and actionable repair, laying the foundation for future\nrefactoring recommendation systems. We release all code, models, and data under\nan open license to support reproducibility and further research.", "AI": {"tldr": "The paper demonstrates that fine-tuned transformer models, especially CodeT5, can effectively recommend fixes for architectural smells in code, achieving high accuracy and outperforming other methods. All resources are openly released.", "motivation": "Architectural smells like God Class, Cyclic Dependency, and Hub-like Dependency negatively impact software quality and maintainability. While tools can detect these issues, there is little support for recommending how to fix them.", "method": "The authors fine-tune pre-trained transformer models (CodeBERT and CodeT5) for a three-class classification problem to recommend refactorings. The models are trained on over 2 million refactoring examples from 11,149 open-source Java projects.", "result": "CodeT5 reaches 96.9% accuracy and 95.2% F1 score, significantly outperforming CodeBERT and traditional baselines.", "conclusion": "Transformer-based models, especially CodeT5, effectively recommend actionable refactorings for architectural smells, bridging the gap between detection and repair. The authors release their code and data for reproducibility."}}
{"id": "2507.12642", "categories": ["cs.SE", "cs.AI", "quant-ph"], "pdf": "https://arxiv.org/pdf/2507.12642", "abs": "https://arxiv.org/abs/2507.12642", "authors": ["Kiana Kheiri", "Aamna Aamir", "Andriy Miranskyy", "Chen Ding"], "title": "QSpark: Towards Reliable Qiskit Code Generation", "comment": null, "summary": "Quantum circuits must be error-resilient, yet LLMs like Granite-20B-Code and\nStarCoder often output flawed Qiskit code. We fine-tuned a 32 B model with two\nRL methods, Group Relative Policy Optimization (GRPO) and Odds-Ratio Preference\nOptimization (ORPO), using a richly annotated synthetic dataset. On the Qiskit\nHumanEval benchmark, ORPO reaches 56.29\\% Pass@1 ($\\approx+10$ pp over\nGranite-8B-QK) and GRPO hits 49\\%, both beating all general-purpose baselines;\non the original HumanEval they score 65.90\\% and 63.00\\%. GRPO excels on basic\ntasks (42/54), ORPO on intermediate ones (41/68), and neither solves the five\nadvanced tasks, highlighting clear gains yet room for progress in AI-assisted\nquantum programming.", "AI": {"tldr": "The paper fine-tunes a large language model for quantum programming via two RL methods, achieving notably better Qiskit codegeneration accuracy, but still failing on the hardest tasks.", "motivation": "Quantum programming requires error-resilient circuits, but current large language models (LLMs) such as Granite-20B-Code and StarCoder often produce incorrect Qiskit code. Improving the reliability of LLM-generated code for quantum circuits is therefore critical.", "method": "The authors fine-tuned a 32B language model for Qiskit code generation using two reinforcement learning approaches: Group Relative Policy Optimization (GRPO) and Odds-Ratio Preference Optimization (ORPO). They trained the model on a synthetic dataset with detailed annotations.", "result": "On the Qiskit HumanEval benchmark, ORPO achieved a Pass@1 of 56.29% (about +10 percentage points over Granite-8B-QK), while GRPO reached 49%, both outperforming general-purpose baselines. On the original HumanEval benchmark, ORPO and GRPO scored 65.90% and 63.00%, respectively. GRPO was better on basic tasks, ORPO on intermediate ones, but neither could solve the most advanced tasks.", "conclusion": "Fine-tuning with GRPO and ORPO significantly improves quantum code generation over baseline models, though advanced tasks remain unsolved, indicating ongoing challenges in AI-driven quantum programming."}}
{"id": "2507.12649", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.12649", "abs": "https://arxiv.org/abs/2507.12649", "authors": ["Christine van Stiphoudt", "Sergio Potenciano Menci", "Gilbert Fridgen"], "title": "A Three-Phase Evaluation Approach for new Information and Data Models in the Smart Grid Domain", "comment": null, "summary": "The ongoing digitalisation of the smart grid is resulting in an increase in\nautomated information exchanges across distributed energy systems. This process\nhas led to the development of new information and data models when the existing\nones fall short. To prevent potential disruptions caused by flaws in the newly\ndesigned information and data models, it is essential to evaluate them during\nthe design process before they are implemented in operation.\n  Currently, general explicit evaluation approaches outside the smart grid\ndomain stay at a high level without defining clear steps. Meanwhile, implicit\nevaluation approaches in the smart grid domain focus on testing systems that\nutilise information and data models already in use for functionality in terms\nof conformance and interoperability. Notably, no combination of explicit and\nimplicit evaluation approaches for newly designed information and data models\noffers a clearly defined set of steps during their design process in the smart\ngrid context.\n  Consequently, we design a three-phase evaluation approach using design\nscience research to address this gap. Our evaluation approach combines explicit\nand implicit evaluation methods and is applicable when developing new\ninformation and data models. We use the development of an information model and\ndata model focused on industrial flexibility descriptions to refine our\nevaluation approach. Additionally, we provide lessons learned from our\nexperience.", "AI": {"tldr": "The paper proposes a new three-phase evaluation method for smart grid data models, combining explicit and implicit checks to improve model reliability early in the design phase, addressing a key gap in current practices.", "motivation": "The motivation is to address the lack of a clearly defined and combined explicit and implicit evaluation methodology for newly designed information and data models in the smart grid context, especially as digitalisation drives increased automation and data exchange.", "method": "The authors use a design science research approach to develop a three-phase evaluation method. This method combines both explicit and implicit evaluation techniques and is demonstrated using the development of an industrial flexibility-focused information and data model.", "result": "The result is a new, three-phase evaluation approach that systematically combines explicit and implicit assessment methods for smart grid information and data models during their design. The authors also present lessons learned from applying this approach on a concrete model development case.", "conclusion": "The paper concludes that their three-phase, combined evaluation method fills a methodical gap, providing a structured way to assess new information and data models during design in smart grid systems, enhancing reliability and robustness before operational deployment."}}
{"id": "2507.12653", "categories": ["cs.SE", "cs.CL", "H.4.m"], "pdf": "https://arxiv.org/pdf/2507.12653", "abs": "https://arxiv.org/abs/2507.12653", "authors": ["Jo\u00e3o Granja-Correia", "Remedios Hern\u00e1ndez-Linares", "Luca Ferranti", "Arm\u00e9nio Rego"], "title": "A Fuzzy Approach to Project Success: Measuring What Matters", "comment": "3 pages, 1 figure, presented at FUZZ-IEEE 2025", "summary": "This paper introduces a novel approach to project success evaluation by\nintegrating fuzzy logic into an existing construct. Traditional Likert-scale\nmeasures often overlook the context-dependent and multifaceted nature of\nproject success. The proposed hierarchical Type-1 Mamdani fuzzy system\nprioritizes sustained positive impact for end-users, reducing emphasis on\nsecondary outcomes like stakeholder satisfaction and internal project success.\nThis dynamic approach may provide a more accurate measure of project success\nand could be adaptable to complex evaluations. Future research will focus on\nempirical testing and broader applications of fuzzy logic in social science.", "AI": {"tldr": "This paper presents a new project success evaluation method using fuzzy logic, prioritizing end-user impact over secondary outcomes, potentially improving accuracy and adaptability compared to traditional measures.", "motivation": "Traditional Likert-scale measures do not adequately capture the complex, context-dependent nature of project success. There is a need for a more dynamic and accurate evaluation method that addresses these limitations.", "method": "The paper proposes integrating fuzzy logic into project success evaluation, specifically using a hierarchical Type-1 Mamdani fuzzy system. This method prioritizes sustained positive outcomes for end-users over secondary outcomes.", "result": "The approach shifts project evaluation focus towards long-term impacts for end-users rather than secondary factors such as stakeholder satisfaction. The system is dynamic and may offer more accurate evaluations, though empirical validation is still pending.", "conclusion": "Incorporating fuzzy logic into project evaluation could enhance measurement accuracy and adaptability in complex settings. Further empirical testing is planned to establish efficacy."}}
{"id": "2507.12665", "categories": ["cs.SE", "cs.AI", "cs.HC"], "pdf": "https://arxiv.org/pdf/2507.12665", "abs": "https://arxiv.org/abs/2507.12665", "authors": ["Salvador D. Escobedo"], "title": "Single Conversation Methodology: A Human-Centered Protocol for AI-Assisted Software Development", "comment": "Style reviewed by a LLM for improving clarity and English syntax", "summary": "We propose the Single Conversation Methodology (SCM), a novel and pragmatic\napproach to software development using large language models (LLMs). In\ncontrast to ad hoc interactions with generative AI, SCM emphasizes a structured\nand persistent development dialogue, where all stages of a project - from\nrequirements to architecture and implementation - unfold within a single,\nlong-context conversation. The methodology is grounded on principles of\ncognitive clarity, traceability, modularity, and documentation. We define its\nphases, best practices, and philosophical stance, while arguing that SCM offers\na necessary correction to the passive reliance on LLMs prevalent in current\npractices. We aim to reassert the active role of the developer as architect and\nsupervisor of the intelligent tool.", "AI": {"tldr": "The paper introduces Single Conversation Methodology (SCM), a structured way to use LLMs for software development in one long, coherent conversation, improving clarity, documentation, and developer oversight compared to unstructured AI interactions.", "motivation": "Current use of LLMs in software development is often ad hoc and unstructured, leading to passive reliance on AI and undermining developer control, traceability, and documentation. The paper aims to correct this by providing a more deliberate and structured interaction model.", "method": "The authors introduce the Single Conversation Methodology, where software development is conducted through one continuous, structured conversation with an LLM covering all project stages, guided by clear methodological principles. They outline phases, best practices, and philosophical underpinnings.", "result": "SCM allows for improved cognitive clarity, traceability, modularity, and documentation compared to ad hoc LLM usage. It reasserts the importance of the developer\u2019s active and central role in the process.", "conclusion": "The SCM provides a structured way to interact with LLMs in software development, promoting better oversight, modularity, and traceability, while positioning the human developer as an active supervisor rather than a passive consumer."}}
{"id": "2507.13035", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13035", "abs": "https://arxiv.org/abs/2507.13035", "authors": ["Keila Lucas", "Rohit Gheyi", "M\u00e1rcio Ribeiro", "Fabio Palomba", "Luana Martins", "Elvys Soares"], "title": "Investigating the Performance of Small Language Models in Detecting Test Smells in Manual Test Cases", "comment": "7 pages, Accepted at Insightful Ideas and Emerging Results (IIER)\n  Track of the Brazilian Symposium on Software Engineering (SBES 2025)", "summary": "Manual testing, in which testers follow natural language instructions to\nvalidate system behavior, remains crucial for uncovering issues not easily\ncaptured by automation. However, these test cases often suffer from test\nsmells, quality issues such as ambiguity, redundancy, or missing checks that\nreduce test reliability and maintainability. While detection tools exist, they\ntypically require manual rule definition and lack scalability. This study\ninvestigates the potential of Small Language Models (SLMs) for automatically\ndetecting test smells. We evaluate Gemma3, Llama3.2, and Phi-4 on 143\nreal-world Ubuntu test cases, covering seven types of test smells. Phi-4\nachieved the best results, reaching a pass@2 of 97% in detecting sentences with\ntest smells, while Gemma3 and Llama3.2 reached approximately 91%. Beyond\ndetection, SLMs autonomously explained issues and suggested improvements, even\nwithout explicit prompt instructions. They enabled low-cost, concept-driven\nidentification of diverse test smells without relying on extensive rule\ndefinitions or syntactic analysis. These findings highlight the potential of\nSLMs as efficient tools that preserve data privacy and can improve test quality\nin real-world scenarios.", "AI": {"tldr": "Small Language Models can automatically and accurately detect test quality issues ('test smells'), provide explanations, and suggest improvements in manual testing instructions, offering a scalable and privacy-friendly alternative to rule-based approaches.", "motivation": "Manual testing is still important for finding issues not easily detected by automation, but manual test cases often suffer from quality problems ('test smells'), which reduce reliability. Existing detection tools need manual rule creation and do not scale well.", "method": "The authors evaluated several Small Language Models (SLMs)\u2014Gemma3, Llama3.2, and Phi-4\u2014on their ability to automatically detect test smells in 143 real-world Ubuntu test cases representing seven different test smell types. Performance was measured using pass@2, and further capabilities (explanation, improvement suggestions) were observed.", "result": "Phi-4 achieved the highest detection rate with a pass@2 of 97%, while Gemma3 and Llama3.2 achieved about 91%. The SLMs also provided explanations and suggestions for improvements autonomously, even without detailed prompts.", "conclusion": "SLMs can effectively and efficiently detect various test smells, explain detected issues, and suggest improvements without the need for extensive rule definitions or syntactic analysis. This provides a scalable, privacy-preserving, and cost-effective way to improve test quality in manual testing contexts."}}
{"id": "2507.13081", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13081", "abs": "https://arxiv.org/abs/2507.13081", "authors": ["Dongming Jin", "Weisong Sun", "Jiangping Huang", "Peng Liang", "Jifeng Xuan", "Yang Liu", "Zhi Jin"], "title": "iReDev: A Knowledge-Driven Multi-Agent Framework for Intelligent Requirements Development", "comment": "22pages, 4 figures", "summary": "Requirements development is a critical phase as it is responsible for\nproviding a clear understanding of what stakeholders need. It involves\ncollaboration among stakeholders to extract explicit requirements and address\npotential conflicts, which is time-consuming and labor-intensive. Recently,\nmulti-agent systems for software development have attracted much attention.\nHowever, existing research provides limited support for requirements\ndevelopment and overlooks the injection of human knowledge into agents and the\nhuman-agent collaboration. % To address these issues, this paper proposes a\nknowledge-driven multi-agent framework for intelligent requirement development,\nnamed iReDev. iReDev features: iReDev consists of six knowledge-driven agents\nto support the entire requirements development. They collaboratively perform\nvarious tasks to produce a software requirements specification. iReDev focuses\non integrating human knowledge for agents, enabling them to simulate real-world\nstakeholders. iReDev uses an event-driven communication mechanism based on an\nartifact pool. Agents continuously monitor the pool and autonomously trigger\nthe next action based on its changes, enabling iReDev to handle new\nrequirements quickly. iReDev introduces a human-in-the-loop mechanism to\nsupport human-agent collaboration, ensuring that the generated artifacts align\nwith the expectations of stakeholders. We evaluated the generated artifacts and\nresults show that iReDev outperforms existing baselines in multiple aspects. We\nfurther envision three key directions and hope this work can facilitate the\ndevelopment of intelligent requirements development.", "AI": {"tldr": "The paper presents iReDev, a multi-agent framework designed to improve software requirements development by incorporating human knowledge and enabling dynamic human-agent collaboration. Evaluations show iReDev outperforms existing methods, promising smarter, more effective requirements engineering.", "motivation": "Requirements development is a crucial and challenging phase in software engineering, involving significant collaboration and conflict resolution among stakeholders. Existing multi-agent solutions lack effective support for this phase, especially in terms of integrating human knowledge and fostering human-agent collaboration.", "method": "The paper introduces iReDev, a knowledge-driven multi-agent framework for intelligent requirements development. iReDev comprises six knowledge-driven agents that collaboratively perform tasks required for generating software requirements specifications. Key techniques include event-driven communication via an artifact pool, allowing responsive and autonomous agent actions, and a human-in-the-loop approach to enhance human-agent interactions.", "result": "iReDev was evaluated by assessing the artifacts it generated and comparing them to those produced by baseline approaches. Experimental results indicate that iReDev outperforms existing baselines in multiple aspects of requirements development.", "conclusion": "The iReDev framework enables more intelligent, collaborative, and human-centric requirements development. Its innovative integration of agent autonomy, human knowledge, and iterative collaboration shows superior performance and promises new research directions to further advance intelligent requirements engineering."}}
{"id": "2507.13095", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13095", "abs": "https://arxiv.org/abs/2507.13095", "authors": ["Dongming Jin", "Zhi Jin", "Linyu Li", "Xiaohong Chen"], "title": "A Conceptual Framework for Requirements Engineering of Pretrained-Model-Enabled Systems", "comment": "5pages, 1 figure", "summary": "Recent advances in large pretrained models have led to their widespread\nintegration as core components in modern software systems. The trend is\nexpected to continue in the foreseeable future. Unlike traditional software\nsystems governed by deterministic logic, systems powered by pretrained models\nexhibit distinctive and emergent characteristics, such as ambiguous capability\nboundaries, context-dependent behavior, and continuous evolution. These\nproperties fundamentally challenge long-standing assumptions in requirements\nengineering, including functional decomposability and behavioral\npredictability. This paper investigates this problem and advocates for a\nrethinking of existing requirements engineering methodologies. We propose a\nconceptual framework tailored to requirements engineering of\npretrained-model-enabled software systems and outline several promising\nresearch directions within this framework. This vision helps provide a guide\nfor researchers and practitioners to tackle the emerging challenges in\nrequirements engineering of pretrained-model-enabled systems.", "AI": {"tldr": "Pretrained models in software systems introduce new challenges that traditional requirements engineering can't address. This paper proposes a new framework and research directions to guide future work in this space.", "motivation": "The integration of large pretrained models as core components in modern software systems has introduced distinctive and challenging characteristics, which are fundamentally different from traditional deterministic logic. This shift challenges longstanding assumptions in requirements engineering and creates a need to reassess current methodologies.", "method": "The authors investigate the unique challenges posed by pretrained-model-enabled systems and propose a conceptual framework specifically tailored for requirements engineering in such systems. They also outline promising research directions within this framework.", "result": "A conceptual framework for requirements engineering in software systems powered by pretrained models is proposed. The paper also highlights research directions to address the identified challenges.", "conclusion": "This work advocates for rethinking traditional requirements engineering methodologies in light of the unique properties of pretrained-model-enabled systems. It provides guidance for researchers and practitioners to adapt to the emerging challenges."}}
{"id": "2507.13117", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13117", "abs": "https://arxiv.org/abs/2507.13117", "authors": ["Andreas Pointner", "Josef Pichler", "Herbert Pr\u00e4hofer"], "title": "Inferring Attributed Grammars from Parser Implementations", "comment": "Accepted to ICSME 2025", "summary": "Software systems that process structured inputs often lack complete and\nup-to-date specifications, which specify the input syntax and the semantics of\ninput processing. While grammar mining techniques have focused on recovering\nsyntactic structures, the semantics of input processing remains largely\nunexplored. In this work, we introduce a novel approach for inferring\nattributed grammars from parser implementations. Given an input grammar, our\ntechnique dynamically analyzes the implementation of recursive descent parsers\nto reconstruct the semantic aspects of input handling, resulting in\nspecifications in the form of attributed grammars. By observing program\nexecutions and mapping the program's runtime behavior to the grammar, we\nsystematically extract and embed semantic actions into the grammar rules. This\nenables comprehensive specification recovery. We demonstrate the feasibility of\nour approach using an initial set of programs, showing that it can accurately\nreproduce program behavior through the generated attributed grammars.", "AI": {"tldr": "This paper introduces a dynamic analysis technique to infer both the syntax and semantics of input processing from parser implementations, resulting in accurate and comprehensive attributed grammars that better capture the full input specification compared to existing approaches.", "motivation": "Software systems frequently lack detailed, current specifications describing both the input syntax and processing semantics. Existing grammar mining works primarily address syntax, leaving input-processing semantics insufficiently explored.", "method": "The paper presents a novel method for deriving attributed grammars from the implementations of recursive descent parsers. The approach observes program executions, analyzes the dynamic behavior of the parser, and systematically embeds semantic actions into the grammar rules, reconstructing both syntax and semantics as attributed grammar specifications.", "result": "The proposed method was evaluated using a set of initial programs. The results showed that the approach could accurately reproduce program behavior through the inferred attributed grammars, confirming its effectiveness in recovering complete specifications.", "conclusion": "The study demonstrates that dynamic analysis of parser executions enables the systematic recovery of both syntactic and semantic specifications in the form of attributed grammars. This approach facilitates more comprehensive and accurate specification mining compared to previous grammar mining techniques focused on syntax alone."}}
{"id": "2507.13123", "categories": ["cs.SE"], "pdf": "https://arxiv.org/pdf/2507.13123", "abs": "https://arxiv.org/abs/2507.13123", "authors": ["Xin Yin", "Xinrui Li", "Chao Ni", "Xiaodan Xu", "Xiaohu Yang"], "title": "Detecting LLM-generated Code with Subtle Modification by Adversarial Training", "comment": null, "summary": "With the rapid development of Large Language Models (LLMs), their powerful\ncode-generation capabilities have been widely applied in tasks like code\ncompletion and automated development, demonstrating the value of improving\ncoding efficiency. However, the extensive use of LLM-generated code also raises\nseveral new challenges. On the one hand, issues such as the regulation of code\nprovenance, copyright disputes, and code quality have become increasingly\nconcerning. How to effectively detect LLM-generated code and ensure its\ncompliant and responsible use has become a critical and urgent issue. On the\nother hand, in practical applications, LLM-generated code is often subject to\nmanual modifications, such as variable renaming or structural adjustments.\nAlthough some recent studies have proposed training-based and zero-shot methods\nfor detecting LLM-generated code, these approaches show insufficient robustness\nwhen facing modified LLM-generated code, and there is a lack of an effective\nsolution. To address the real-world scenario where LLM-generated code may\nundergo minor modifications, we propose CodeGPTSensor+, an enhanced version of\nCodeGPTSensor, which employs adversarial training to improve robustness against\ninput perturbations. CodeGPTSensor+ integrates an adversarial sample generation\nmodule, Multi-objective Identifier and Structure Transformation (MIST), which\nsystematically generates both high-quality and representative adversarial\nsamples. This module effectively enhances the model's resistance against\ndiverse adversarial attacks. Experimental results on the HMCorp dataset\ndemonstrate that CodeGPTSensor+ significantly improves detection accuracy on\nthe adversarial test set while maintaining high accuracy on the original test\nset, showcasing superior robustness compared to CodeGPTSensor.", "AI": {"tldr": "The paper introduces CodeGPTSensor+, a more robust model for detecting LLM-generated code, even after modifications like variable renaming. Using adversarial training and a new sample generation module, it outperforms previous methods in both detection accuracy and robustness.", "motivation": "The increasing reliance on Large Language Model (LLM)-generated code introduces concerns about code provenance, copyright, code quality, and the ability to detect machine-generated code, especially when such code is modified manually (e.g., variable renaming). Existing detection methods lack robustness against these modifications, creating a need for more reliable solutions.", "method": "The paper proposes CodeGPTSensor+, an improved version of CodeGPTSensor, designed to detect LLM-generated code even after it has been manually modified. The method uses adversarial training and integrates a module called Multi-objective Identifier and Structure Transformation (MIST) to generate high-quality adversarial samples. These samples help train the model to resist various adversarial attacks and input perturbations.", "result": "CodeGPTSensor+ demonstrates significantly better detection accuracy on adversarially modified code using the HMCorp dataset, while retaining high accuracy on unmodified code. This confirms its improved robustness over the original CodeGPTSensor.", "conclusion": "CodeGPTSensor+ effectively addresses the challenge of detecting LLM-generated code that has undergone minor modifications, achieving superior robustness and accuracy compared to existing methods. Its approach offers a promising solution for responsible and compliant use of AI-generated code."}}
